// dLabPro SDK class CCgen (cgen)
// - Code Generator for dLabPro
//
// AUTHOR : Matthias Wolff
// PACKAGE: dLabPro/sdk
//
// This file was generated by dcg. DO NOT MODIFY! Modify cgen.def instead.
// 
// Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
// - Chair of System Theory and Speech Technology, TU Dresden
// - Chair of Communications Engineering, BTU Cottbus
// 
// This file is part of dLabPro.
// 
// dLabPro is free software: you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
// 
// dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
// details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with dLabPro. If not, see <http://www.gnu.org/licenses/>.


//{{CGEN_INCLUDE
//}}CGEN_END
#include "dlp_cgen.h"

// Class CCgen

CCgen::CCgen(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	DEBUGMSG(-1,"CCgen::CCgen; (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	dlp_strcpy(m_lpClassName,"cgen");
	dlp_strcpy(m_lpObsoleteName,"");
	dlp_strcpy(m_lpProjectName,"cgen");
	dlp_strcpy(m_version.no,"2.5.5");
	dlp_strcpy(m_version.date,"");
	m_nClStyle = CS_AUTOACTIVATE;

	if (bCallVirtual)
	{
		DLPASSERT(OK(AutoRegisterWords()));
		Init(TRUE);
	}
}

CCgen::~CCgen()
{
  //{{CGEN_DONECODE
  DONE;
  //}}CGEN_DONECODE
}

INT16 CCgen::AutoRegisterWords()
{
	DEBUGMSG(-1,"CCgen::AutoRegisterWords",0,0,0);
	IF_NOK(inherited::AutoRegisterWords()) return NOT_EXEC;

	//{{CGEN_REGISTERWORDS
	REGISTER_METHOD("-cgen","",LPMF(CCgen,Cgen),"Generate source and project files.",0,"<cgen this>","")
	REGISTER_METHOD("-listdef","",LPMF(CCgen,Listdef),"-- undocumented feature --",0,"<cgen this>","")
	REGISTER_METHOD("-listwords","",LPMF(CCgen,Listwords),"-- undocumented feature --",0,"<cgen this>","files|defines|includes|errors|fields|options|methods")
	REGISTER_METHOD("-loadAncestor","",LPMF(CCgen,LoadAncestor),"-- DEPRECATED -- Use SUPERCLASS: instead.",0,"<cgen this>","")
	REGISTER_METHOD("-template","",LPMF(CCgen,Template),"-- undocumented feature --",0,"<cgen this>","h|cpp")
	REGISTER_METHOD("AR:","",LPMF(CCgen,OnAr),"-- DEFUNCT SUBKEY --, ignored.",0,"<cgen this>","<filename>")
	REGISTER_METHOD("AUTHOR:","",LPMF(CCgen,OnAuthor),"SUBKEY; Name of autor(s).",0,"<cgen this>","<name>")
	REGISTER_METHOD("AUTOINSTANCE:","",LPMF(CCgen,OnAutoinstance),"SUBKEY; Identifier of automatically created instance.",0,"<cgen this>","<identifier>")
	REGISTER_METHOD("CLASS:","",LPMF(CCgen,OnClass),"SUBKEY; dLabPro identifier of class or library.",0,"<cgen this>","<identifier>")
	REGISTER_METHOD("CLASSCODE:","",LPMF(CCgen,OnClasscode),"CODE SNIPPET: Code executed interpreting instance identifier.",0,"<cgen this>","... END_CODE")
	REGISTER_METHOD("CNAME:","",LPMF(CCgen,OnCname),"SUBKEY; C/C++ identifier of class, library or member.",0,"<cgen this>","<identifier>")
	REGISTER_METHOD("CODE:","",LPMF(CCgen,OnCode),"SUBKEY; Member code snippet.",0,"<cgen this>","... END_CODE")
	REGISTER_METHOD("COMMENT:","",LPMF(CCgen,OnComment),"SUBKEY; Brief description of member (one line).",0,"<cgen this>","<description>")
	REGISTER_METHOD("COMPILER:","",LPMF(CCgen,OnCompiler),"-- DEFUNCT SUBKEY --, ignored.",0,"<cgen this>","<filename>")
	REGISTER_METHOD("COPYCODE:","",LPMF(CCgen,OnCopycode),"CODE SNIPPET: Custom instance copy code.",0,"<cgen this>","... END_CODE")
	REGISTER_METHOD("CSTRUCTNAME:","",LPMF(CCgen,OnCstructname),"SUBKEY; C structure identifier of class (for backward compatibility only).",0,"<cgen this>","<identifier>")
	REGISTER_METHOD("DEFINE:","",LPMF(CCgen,OnDefine),"LIST KEYWORD: Class header",0,"<cgen this>","<statement>")
	REGISTER_METHOD("DONECODE:","",LPMF(CCgen,OnDonecode),"CODE SNIPPET: Custom one-time-destruction code.",0,"<cgen this>","... END_CODE")
	REGISTER_METHOD("ERROR:","",LPMF(CCgen,OnError),"SECTION KEY; Defines an error member.",0,"<cgen this>","<identifier>")
	REGISTER_METHOD("FIELD:","PARAM:",LPMF(CCgen,OnField),"SECTION KEY; Defines a field member.",0,"<cgen this>","<identifier>")
	REGISTER_METHOD("FILE:","",LPMF(CCgen,OnFile),"LIST KEYWORD: Additional C/C++ source file.",0,"<cgen this>","<filename>")
	REGISTER_METHOD("FLAGS:","",LPMF(CCgen,OnFlags),"SUBKEY; SEM/Member properties.",0,"<cgen this>","/hidden|/noset|/nosave|/nonautomatic|/noautoactivate|/singleton|/secondary|/nondistinct")
	REGISTER_METHOD("FRIEND:","",LPMF(CCgen,OnFriend),"LIST KEYWORD: A friend class (dLabPro or C++ identifier)",0,"<cgen this>","<friendclass>")
	REGISTER_METHOD("GCCFLAGS:","CFLAGS:",LPMF(CCgen,OnGccFlags),"SUBKEY; GCC C(++) compiler flags.",0,"<cgen this>","<flags>")
	REGISTER_METHOD("HEADERCODE:","",LPMF(CCgen,OnHeadercode),"CODE SNIPPET: Additional class header code.",0,"<cgen this>","... END_CODE")
	REGISTER_METHOD("HFILE:","",LPMF(CCgen,OnHfile),"SUBKEY; Header file name.",0,"<cgen this>","<filename>")
	REGISTER_METHOD("INCLUDE:","",LPMF(CCgen,OnInclude),"LIST KEYWORD: Additional include file (header).",0,"<cgen this>","<filename>")
	REGISTER_METHOD("INIT:","",LPMF(CCgen,OnInit),"SUBKEY; Initial field value.",0,"<cgen this>","<value>")
	REGISTER_METHOD("INITCODE:","",LPMF(CCgen,OnInitcode),"CODE SNIPPET: Custom one-time-initialization code.",0,"<cgen this>","... END_CODE")
	REGISTER_METHOD("INSTALL:","",LPMF(CCgen,OnInstallClass),"SECTION KEY; Installs a class in a main project.",0,"<cgen this>","<identifier>")
	REGISTER_METHOD("INSTALLCODE:","",LPMF(CCgen,OnInstallcode),"CODE SNIPPET: Class installation procedure",0,"<cgen this>","... END_CODE")
	REGISTER_METHOD("IPATH:","",LPMF(CCgen,OnIpath),"SUBKEY; Include path (relative to SEM home path).",0,"<cgen this>","<path>")
	REGISTER_METHOD("LEVEL:","",LPMF(CCgen,OnLevel),"SUBKEY; Error level of (error) member.",0,"<cgen this>","EL_FATAL|EL_ERROR|EL_WARNING|EL_WARNING2")
	REGISTER_METHOD("LFILE:","",LPMF(CCgen,OnLfile),"SUBKEY; Library file name.",0,"<cgen this>","<filename>")
	REGISTER_METHOD("load","",LPMF(CCgen,OnLoad),"-- DEPRECATED -- Use include instead.",0,"<string sDefFile> <cgen this>","")
	REGISTER_METHOD("LPATH:","",LPMF(CCgen,OnLpath),"SUBKEY; Library path (relative to SEM home path).",0,"<cgen this>","<path>")
	REGISTER_METHOD("MAIN:","",LPMF(CCgen,OnMain),"SECTION KEY; Defines and names a main project.",0,"<cgen this>","<name>")
	REGISTER_METHOD("MAN:","",LPMF(CCgen,OnMan),"SUBKEY; Manual page of SEM/member.",0,"<cgen this>","... END_MAN")
	REGISTER_METHOD("METHOD:","COMMAND:",LPMF(CCgen,OnMethod),"SECTION KEY; Defines a method member.",0,"<cgen this>","<identifier>")
	REGISTER_METHOD("MPATH:","",LPMF(CCgen,OnMpath),"SUBKEY; Manual path (relative to SEM home path).",0,"<cgen this>","<path>")
	REGISTER_METHOD("MSVCFLAGS:","",LPMF(CCgen,OnMsvcFlags),"SUBKEY; MS Visual C++ compiler flags.",0,"<cgen this>","<flags>")
	REGISTER_METHOD("NOTE:","",LPMF(CCgen,OnNote),"SECTION KEY; Defines a release note.",0,"<cgen this>","<identifier>")
	REGISTER_METHOD("OBSOLETE:","",LPMF(CCgen,OnObsolete),"SUBKEY; Obsolete SEM/member identifier.",0,"<cgen this>","<identifier>")
	REGISTER_METHOD("OPATH:","",LPMF(CCgen,OnOpath),"SUBKEY; Object path (relative to SEM home path).",0,"<cgen this>","<path>")
	REGISTER_METHOD("OPTION:","",LPMF(CCgen,OnOption),"SECTION KEY; Defines an option member.",0,"<cgen this>","<identifier>")
	REGISTER_METHOD("PARENT:","",LPMF(CCgen,OnParent),"SUBKEY; Base SEM, additional C++ base classes.",0,"<cgen this>","<identifier>[ C(public|protected <identifier>, ...)]")
	REGISTER_METHOD("PINCLUDE:","",LPMF(CCgen,OnPinclude),"LIST KEYWORD: Additional include file (impl.).",0,"<cgen this>","<filename>")
	REGISTER_METHOD("PLATFORM:","",LPMF(CCgen,OnPlatform),"SUBKEY; C++ compiler platform.",0,"<cgen this>","GNUC++|MSDEV4|MSDEV5")
	REGISTER_METHOD("POSTSYN:","",LPMF(CCgen,OnPostsyn),"SUBKEY; User interpreted post method syntax.",0,"<cgen this>","<regular expression>")
	REGISTER_METHOD("PROJECT:","",LPMF(CCgen,OnProject),"SECTION KEY; Defines and names a class project.",0,"<cgen this>","<name>")
	REGISTER_METHOD("quit","",LPMF(CCgen,Quit),"Finish with definition script.",0,"<cgen this>","")
	REGISTER_METHOD("RESETCODE:","",LPMF(CCgen,OnResetcode),"CODE SNIPPET: Custom instance reset code.",0,"<cgen this>","... END_CODE")
	REGISTER_METHOD("RESTORECODE:","",LPMF(CCgen,OnRestorecode),"CODE SNIPPET: Custom DN3-stream restore code.",0,"<cgen this>","... END_CODE")
	REGISTER_METHOD("SAVECODE:","",LPMF(CCgen,OnSavecode),"CODE SNIPPET: Custom DN3-stream save code.",0,"<cgen this>","... END_CODE")
	REGISTER_METHOD("SUPERCLASS:","",LPMF(CCgen,OnSuperClass),"SUBKEY; Definition file of super class.",0,"<cgen this>","<filename>")
	REGISTER_METHOD("SYNTAX:","",LPMF(CCgen,OnSyntax),"SUBKEY; Method syntax description.",0,"<cgen this>","<syntax description>")
	REGISTER_METHOD("TYPE:","",LPMF(CCgen,OnType),"SUBKEY; Field variable type.",0,"<cgen this>","<identifier>")
	REGISTER_METHOD("VERSION:","",LPMF(CCgen,OnVersion),"SUBKEY; SEM version code.",0,"<cgen this>","<version>")

	// Register options
	REGISTER_OPTION("/append","",LPMV(m_bAppend),NULL,"Continue an existing section.",0)
	REGISTER_OPTION("/cLib","",LPMV(m_bClib),NULL,"Generate documentation for a C/C++ library.",OF_NONAUTOMATIC)
	REGISTER_OPTION("/cProject","",LPMV(m_bCProject),NULL,"Generate ANSI C compatible in interface code.",OF_NONAUTOMATIC)
	REGISTER_OPTION("/cxx_nconv","",LPMV(m_bCxxNconv),NULL,"Use strict C++ naming conventions for member identifiers.",OF_NONAUTOMATIC)
	REGISTER_OPTION("/html","",LPMV(m_bHtml),NULL,"The following <MAN:> section is HTML code.",0)
	REGISTER_OPTION("/no_idcheck","",LPMV(m_bNoIdcheck),NULL,"Do not use dLabPro naming conventions for members id's.",OF_NONAUTOMATIC)
	REGISTER_OPTION("/no_stdincl","",LPMV(m_bNoStdincl),NULL,"Do not use standard header files.",OF_NONAUTOMATIC)
	REGISTER_OPTION("/primary","",LPMV(m_bPrimary),NULL,"Primary method invocation CODE:",0)
	REGISTER_OPTION("/xDoc","",LPMV(m_bXDoc),NULL,"Generate documentation for hidden and private members.",OF_NONAUTOMATIC)
	REGISTER_FIELD("ancestor","",LPMV(m_nAncestor),NULL,"",FF_HIDDEN | FF_NOSET,2002,1,"short",(INT16)0)
	REGISTER_FIELD("author","",LPMV(m_lpsAuthor),NULL,"",FF_HIDDEN | FF_NOSET,100,100,"char[100]","")
	REGISTER_FIELD("autoname","",LPMV(m_lpsAutoname),NULL,"",FF_HIDDEN | FF_NOSET,100,100,"char[100]","")
	REGISTER_FIELD("b_path","",LPMV(m_lpsBPath),NULL,"",FF_HIDDEN | FF_NOSET,255,255,"char[255]","")
	REGISTER_FIELD("bsiFileTmpl","",LPMV(m_bsiFileTmpl),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("c_name","",LPMV(m_lpsCName),NULL,"",FF_HIDDEN | FF_NOSET,100,100,"char[100]","")
	REGISTER_FIELD("c_struct_name","",LPMV(m_lpsCStructName),NULL,"",FF_HIDDEN | FF_NOSET,100,100,"char[100]","")
	REGISTER_FIELD("Cexports","",LPMV(m_Cexports),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("cfns","",LPMV(m_cfns),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGMth>",0)
	REGISTER_FIELD("cl_site_map","",LPMV(m_clSiteMap),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("cl_toc","",LPMV(m_clToc),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("class","",LPMV(m_lpsClass),NULL,"",FF_HIDDEN | FF_NOSET,100,100,"char[100]","")
	REGISTER_FIELD("class_code","",LPMV(m_classCode),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("cmanual","",LPMV(m_cmanual),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("comment","",LPMV(m_lpsComment),NULL,"",FF_HIDDEN | FF_NOSET,255,255,"char[255]","")
	REGISTER_FIELD("copy_code","",LPMV(m_copyCode),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("cppFileTmpl","",LPMV(m_cppFileTmpl),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("creating","",LPMV(m_nCreating),NULL,"",FF_HIDDEN | FF_NOSET,2002,1,"short",(INT16)CR_NOTHING)
	REGISTER_FIELD("creating_err","",LPMV(m_lpCreatingErr),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,6000,1,"SCGErr*",NULL)
	REGISTER_FIELD("creating_fld","",LPMV(m_lpCreatingFld),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,6000,1,"SCGFld*",NULL)
	REGISTER_FIELD("creating_icl","",LPMV(m_lpCreatingIcl),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,6000,1,"SCGIcl*",NULL)
	REGISTER_FIELD("creating_mth","",LPMV(m_lpCreatingMth),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,6000,1,"SCGMth*",NULL)
	REGISTER_FIELD("creating_opt","",LPMV(m_lpCreatingOpt),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,6000,1,"SCGOpt*",NULL)
	REGISTER_FIELD("creating_rnt","",LPMV(m_lpCreatingRnt),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,6000,1,"SCGRnt*",NULL)
	REGISTER_FIELD("CSXXX","",LPMV(m_nCSXXX),NULL,"",FF_HIDDEN | FF_NOSET,2008,1,"long",(INT64)CS_AUTOACTIVATE)
	REGISTER_FIELD("cxx_more_parents","",LPMV(m_lpsCxxMoreParents),NULL,"",FF_HIDDEN | FF_NOSET,100,100,"char[100]","")
	REGISTER_FIELD("cxx_parent","",LPMV(m_lpsCxxParent),NULL,"",FF_HIDDEN | FF_NOSET,100,100,"char[100]","")
	REGISTER_FIELD("cxxWrappers","",LPMV(m_cxxWrappers),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("def_list","",LPMV(m_defList),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("defines","",LPMV(m_defines),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("dlc_parent","",LPMV(m_lpsDlcParent),NULL,"",FF_HIDDEN | FF_NOSET,100,100,"char[100]","")
	REGISTER_FIELD("done_code","",LPMV(m_doneCode),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("dspFileTmpl","",LPMV(m_dspFileTmpl),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("dswFileTmpl","",LPMV(m_dswFileTmpl),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("errors","",LPMV(m_errors),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGErr>",0)
	REGISTER_FIELD("exports","",LPMV(m_exports),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("fgen","",LPMV(m_nFgen),NULL,"",FF_HIDDEN | FF_NOSET,2002,1,"short",(INT16)0)
	REGISTER_FIELD("files","",LPMV(m_files),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGFile>",0)
	REGISTER_FIELD("flds","",LPMV(m_flds),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGFld>",0)
	REGISTER_FIELD("friends","",LPMV(m_friends),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("gcc_flags","",LPMV(m_lpsGccFlags),NULL,"",FF_HIDDEN | FF_NOSET,255,255,"char[255]","")
	REGISTER_FIELD("header_code","",LPMV(m_headerCode),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("hFileTmpl","",LPMV(m_hFileTmpl),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("home_path","",LPMV(m_lpsHomePath),NULL,"",FF_HIDDEN | FF_NOSET,255,255,"char[255]","")
	REGISTER_FIELD("HtmlMan","",LPMV(m_bHtmlMan),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,2002,1,"short",(INT16)0)
	REGISTER_FIELD("i_path","",LPMV(m_lpsIPath),NULL,"",FF_HIDDEN | FF_NOSET,255,255,"char[255]","")
	REGISTER_FIELD("icls","",LPMV(m_icls),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGIcl>",0)
	REGISTER_FIELD("includes","",LPMV(m_includes),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("init_code","",LPMV(m_initCode),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("install_code","",LPMV(m_installCode),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("l_files","",LPMV(m_lFiles),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("l_path","",LPMV(m_lpsLPath),NULL,"",FF_HIDDEN | FF_NOSET,255,255,"char[255]","")
	REGISTER_FIELD("libfile","",LPMV(m_lpsLibfile),NULL,"",FF_HIDDEN | FF_NOSET,64,64,"char[64]","")
	REGISTER_FIELD("m_path","",LPMV(m_lpsMPath),NULL,"",FF_HIDDEN | FF_NOSET,255,255,"char[255]","")
	REGISTER_FIELD("mainProject","",LPMV(m_bMainProject),NULL,"",FF_HIDDEN | FF_NOSET,1000,1,"bool",(BOOL)0)
	REGISTER_FIELD("makFileTmpl","",LPMV(m_makFileTmpl),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("manual","",LPMV(m_manual),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("MSD_path","",LPMV(m_lpsMSDPath),NULL,"",FF_HIDDEN | FF_NOSET,255,255,"char[255]","")
	REGISTER_FIELD("msvc_flags","",LPMV(m_lpsMsvcFlags),NULL,"",FF_HIDDEN | FF_NOSET,255,255,"char[255]","")
	REGISTER_FIELD("mths","",LPMV(m_mths),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGMth>",0)
	REGISTER_FIELD("NMake_section","",LPMV(m_nNMakeSection),NULL,"",FF_HIDDEN | FF_NOSET,2002,1,"short",(INT16)NMS_RELEASE)
	REGISTER_FIELD("nmakFileTmpl","",LPMV(m_nmakFileTmpl),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("o_path","",LPMV(m_lpsOPath),NULL,"",FF_HIDDEN | FF_NOSET,255,255,"char[255]","")
	REGISTER_FIELD("obsolete","",LPMV(m_lpsObsolete),NULL,"",FF_HIDDEN | FF_NOSET,100,100,"char[100]","")
	REGISTER_FIELD("opts","",LPMV(m_opts),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGOpt>",0)
	REGISTER_FIELD("package","",LPMV(m_lpsPackage),NULL,"",FF_HIDDEN | FF_NOSET,100,100,"char[100]","")
	REGISTER_FIELD("parent_project","",LPMV(m_lpsParentProject),NULL,"",FF_HIDDEN | FF_NOSET,100,100,"char[100]","")
	REGISTER_FIELD("parser","",LPMV(m_iParser),NULL,"",FF_HIDDEN | FF_NOSET | FF_NOSAVE,6002,1,"CDgen",NULL)
	REGISTER_FIELD("pincludes","",LPMV(m_pincludes),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("platform","",LPMV(m_nPlatform),NULL,"",FF_HIDDEN | FF_NOSET,2002,1,"short",(INT16)0)
	REGISTER_FIELD("project","",LPMV(m_lpsProject),NULL,"",FF_HIDDEN | FF_NOSET,100,100,"char[100]","")
	REGISTER_FIELD("reset_code","",LPMV(m_resetCode),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("restore_code","",LPMV(m_restoreCode),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("rnts","",LPMV(m_rnts),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGRnt>",0)
	REGISTER_FIELD("save_code","",LPMV(m_saveCode),NULL,"",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,10000,1,"CList<SCGStr>",0)
	REGISTER_FIELD("verbose","",LPMV(m_nVerbose),NULL,"The verbose level.",0,2004,1,"int",(INT32)0)
	REGISTER_FIELD("version","",LPMV(m_lpsVersion),NULL,"",FF_HIDDEN | FF_NOSET,20,20,"char[20]","")
	REGISTER_ERROR("~e6_2_0__1",EL_WARNING,ERR_DEPRECATED,"%s is deprecated. %s")
	REGISTER_ERROR("~e7_2_0__1",EL_ERROR,ERR_EXPECTAFTER,"Expect %s after identifier '%s'.")
	REGISTER_ERROR("~e8_2_0__1",EL_ERROR,ERR_EXPECTIDAFTER,"Expect identifier after '%s' (creating '%s').")
	REGISTER_ERROR("~e9_2_0__1",EL_WARNING,ERR_DDEF_LIST,"%s '%s' is already defined. New definition ignored.")
	REGISTER_ERROR("~e0_3_0__1",EL_ERROR,ERR_CANNOTCREATE,"%s '%s' cannot be created.")
	REGISTER_ERROR("~e1_3_0__1",EL_WARNING,ERR_INVALMETHOD,"Method '%s' is not allowed in '%s' projects.")
	REGISTER_ERROR("~e2_3_0__1",EL_WARNING,ERR_INVALKEY,"Key '%s' is not allowed in '%s' projects.")
	REGISTER_ERROR("~e3_3_0__1",EL_WARNING,ERR_INVALSUBKEY,"Section '%s' does not allow the '%s' subkey.")
	REGISTER_ERROR("~e4_3_0__1",EL_ERROR,ERR_EXPGLOBALKEY,"Expect section keyword before '%s'.")
	REGISTER_ERROR("~e5_3_0__1",EL_FATAL,ERR_EXPPROJECT,"Expect 'PROJECT:' before '%s'.")
	REGISTER_ERROR("~e6_3_0__1",EL_ERROR,ERR_EXPECTENDMARK,"Unexpected end of file scanning for '%s'.")
	REGISTER_ERROR("~e7_3_0__1",EL_WARNING,ERR_TOOMANYPARS,"Too many actual parameters follow '%s' (creating '%s').")
	REGISTER_ERROR("~e8_3_0__1",EL_WARNING,ERR_UNKNOWNTYPE,"Field type '%s' unknown. Assuming pointer type.")
	REGISTER_ERROR("~e9_3_0__1",EL_ERROR,ERR_CREATEFILE,"Cannot create this file: '%s'.")
	REGISTER_ERROR("~e0_4_0__1",EL_ERROR,ERR_OPENFILE,"Cannot open this file or folder: '%s'.")
	REGISTER_ERROR("~e1_4_0__1",EL_WARNING,ERR_MISSCOMMENT,"No COMMENT: defined creating %s '%s'.")
	REGISTER_ERROR("~e2_4_0__1",EL_WARNING,ERR_MISSTYPE,"No TYPE: defined creating %s '%s'. Assuming type 'short'.")
	REGISTER_ERROR("~e3_4_0__1",EL_WARNING3,ERR_MISSINIT,"No INIT: defined creating %s '%s'. Assuming %s.")
	REGISTER_ERROR("~e4_4_0__1",EL_WARNING,ERR_MISSSYNTAX,"No SYNTAX: defined creating %s '%s'. Assuming none.")
	REGISTER_ERROR("~e5_4_0__1",EL_ERROR,ERR_BADSYNTAX,"Bad SYNTAX: description.")
	REGISTER_ERROR("~e6_4_0__1",EL_ERROR,ERR_BADRETTYPE,"Type '%s' is not supported for return values.")
	REGISTER_ERROR("~e7_4_0__1",EL_WARNING3,ERR_MISSNOTE,"NOTE: '%s' does not contain a MAN text.")
	REGISTER_ERROR("~e8_4_0__1",EL_WARNING,ERR_DATAUNDEFDW,"No %s defined creating %s. Assuming none.")
	REGISTER_ERROR("~e9_4_0__1",EL_ERROR,ERR_DATAUNDEFD,"Required parameter %s was not defined.")
	REGISTER_ERROR("~e0_5_0__1",EL_FATAL,ERR_VERIFYDATA,"Cannot make source files because of missing data.")
	REGISTER_ERROR("~e1_5_0__1",EL_FATAL,ERR_NOPLATFORM,"The platform '%s' is not supported or unknown.")
	REGISTER_ERROR("~e2_5_0__1",EL_FATAL,ERR_NOMSVCFOUND,"MS Visual C++ tools not found.")
	REGISTER_ERROR("~e3_5_0__1",EL_WARNING,ERR_WRONGMSVCVERSION,"Specified MS Visual C++ version not found. Changed to V%d.0!")
	REGISTER_ERROR("~e4_5_0__1",EL_ERROR,ERR_FILETYPE,"*%s - files are not supported as soures.")
	REGISTER_ERROR("~e5_5_0__1",EL_WARNING,ERR_POINTERINIT,"INIT: is not allowed on pointer types. Definition ignored.")
	REGISTER_ERROR("~e6_5_0__1",EL_WARNING,ERR_UNKNOWNARGTYPE,"Argument type '%s' unknown. Assuming instance type.")
	REGISTER_ERROR("~e7_5_0__1",EL_WARNING2,ERR_INFUNCTION,"In function '%s' (%s:%d):")
	REGISTER_ERROR("~e8_5_0__1",EL_WARNING3,ERR_INFUNCTION2,"In function '%s' (%s:%d):")
	REGISTER_ERROR("~e9_5_0__1",EL_WARNING2,ERR_INLINE,"In line %s(%d):")
	REGISTER_ERROR("~e0_6_0__1",EL_ERROR,ERR_PARSEERR,"Parse error in %s near '%s'.")
	REGISTER_ERROR("~e1_6_0__1",EL_ERROR,ERR_PARSEERR2,"Parse error: %s.")
	REGISTER_ERROR("~e2_6_0__1",EL_ERROR,ERR_PARSEERR_ARG,"Parse error in argument %d: %s.")
	REGISTER_ERROR("~e3_6_0__1",EL_WARNING,ERR_ELLIPSIS,"Ellipses not supported by generated C++ wrapper functions.")
	REGISTER_ERROR("~e4_6_0__1",EL_WARNING,ERR_CPROJECT,"Switched to C-mode because of C style member function(s).")
	REGISTER_ERROR("~e5_6_0__1",EL_ERROR,ERR_BADIDENTIFIER,"%s indentifier '%s' unknown.")
	REGISTER_ERROR("~e6_6_0__1",EL_ERROR,ERR_INVALARRLEN,"Invalid array length specifier '%s'.")
	REGISTER_ERROR("~e7_6_0__1",EL_WARNING,ERR_MULTIARRAY,"Multidimensional arrays are not supported.")
	REGISTER_ERROR("~e8_6_0__1",EL_ERROR,ERR_EXPECT,"Expect '%s'%s.")
	REGISTER_ERROR("~e9_6_0__1",EL_ERROR,ERR_TOOLEXEC,"Cannot execute '%s'.")
	REGISTER_ERROR("~e0_7_0__1",EL_WARNING,ERR_BADIDCHAR,"'%s': identifier must not contain '%c'.")
	REGISTER_ERROR("~e1_7_0__1",EL_WARNING,ERR_BADLEAD,"'%s': %ss should not start with '%c'.")
	REGISTER_ERROR("~e2_7_0__1",EL_ERROR,ERR_APPEND,"Cannot append to %s '%s'.")
	REGISTER_ERROR("~e3_7_0__1",EL_WARNING,ERR_NOBASECALL,"Base call ('%s') not found in %s.")
	REGISTER_ERROR("~e4_7_0__1",EL_ERROR,ERR_BADOPTION,"Option %s can %s be used %s.")
	REGISTER_ERROR("~e5_7_0__1",EL_ERROR,ERR_UNEXPECTEDEOF,"Unexpected end of file scanning for %s.")
	REGISTER_ERROR("~e6_7_0__1",EL_WARNING,ERR_EXTRA_HTML,"Extra custom HTML code removed. See file '%s'.")
	REGISTER_ERROR("~e7_7_0__1",EL_WARNING,ERR_TOOLONG,"%s(%ld): %s too long.")
	REGISTER_ERROR("~e8_7_0__1",EL_WARNING,ERR_UNKNOWN,"Unknown %s '%s'. %s.")
	REGISTER_ERROR("~e9_7_0__1",EL_WARNING,ERR_RESJDLINK,"Cannot resolve JavaDoc link '%s'.")
	REGISTER_ERROR("~e0_8_0__1",EL_ERROR,ERR_INVALARGS,"Invalid command line arguments.")
	//}}CGEN_REGISTERWORDS

	return O_K;
}

INT16 CCgen::Init(BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CCgen::Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	//{{CGEN_INITCODE
  INIT;

  // Initialize "creating" members
  SetErrorLevel(3);             // Disable lowest level warnings
  SetCreating(CR_NOTHING,NULL);
	//}}CGEN_INITCODE

	// If last derivation call reset (do not reset members; already done by Init())
	if (bCallVirtual) return Reset(FALSE);
	else              return O_K;
}

INT16 CCgen::Reset(BOOL bResetMembers)
{
	DEBUGMSG(-1,"CCgen::Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	//{{CGEN_RESETCODE
  RESET;
  IFIELD_RESET(CDgen,"parser");
  m_iParser->Setup("def");
	//}}CGEN_RESETCODE

	return O_K;
}

INT16 CCgen::ClassProc()
{
	//{{CGEN_CLASSCODE
  return CLASSPROC;
	//}}CGEN_CLASSCODE

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CCgen::Serialize(CDN3Stream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CCgen::SerializeXml(CXmlStream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CCgen::Deserialize(CDN3Stream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CCgen::DeserializeXml(CXmlStream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CCgen::Copy(CDlpObject* __iSrc)
{
	//{{CGEN_COPYCODE
  return COPY;
	//}}CGEN_COPYCODE

	return O_K;
}

// Runtime class type information and class factory
INT16 CCgen::InstallProc(void* lpItp)
{
	//{{CGEN_INSTALLCODE
  return INSTALL;
	//}}CGEN_INSTALLCODE

	return O_K;
}

CCgen* CCgen::CreateInstance(const char* lpName)
{
	CCgen* lpNewInstance;
	ICREATEEX(CCgen,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CCgen::GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOACTIVATE;
	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CCgen::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CCgen::InstallProc;
	lpClassWord->ex.fct.lpProject   = "cgen";
	lpClassWord->ex.fct.lpBaseClass = "function";
	lpClassWord->lpComment          = "Code Generator for dLabPro";
	lpClassWord->ex.fct.lpAutoname  = "";
	lpClassWord->ex.fct.lpCname     = "CCgen";
	lpClassWord->ex.fct.lpAuthor    = "Matthias Wolff";

	dlp_strcpy(lpClassWord->lpName             ,"cgen");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"2.5.5");

	return O_K;
}

INT16 CCgen::GetInstanceInfo(SWord* lpClassWord)
{
	return CCgen::GetClassInfo(lpClassWord);
}

BOOL CCgen::IsKindOf(const char* lpClassName)
{
  if (dlp_strncmp(lpClassName,"cgen",L_NAMES) == 0) return TRUE;
  else return inherited::IsKindOf(lpClassName);
}

INT16 CCgen::ResetAllOptions(BOOL bInit)
{
	DEBUGMSG(-1,"CCgen::ResetAllOptions;",0,0,0);
	//{{CGEN_RESETALLOPTIONS
	_this->m_bAppend = FALSE;
	if (bInit) _this->m_bClib = FALSE;
	if (bInit) _this->m_bCProject = FALSE;
	if (bInit) _this->m_bCxxNconv = FALSE;
	_this->m_bHtml = FALSE;
	if (bInit) _this->m_bNoIdcheck = FALSE;
	if (bInit) _this->m_bNoStdincl = FALSE;
	_this->m_bPrimary = FALSE;
	if (bInit) _this->m_bXDoc = FALSE;
	//}}CGEN_RESETALLOPTIONS

	return inherited::ResetAllOptions(bInit);
}

// Generated primary method invocation functions

#ifndef __NOITP
//{{CGEN_PMIC
INT16 CCgen::OnLoad()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	char* sDefFile = MIC_GET_S(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Load(sDefFile);
	return __nErr;
}

//}}CGEN_PMIC
#endif /* #ifndef __NOITP */


// Generated secondary method invocation functions

//{{CGEN_SMIC
INT16 CCgen::Listdef()
{
      m_defList.PrintList();
	return O_K;
}

INT16 CCgen::Load(char* sDefFile)
{
    IERROR(this,ERR_DEPRECATED,"load",  "Use include instead!",0);
    return Include(sDefFile);
	return O_K;
}

//}}CGEN_SMIC


// Generated option change callback functions

//{{CGEN_OCCF
//}}CGEN_OCCF


// Generated field change callback functions

//{{CGEN_FCCF
//}}CGEN_FCCF


// EOF
