// dLabPro class CHFAproc (HFAproc)
// - Harmonicity based feature analysis
//
// AUTHOR : Rico Petrick, Mike Lorenz
// PACKAGE: dLabPro/classes
//
// This file was generated by dcg. DO NOT MODIFY! Modify hfaproc.def instead.
// 
// Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
// - Chair of System Theory and Speech Technology, TU Dresden
// - Chair of Communications Engineering, BTU Cottbus
// 
// This file is part of dLabPro.
// 
// dLabPro is free software: you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
// 
// dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
// details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with dLabPro. If not, see <http://www.gnu.org/licenses/>.


//{{CGEN_INCLUDE
//}}CGEN_END
#include "dlp_hfaproc.h"

// Class CHFAproc

CHFAproc::CHFAproc(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	DEBUGMSG(-1,"CHFAproc::CHFAproc; (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	dlp_strcpy(m_lpClassName,"HFAproc");
	dlp_strcpy(m_lpObsoleteName,"");
	dlp_strcpy(m_lpProjectName,"HFAproc");
	dlp_strcpy(m_version.no,"1.0");
	dlp_strcpy(m_version.date,"");
	m_nClStyle = CS_AUTOACTIVATE;

	if (bCallVirtual)
	{
		DLPASSERT(OK(AutoRegisterWords()));
		Init(TRUE);
	}
}

CHFAproc::~CHFAproc()
{
  //{{CGEN_DONECODE
   hfa_done(m_lpStrHFA);
  DONE;
  //}}CGEN_DONECODE
}

INT16 CHFAproc::AutoRegisterWords()
{
	DEBUGMSG(-1,"CHFAproc::AutoRegisterWords",0,0,0);
	IF_NOK(inherited::AutoRegisterWords()) return NOT_EXEC;

	//{{CGEN_REGISTERWORDS

	// Register fields
	REGISTER_FIELD("atype","",LPMV(m_lpsAtype),NULL,"Filter type after HFA",0,50,50,"char[50]","")
	REGISTER_FIELD("coeff","",LPMV(m_nCoeff),NULL,"",FF_HIDDEN | FF_NOSET,2002,1,"short",(INT16)30)
	REGISTER_FIELD("DCTswitch","",LPMV(m_nDCTswitch),NULL,"DCT on/off",0,2002,1,"short",(INT16)0)
	REGISTER_FIELD("exp","",LPMV(m_nExp),NULL,"exponent for hfa",0,2002,1,"short",(INT16)0)
	REGISTER_FIELD("f0max","",LPMV(m_nF0max),NULL,"fundamental frequency range in Hz (max)",0,2002,1,"short",(INT16)0)
	REGISTER_FIELD("f0min","",LPMV(m_nF0min),NULL,"fundamental frequency range in Hz (min)",0,2002,1,"short",(INT16)0)
	REGISTER_FIELD("HFAswitch","",LPMV(m_nHFAswitch),NULL,"HFA on/off",0,2002,1,"short",(INT16)0)
	REGISTER_FIELD("limit","",LPMV(m_nLimit),NULL,"",FF_HIDDEN | FF_NOSET,3004,1,"float",(FLOAT32)127.)
	REGISTER_FIELD("p_offset","",LPMV(m_nPOffset),NULL,"unvoiced frame fade window offset in Hz",0,2002,1,"short",(INT16)0)
	REGISTER_FIELD("p_width","",LPMV(m_nPWidth),NULL,"unvoiced frame fade window width",0,2002,1,"short",(INT16)0)
	REGISTER_FIELD("par1","",LPMV(m_nPar1),NULL,"dummy parameter",0,3004,1,"float",(FLOAT32)0.f)
	REGISTER_FIELD("par10","",LPMV(m_nPar10),NULL,"dummy parameter",0,3004,1,"float",(FLOAT32)0.f)
	REGISTER_FIELD("par2","",LPMV(m_nPar2),NULL,"dummy parameter",0,3004,1,"float",(FLOAT32)0.f)
	REGISTER_FIELD("par3","",LPMV(m_nPar3),NULL,"dummy parameter",0,3004,1,"float",(FLOAT32)0.f)
	REGISTER_FIELD("par4","",LPMV(m_nPar4),NULL,"dummy parameter",0,3004,1,"float",(FLOAT32)0.f)
	REGISTER_FIELD("par5","",LPMV(m_nPar5),NULL,"dummy parameter",0,3004,1,"float",(FLOAT32)0.f)
	REGISTER_FIELD("par6","",LPMV(m_nPar6),NULL,"dummy parameter",0,3004,1,"float",(FLOAT32)0.f)
	REGISTER_FIELD("par7","",LPMV(m_nPar7),NULL,"dummy parameter",0,3004,1,"float",(FLOAT32)0.f)
	REGISTER_FIELD("par8","",LPMV(m_nPar8),NULL,"dummy parameter",0,3004,1,"float",(FLOAT32)0.f)
	REGISTER_FIELD("par9","",LPMV(m_nPar9),NULL,"dummy parameter",0,3004,1,"float",(FLOAT32)0.f)
	REGISTER_FIELD("strHFA","",LPMV(m_lpStrHFA),NULL,"HFA structure for parameters",0,6000,1,"tHFA*",NULL)
	REGISTER_FIELD("v_offset","",LPMV(m_nVOffset),NULL,"voiced frame fade window offset in Hz",0,2002,1,"short",(INT16)0)
	REGISTER_FIELD("v_width","",LPMV(m_nVWidth),NULL,"voiced frame fade window width",0,2002,1,"short",(INT16)0)
	REGISTER_FIELD("VAD","",LPMV(m_nVAD),NULL,"VAD on/off",0,2002,1,"short",(INT16)0)
	REGISTER_FIELD("VADmean_fac","",LPMV(m_nVADmeanFac),NULL,"VAD decision factor",0,3004,1,"float",(FLOAT32)0.f)
	REGISTER_FIELD("VADthresh","",LPMV(m_nVADthresh),NULL,"VAD decision threshold",0,2002,1,"short",(INT16)0)
	REGISTER_FIELD("VADtype","",LPMV(m_lpsVADtype),NULL,"VAD type",0,50,50,"char[50]","")
	REGISTER_FIELD("wtypefft","",LPMV(m_lpsWtypefft),NULL,"Window type",0,50,50,"char[50]","")
	//}}CGEN_REGISTERWORDS

	return O_K;
}

INT16 CHFAproc::Init(BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CHFAproc::Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	//{{CGEN_INITCODE
  INIT;
  m_lpStrHFA=(tHFA *)dlp_calloc(1,sizeof(tHFA));
	//}}CGEN_INITCODE

	// If last derivation call reset (do not reset members; already done by Init())
	if (bCallVirtual) return Reset(FALSE);
	else              return O_K;
}

INT16 CHFAproc::Reset(BOOL bResetMembers)
{
	DEBUGMSG(-1,"CHFAproc::Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	//{{CGEN_RESETCODE
  return RESET;
	//}}CGEN_RESETCODE

	return O_K;
}

INT16 CHFAproc::ClassProc()
{
	//{{CGEN_CLASSCODE
  return CLASSPROC;
	//}}CGEN_CLASSCODE

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CHFAproc::Serialize(CDN3Stream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CHFAproc::SerializeXml(CXmlStream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CHFAproc::Deserialize(CDN3Stream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CHFAproc::DeserializeXml(CXmlStream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CHFAproc::Copy(CDlpObject* __iSrc)
{
	//{{CGEN_COPYCODE
  return COPY;
	//}}CGEN_COPYCODE

	return O_K;
}

// Runtime class type information and class factory
INT16 CHFAproc::InstallProc(void* lpItp)
{
	//{{CGEN_INSTALLCODE
  return INSTALL;
	//}}CGEN_INSTALLCODE

	return O_K;
}

CHFAproc* CHFAproc::CreateInstance(const char* lpName)
{
	CHFAproc* lpNewInstance;
	ICREATEEX(CHFAproc,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CHFAproc::GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOACTIVATE;
	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CHFAproc::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CHFAproc::InstallProc;
	lpClassWord->ex.fct.lpProject   = "HFAproc";
	lpClassWord->ex.fct.lpBaseClass = "FBAproc";
	lpClassWord->lpComment          = "Harmonicity based feature analysis";
	lpClassWord->ex.fct.lpAutoname  = "";
	lpClassWord->ex.fct.lpCname     = "CHFAproc";
	lpClassWord->ex.fct.lpAuthor    = "Rico Petrick, Mike Lorenz";

	dlp_strcpy(lpClassWord->lpName             ,"HFAproc");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"1.0");

	return O_K;
}

INT16 CHFAproc::GetInstanceInfo(SWord* lpClassWord)
{
	return CHFAproc::GetClassInfo(lpClassWord);
}

BOOL CHFAproc::IsKindOf(const char* lpClassName)
{
  if (dlp_strncmp(lpClassName,"HFAproc",L_NAMES) == 0) return TRUE;
  else return inherited::IsKindOf(lpClassName);
}

INT16 CHFAproc::ResetAllOptions(BOOL bInit)
{
	DEBUGMSG(-1,"CHFAproc::ResetAllOptions;",0,0,0);
	//{{CGEN_RESETALLOPTIONS
	//}}CGEN_RESETALLOPTIONS

	return inherited::ResetAllOptions(bInit);
}

// Generated primary method invocation functions

#ifndef __NOITP
//{{CGEN_PMIC
//}}CGEN_PMIC
#endif /* #ifndef __NOITP */


// Generated secondary method invocation functions

//{{CGEN_SMIC
//}}CGEN_SMIC


// Generated option change callback functions

//{{CGEN_OCCF
//}}CGEN_OCCF


// Generated field change callback functions

//{{CGEN_FCCF
//}}CGEN_FCCF


// EOF
