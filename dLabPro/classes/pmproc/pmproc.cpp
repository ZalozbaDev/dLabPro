// dLabPro class CPMproc (PMproc)
// - Base class for pitch calculation.
//
// AUTHOR : Guntram Strecha
// PACKAGE: dLabPro/classes
//
// This file was generated by dcg. DO NOT MODIFY! Modify pmproc.def instead.
// 
// Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
// - Chair of System Theory and Speech Technology, TU Dresden
// - Chair of Communications Engineering, BTU Cottbus
// 
// This file is part of dLabPro.
// 
// dLabPro is free software: you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
// 
// dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
// details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with dLabPro. If not, see <http://www.gnu.org/licenses/>.


//{{CGEN_INCLUDE
//}}CGEN_END
#include "dlp_pmproc.h"

// Class CPMproc

CPMproc::CPMproc(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	DEBUGMSG(-1,"CPMproc::CPMproc; (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	dlp_strcpy(m_lpClassName,"PMproc");
	dlp_strcpy(m_lpObsoleteName,"");
	dlp_strcpy(m_lpProjectName,"PMproc");
	dlp_strcpy(m_version.no,"1.0 DLP");
	dlp_strcpy(m_version.date,"");
	m_nClStyle = CS_AUTOACTIVATE;

	if (bCallVirtual)
	{
		DLPASSERT(OK(AutoRegisterWords()));
		Init(TRUE);
	}
}

CPMproc::~CPMproc()
{
  //{{CGEN_DONECODE
  ChfaFreeTables();
  DONE;
  //}}CGEN_DONECODE
}

INT16 CPMproc::AutoRegisterWords()
{
	DEBUGMSG(-1,"CPMproc::AutoRegisterWords",0,0,0);
	IF_NOK(inherited::AutoRegisterWords()) return NOT_EXEC;

	//{{CGEN_REGISTERWORDS

	// Register methods
	REGISTER_METHOD("-analyze","",LPMF(CPMproc,OnAnalyze),"Run pitch marking.",0,"<data idSignal> <data idPitch> <PMproc this>","")
	REGISTER_METHOD("-compress_pm","",LPMF(CPMproc,OnCompressPm),"Expand/reduce number of pitch markers to new number.",0,"<data idSrc> <data idDst> <int n> <PMproc this>","")
	REGISTER_METHOD("-expand_pm","",LPMF(CPMproc,OnExpandPm),"Expand/reduce number of pitch markers to fit new target sum of period length.",0,"<data idSrc> <data idDst> <int n> <PMproc this>","")
	REGISTER_METHOD("-f02pm","",LPMF(CPMproc,OnF02pm),"Convert f0-contour with equal spaced sampling points to pitch markers.",0,"<data idSrc> <data idDst> <int n> <int srate> <PMproc this>","")
	REGISTER_METHOD("-fill","",LPMF(CPMproc,OnFill),"Add periods to reach desired sum od periods.",0,"<data idSrc> <data idDst> <int n> <cstring method> <PMproc this>","")
	REGISTER_METHOD("-pm2f0","",LPMF(CPMproc,OnPm2f0),"Convert (unequal spaced) pitch markers to f0-contour with equal spaced sampling points.",0,"<data idSrc> <data idDst> <int n> <int srate> <PMproc this>","")

	// Register options
	REGISTER_OPTION("/chfa","",LPMV(m_bChfa),NULL,"Compute pitch markers using Complex Harmonic Filter Analysis (CHFA).",0)
	REGISTER_OPTION("/epochdetect","",LPMV(m_bEpochdetect),NULL,"Compute pitch markers using EpochDetect method.",0)
	REGISTER_OPTION("/gcida","",LPMV(m_bGcida),NULL,"Compute pitch markers using GCIDA.",0)
	REGISTER_OPTION("/hybrid","",LPMV(m_bHybrid),NULL,"Compute pitch markers using hybrid method.",0)

	// Register fields
	REGISTER_FIELD("filt_b_i","",LPMV(m_lpFiltBI),NULL,"Internal filter table.",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,6000,1,"double**",NULL)
	REGISTER_FIELD("filt_b_r","",LPMV(m_lpFiltBR),NULL,"Internal filter table.",FF_HIDDEN | FF_NOSET | FF_NONAUTOMATIC,6000,1,"double**",NULL)
	REGISTER_FIELD("level","",LPMV(m_nLevel),NULL,"Adjust voiceless/voiced decision. Higher values produce more voiceless periods.",0,3008,1,"double",(FLOAT64)2.0)
	REGISTER_FIELD("max","",LPMV(m_nMax),LPMF(CPMproc,OnMaxChanged),"Maximum base F0.",0,2002,1,"short",(INT16)400)
	REGISTER_FIELD("mean","",LPMV(m_nMean),NULL,"Mean base F0.",0,2002,1,"short",(INT16)100)
	REGISTER_FIELD("min","",LPMV(m_nMin),LPMF(CPMproc,OnMinChanged),"Minimum base F0.",0,2002,1,"short",(INT16)50)
	REGISTER_FIELD("srate","",LPMV(m_nSrate),NULL,"Sample rate.",0,2004,1,"int",(INT32)16000)

	// Register errors
	REGISTER_ERROR("~e1_0_0__1",EL_ERROR,PM_SIGLENGTH,"To many voiced segments (%d). Reduce the length of speech signal.")
	REGISTER_ERROR("~e2_0_0__1",EL_ERROR,PM_FFTSIZE,"Precomputed trig tables are not big enough in fft (%d < %d).")
	//}}CGEN_REGISTERWORDS

	return O_K;
}

INT16 CPMproc::Init(BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CPMproc::Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	//{{CGEN_INITCODE
  INIT;
	//}}CGEN_INITCODE

	// If last derivation call reset (do not reset members; already done by Init())
	if (bCallVirtual) return Reset(FALSE);
	else              return O_K;
}

INT16 CPMproc::Reset(BOOL bResetMembers)
{
	DEBUGMSG(-1,"CPMproc::Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	//{{CGEN_RESETCODE
  RESET;
	//}}CGEN_RESETCODE

	return O_K;
}

INT16 CPMproc::ClassProc()
{
	//{{CGEN_CLASSCODE
  return CLASSPROC;
	//}}CGEN_CLASSCODE

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CPMproc::Serialize(CDN3Stream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CPMproc::SerializeXml(CXmlStream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CPMproc::Deserialize(CDN3Stream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CPMproc::DeserializeXml(CXmlStream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CPMproc::Copy(CDlpObject* __iSrc)
{
	//{{CGEN_COPYCODE
  return COPY;
	//}}CGEN_COPYCODE

	return O_K;
}

// Runtime class type information and class factory
INT16 CPMproc::InstallProc(void* lpItp)
{
	//{{CGEN_INSTALLCODE
  return INSTALL;
	//}}CGEN_INSTALLCODE

	return O_K;
}

CPMproc* CPMproc::CreateInstance(const char* lpName)
{
	CPMproc* lpNewInstance;
	ICREATEEX(CPMproc,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CPMproc::GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOACTIVATE;
	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CPMproc::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CPMproc::InstallProc;
	lpClassWord->ex.fct.lpProject   = "PMproc";
	lpClassWord->ex.fct.lpBaseClass = "-";
	lpClassWord->lpComment          = "Base class for pitch calculation.";
	lpClassWord->ex.fct.lpAutoname  = "";
	lpClassWord->ex.fct.lpCname     = "CPMproc";
	lpClassWord->ex.fct.lpAuthor    = "Guntram Strecha";

	dlp_strcpy(lpClassWord->lpName             ,"PMproc");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"1.0 DLP");

	return O_K;
}

INT16 CPMproc::GetInstanceInfo(SWord* lpClassWord)
{
	return CPMproc::GetClassInfo(lpClassWord);
}

BOOL CPMproc::IsKindOf(const char* lpClassName)
{
  if (dlp_strncmp(lpClassName,"PMproc",L_NAMES) == 0) return TRUE;
  else return inherited::IsKindOf(lpClassName);
}

INT16 CPMproc::ResetAllOptions(BOOL bInit)
{
	DEBUGMSG(-1,"CPMproc::ResetAllOptions;",0,0,0);
	//{{CGEN_RESETALLOPTIONS
	_this->m_bChfa = FALSE;
	_this->m_bEpochdetect = FALSE;
	_this->m_bGcida = FALSE;
	_this->m_bHybrid = FALSE;
	//}}CGEN_RESETALLOPTIONS

	return inherited::ResetAllOptions(bInit);
}

// Generated primary method invocation functions

#ifndef __NOITP
//{{CGEN_PMIC
INT16 CPMproc::OnAnalyze()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idPitch = MIC_GET_I_EX(idPitch,data,1,1);
	data* idSignal = MIC_GET_I_EX(idSignal,data,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Analyze(idSignal, idPitch);
	return __nErr;
}

INT16 CPMproc::OnCompressPm()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 n = (INT32)MIC_GET_N(1,0);
	data* idDst = MIC_GET_I_EX(idDst,data,2,1);
	data* idSrc = MIC_GET_I_EX(idSrc,data,3,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CompressPm(idSrc, idDst, n);
	return __nErr;
}

INT16 CPMproc::OnExpandPm()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 n = (INT32)MIC_GET_N(1,0);
	data* idDst = MIC_GET_I_EX(idDst,data,2,1);
	data* idSrc = MIC_GET_I_EX(idSrc,data,3,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = ExpandPm(idSrc, idDst, n);
	return __nErr;
}

INT16 CPMproc::OnF02pm()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 srate = (INT32)MIC_GET_N(1,0);
	INT32 n = (INT32)MIC_GET_N(2,1);
	data* idDst = MIC_GET_I_EX(idDst,data,3,1);
	data* idSrc = MIC_GET_I_EX(idSrc,data,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = F02pm(idSrc, idDst, n, srate);
	return __nErr;
}

INT16 CPMproc::OnFill()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	const char* method = MIC_GET_S(1,0);
	INT32 n = (INT32)MIC_GET_N(2,0);
	data* idDst = MIC_GET_I_EX(idDst,data,3,1);
	data* idSrc = MIC_GET_I_EX(idSrc,data,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Fill(idSrc, idDst, n, method);
	return __nErr;
}

INT16 CPMproc::OnPm2f0()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 srate = (INT32)MIC_GET_N(1,0);
	INT32 n = (INT32)MIC_GET_N(2,1);
	data* idDst = MIC_GET_I_EX(idDst,data,3,1);
	data* idSrc = MIC_GET_I_EX(idSrc,data,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Pm2f0(idSrc, idDst, n, srate);
	return __nErr;
}

//}}CGEN_PMIC
#endif /* #ifndef __NOITP */


// Generated secondary method invocation functions

//{{CGEN_SMIC
//}}CGEN_SMIC


// Generated option change callback functions

//{{CGEN_OCCF
//}}CGEN_OCCF


// Generated field change callback functions

//{{CGEN_FCCF
INT16 CPMproc::OnMaxChanged()
{
           ChfaFreeTables();
           ChfaAllocTables();

	return O_K;
}

INT16 CPMproc::OnMinChanged()
{
           ChfaFreeTables();
           ChfaAllocTables();

	return O_K;
}

//}}CGEN_FCCF


// EOF
