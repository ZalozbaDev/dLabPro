// dLabPro class CVADproc (VADproc)
// - VAD implementation
//
// AUTHOR : Frank Duckhorn
// PACKAGE: dLabPro/classes
//
// This file was generated by dcg. DO NOT MODIFY! Modify vadproc.def instead.
// 
// Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
// - Chair of System Theory and Speech Technology, TU Dresden
// - Chair of Communications Engineering, BTU Cottbus
// 
// This file is part of dLabPro.
// 
// dLabPro is free software: you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
// 
// dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
// details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with dLabPro. If not, see <http://www.gnu.org/licenses/>.


//{{CGEN_INCLUDE
//}}CGEN_END
#include "dlp_vadproc.h"

// Class CVADproc

CVADproc::CVADproc(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	DEBUGMSG(-1,"CVADproc::CVADproc; (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	dlp_strcpy(m_lpClassName,"VADproc");
	dlp_strcpy(m_lpObsoleteName,"");
	dlp_strcpy(m_lpProjectName,"VADproc");
	dlp_strcpy(m_version.no,"1.0.0");
	dlp_strcpy(m_version.date,"");
	m_nClStyle = CS_AUTOACTIVATE;

	if (bCallVirtual)
	{
		DLPASSERT(OK(AutoRegisterWords()));
		Init(TRUE);
	}
}

CVADproc::~CVADproc()
{
  //{{CGEN_DONECODE
  if(m_lpVadState) dlp_free(m_lpVadState);
  DONE;
  //}}CGEN_DONECODE
}

INT16 CVADproc::AutoRegisterWords()
{
	DEBUGMSG(-1,"CVADproc::AutoRegisterWords",0,0,0);
	IF_NOK(inherited::AutoRegisterWords()) return NOT_EXEC;

	//{{CGEN_REGISTERWORDS
	REGISTER_METHOD("-get_delay","",LPMF(CVADproc,OnGetDelay),"Get the VAD delay",0,"<VADproc this>","")
	REGISTER_METHOD("-vad","",LPMF(CVADproc,OnVad),"Add voice activity information to frame sequence",0,"<data idFrames> <VADproc this>","")
	REGISTER_METHOD("-vad_one","",LPMF(CVADproc,OnVadOne),"Return voice activity information for one frame",0,"<data idFrame> <long nR> <VADproc this>","")
	REGISTER_METHOD("-vad_primary","",LPMF(CVADproc,OnVadPrimary),"Do only primary vad decission (without state machine) for frame number nR in idFrames",0,"<data idFrames> <long nR> <VADproc this>","")
	REGISTER_FIELD("gmm","",LPMV(m_iGmm),NULL,"Gaussian mixture models for vad_type = gmm",0,6002,1,"gmm",NULL)
	REGISTER_FIELD("gmm_lab","",LPMV(m_idGmmLab),NULL,"Gaussian mixture model label (for vad_type = gmm)",0,6002,1,"data",NULL)
	REGISTER_FIELD("max_sp","",LPMV(m_nMaxSp),LPMF(CVADproc,OnMaxSpChanged),"Maximal speech length",0,2002,1,"short",(INT16)500)
	REGISTER_FIELD("min_si","",LPMV(m_nMinSi),LPMF(CVADproc,OnMinSiChanged),"Minimal silence length",0,2002,1,"short",(INT16)10)
	REGISTER_FIELD("min_sp","",LPMV(m_nMinSp),LPMF(CVADproc,OnMinSpChanged),"Minimal speech length",0,2002,1,"short",(INT16)4)
	REGISTER_FIELD("post_sp","",LPMV(m_nPostSp),LPMF(CVADproc,OnPostSpChanged),"Number of frames after speech to mark as speech (must be less or equal nMinSi)",0,2002,1,"short",(INT16)4)
	REGISTER_FIELD("pow_thr","",LPMV(m_nPowThr),NULL,"Threshold for energy with vad_type = pow",0,3008,1,"double",(FLOAT64)1000000.)
	REGISTER_FIELD("pre_sp","",LPMV(m_nPreSp),LPMF(CVADproc,OnPreSpChanged),"Maximal number of frames before speech to mark as speech",0,2002,1,"short",(INT16)3)
	REGISTER_FIELD("vad_type","",LPMV(m_lpsVadType),NULL,"Type of the primary Vad",0,255,255,"char[255]","pow")
	REGISTER_FIELD("VadState","",LPMV(m_lpVadState),NULL,"State of the Vad",FF_HIDDEN | FF_NOSET | FF_NOSAVE,6000,1,"void*",NULL)
	REGISTER_ERROR("~e8_1_0__1",EL_ERROR,VAD_UNKOWNMETH,"Vad method is unkown: vad_prim = %s.")
	//}}CGEN_REGISTERWORDS

	return O_K;
}

INT16 CVADproc::Init(BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CVADproc::Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	//{{CGEN_INITCODE

  // Call constructor of class CFBAproc
  INIT;

  // Extra initialization
  if(InitVAD() != O_K) return NOT_EXEC;
	//}}CGEN_INITCODE

	// If last derivation call reset (do not reset members; already done by Init())
	if (bCallVirtual) return Reset(FALSE);
	else              return O_K;
}

INT16 CVADproc::Reset(BOOL bResetMembers)
{
	DEBUGMSG(-1,"CVADproc::Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	//{{CGEN_RESETCODE
  return RESET;
	//}}CGEN_RESETCODE

	return O_K;
}

INT16 CVADproc::ClassProc()
{
	//{{CGEN_CLASSCODE
  return CLASSPROC;
	//}}CGEN_CLASSCODE

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CVADproc::Serialize(CDN3Stream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CVADproc::SerializeXml(CXmlStream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CVADproc::Deserialize(CDN3Stream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CVADproc::DeserializeXml(CXmlStream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CVADproc::Copy(CDlpObject* __iSrc)
{
	//{{CGEN_COPYCODE
  return COPY;
	//}}CGEN_COPYCODE

	return O_K;
}

// Runtime class type information and class factory
INT16 CVADproc::InstallProc(void* lpItp)
{
	//{{CGEN_INSTALLCODE
  return INSTALL;
	//}}CGEN_INSTALLCODE

	return O_K;
}

CVADproc* CVADproc::CreateInstance(const char* lpName)
{
	CVADproc* lpNewInstance;
	ICREATEEX(CVADproc,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CVADproc::GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOACTIVATE;
	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CVADproc::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CVADproc::InstallProc;
	lpClassWord->ex.fct.lpProject   = "VADproc";
	lpClassWord->ex.fct.lpBaseClass = "FBAproc";
	lpClassWord->lpComment          = "VAD implementation";
	lpClassWord->ex.fct.lpAutoname  = "";
	lpClassWord->ex.fct.lpCname     = "CVADproc";
	lpClassWord->ex.fct.lpAuthor    = "Frank Duckhorn";

	dlp_strcpy(lpClassWord->lpName             ,"VADproc");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"1.0.0");

	return O_K;
}

INT16 CVADproc::GetInstanceInfo(SWord* lpClassWord)
{
	return CVADproc::GetClassInfo(lpClassWord);
}

BOOL CVADproc::IsKindOf(const char* lpClassName)
{
  if (dlp_strncmp(lpClassName,"VADproc",L_NAMES) == 0) return TRUE;
  else return inherited::IsKindOf(lpClassName);
}

INT16 CVADproc::ResetAllOptions(BOOL bInit)
{
	DEBUGMSG(-1,"CVADproc::ResetAllOptions;",0,0,0);
	//{{CGEN_RESETALLOPTIONS
	//}}CGEN_RESETALLOPTIONS

	return inherited::ResetAllOptions(bInit);
}

// Generated primary method invocation functions

#ifndef __NOITP
//{{CGEN_PMIC
INT16 CVADproc::OnGetDelay()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_N(GetDelay());
	return __nErr;
}

INT16 CVADproc::OnVad()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idFrames = MIC_GET_I_EX(idFrames,data,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Vad(idFrames);
	return __nErr;
}

INT16 CVADproc::OnVadOne()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT64 nR = (INT64)MIC_GET_N(1,0);
	data* idFrame = MIC_GET_I_EX(idFrame,data,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_B(VadOne(idFrame, nR));
	return __nErr;
}

INT16 CVADproc::OnVadPrimary()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT64 nR = (INT64)MIC_GET_N(1,0);
	data* idFrames = MIC_GET_I_EX(idFrames,data,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_B(VadPrimary(idFrames, nR));
	return __nErr;
}

//}}CGEN_PMIC
#endif /* #ifndef __NOITP */


// Generated secondary method invocation functions

//{{CGEN_SMIC
//}}CGEN_SMIC


// Generated option change callback functions

//{{CGEN_OCCF
//}}CGEN_OCCF


// Generated field change callback functions

//{{CGEN_FCCF
INT16 CVADproc::OnMaxSpChanged()
{
    return InitVAD();

	return O_K;
}

INT16 CVADproc::OnMinSiChanged()
{
    return InitVAD();

	return O_K;
}

INT16 CVADproc::OnMinSpChanged()
{
    return InitVAD();

	return O_K;
}

INT16 CVADproc::OnPostSpChanged()
{
    return InitVAD();

	return O_K;
}

INT16 CVADproc::OnPreSpChanged()
{
    return InitVAD();

	return O_K;
}

//}}CGEN_FCCF


// EOF
