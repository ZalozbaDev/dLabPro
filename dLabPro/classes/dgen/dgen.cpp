// dLabPro class CDgen (DGen)
// - Document parser and generator
//
// AUTHOR : Matthias Wolff
// PACKAGE: dLabPro/classes
//
// This file was generated by dcg. DO NOT MODIFY! Modify dgen.def instead.
// 
// Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
// - Chair of System Theory and Speech Technology, TU Dresden
// - Chair of Communications Engineering, BTU Cottbus
// 
// This file is part of dLabPro.
// 
// dLabPro is free software: you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
// 
// dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
// details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with dLabPro. If not, see <http://www.gnu.org/licenses/>.


//{{CGEN_INCLUDE
//}}CGEN_END
#include "dlp_dgen.h"

// Class CDgen

CDgen::CDgen(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	DEBUGMSG(-1,"CDgen::CDgen; (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	dlp_strcpy(m_lpClassName,"DGen");
	dlp_strcpy(m_lpObsoleteName,"");
	dlp_strcpy(m_lpProjectName,"dgen");
	dlp_strcpy(m_version.no,"1.0.1");
	dlp_strcpy(m_version.date,"");
	m_nClStyle = CS_AUTOACTIVATE;

	if (bCallVirtual)
	{
		DLPASSERT(OK(AutoRegisterWords()));
		Init(TRUE);
	}
}

CDgen::~CDgen()
{
  //{{CGEN_DONECODE
  DONE;
  //}}CGEN_DONECODE
}

INT16 CDgen::AutoRegisterWords()
{
	DEBUGMSG(-1,"CDgen::AutoRegisterWords",0,0,0);
	IF_NOK(inherited::AutoRegisterWords()) return NOT_EXEC;

	//{{CGEN_REGISTERWORDS

	// Register methods
	REGISTER_METHOD("-edit_section","",LPMF(CDgen,OnEditSection),"Edits text between two markers in generated document.",0,"<string sMarkOn> <string sMarkOff> <data idText> <string sOpname> <DGen this>","")
	REGISTER_METHOD("-load","",LPMF(CDgen,OnLoad),"Load document template.",0,"<string sFilename> <DGen this>","")
	REGISTER_METHOD("-parse","",LPMF(CDgen,OnParse),"Parse token sequence (field tsq)",0,"<string sParser> <fst itDeps> <int nFtok> <int nLtok> <DGen this>","")
	REGISTER_METHOD("-scan","",LPMF(CDgen,OnScan),"For convenience: -tokenize plus -parse",0,"<string sFilename> <string sParser> <fst itDeps> <DGen this>","")
	REGISTER_METHOD("-setup","",LPMF(CDgen,OnSetup),"Load default parameter set for given parser",0,"<string sParser> <DGen this>","")
	REGISTER_METHOD("-table","",LPMF(CDgen,OnTable),"Adds table data to HTML page",0,"<data idTable> <string sPre> <string sDel> <string sSuf> <DGen this>","")
	REGISTER_METHOD("-tokenize","",LPMF(CDgen,OnTokenize),"Tokenize source file",0,"<string sFilename> <DGen this>","")
	REGISTER_METHOD("-write","",LPMF(CDgen,OnWrite),"Write HTML page to file",0,"<string sFilename> <DGen this>","")
	REGISTER_METHOD("<%","",LPMF(CDgen,HereScript),"Add HTML code (here script) to HTML page",0,"<DGen this>","... %>")
	REGISTER_METHOD(">>","",LPMF(CDgen,OnAddText),"Add text to HTML page",0,"<string sText> <DGen this>","")

	// Register options
	REGISTER_OPTION("/bare","",LPMV(m_bBare),NULL,"Ignore prefixes and suffixes.",0)

	// Register fields
	REGISTER_FIELD("bcmtoff","",LPMV(m_lpsBcmtoff),NULL,"Block comment mark (end)",0,8,8,"char[8]","")
	REGISTER_FIELD("bcmton","",LPMV(m_lpsBcmton),NULL,"Block comment mark (start)",0,8,8,"char[8]","")
	REGISTER_FIELD("chrs","",LPMV(m_bChrs),NULL,"Get character strings in single quotation marks as tokens.",0,2002,1,"short",(INT16)TRUE)
	REGISTER_FIELD("dcmt","",LPMV(m_lpsDcmt),NULL,"Documentation comment",0,8,8,"char[8]","##")
	REGISTER_FIELD("dom","",LPMV(m_idDom),NULL,"Document object model",FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("drct","",LPMV(m_lpsDrct),NULL,"Compiler directive (entire line will be one token)",0,8,8,"char[8]","")
	REGISTER_FIELD("filename","",LPMV(m_lpsFilename),NULL,"Most recently tokenized file",FF_NOSET,255,255,"char[255]","")
	REGISTER_FIELD("gen","",LPMV(m_idGen),NULL,"Generated document",FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("grany","",LPMV(m_nGrany),NULL,"Memory allocation granularity",FF_NOSET,2004,1,"int",(INT32)100)
	REGISTER_FIELD("idel","",LPMV(m_lpsIdel),LPMF(CDgen,OnIdelChanged),"Insignificant token delimiter characters",0,64,64,"char[64]"," \t")
	REGISTER_FIELD("lcmt","",LPMV(m_lpsLcmt),NULL,"One line comment mark ('til end of line)",0,8,8,"char[8]","#")
	REGISTER_FIELD("sdel","",LPMV(m_lpsSdel),LPMF(CDgen,OnSdelChanged),"Significant token delimiter characters",0,64,64,"char[64]","")
	REGISTER_FIELD("spl","",LPMV(m_idSpl),NULL,"Source property list (key-value pairs)",FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("strs","",LPMV(m_bStrs),NULL,"Get character strings in double quotation marks as tokens.",0,2002,1,"short",(INT16)TRUE)
	REGISTER_FIELD("tsq","",LPMV(m_idTsq),NULL,"Token sequence",FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("txt","",LPMV(m_idTxt),NULL,"Documentation texts",FF_NOSET,6002,1,"data",NULL)

	// Register errors
	REGISTER_ERROR("~e1_0_0__1",EL_ERROR,DG_TOOFEWCOMPS,"Node table of instance '%s' has too few components.")
	REGISTER_ERROR("~e2_0_0__1",EL_ERROR,DG_NOTSYMBCOMPTYPE,"Node component %ld of instance '%s' must be symbolic.")
	REGISTER_ERROR("~e3_0_0__1",EL_WARNING,DG_TOOLONG,"%s(%ld): %s too long.")
	REGISTER_ERROR("~e4_0_0__1",EL_WARNING,DG_TOOLONG2,"%s '%s' too long (max. %ld characters).")
	REGISTER_ERROR("~e5_0_0__1",EL_ERROR,DG_HERESCRIPT,"Unexpected end of file scanning for '%s'.")
	REGISTER_ERROR("~e6_0_0__1",EL_ERROR,DG_STREXCEEDSLINE,"String constant exceeds line.")
	REGISTER_ERROR("~e7_0_0__1",EL_ERROR,DG_PARSER,"Parser '%s' unknown.")
	REGISTER_ERROR("~e8_0_0__1",EL_ERROR,DG_OPCODE,"'%s' is not a valid %s operation.")
	REGISTER_ERROR("~e9_0_0__1",EL_ERROR,DG_SYNTAX,"Syntax error.")
	REGISTER_ERROR("~e0_1_0__1",EL_ERROR,DG_SYNTAX2,"Syntax error (%s).")
	REGISTER_ERROR("~e1_1_0__1",EL_ERROR,DG_EXPECT,"Expect %s.")
	REGISTER_ERROR("~e2_1_0__1",EL_ERROR,DG_AWOB,"%s without matching %s.")
	REGISTER_ERROR("~e3_1_0__1",EL_ERROR,DG_JVD,"JavaDoc %s %s %s.")
	//}}CGEN_REGISTERWORDS

	return O_K;
}

INT16 CDgen::Init(BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CDgen::Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	//{{CGEN_INITCODE
  INIT;
	//}}CGEN_INITCODE

	// If last derivation call reset (do not reset members; already done by Init())
	if (bCallVirtual) return Reset(FALSE);
	else              return O_K;
}

INT16 CDgen::Reset(BOOL bResetMembers)
{
	DEBUGMSG(-1,"CDgen::Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	//{{CGEN_RESETCODE
  RESET;
  IFIELD_RESET(CData,"tsq");
  IFIELD_RESET(CData,"spl");
  IFIELD_RESET(CData,"dom");
  IFIELD_RESET(CData,"txt");
  IFIELD_RESET(CData,"gen");
  m_idSpl->AddComp("key" , 33);
  m_idSpl->AddComp("val" ,255);
  m_idTxt->AddComp("line",255);
  m_idGen->AddComp("line",255);
	//}}CGEN_RESETCODE

	return O_K;
}

INT16 CDgen::ClassProc()
{
	//{{CGEN_CLASSCODE
  return CLASSPROC;
	//}}CGEN_CLASSCODE

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CDgen::Serialize(CDN3Stream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CDgen::SerializeXml(CXmlStream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CDgen::Deserialize(CDN3Stream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CDgen::DeserializeXml(CXmlStream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CDgen::Copy(CDlpObject* __iSrc)
{
	//{{CGEN_COPYCODE
  return COPY;
	//}}CGEN_COPYCODE

	return O_K;
}

// Runtime class type information and class factory
INT16 CDgen::InstallProc(void* lpItp)
{
	//{{CGEN_INSTALLCODE
  return INSTALL;
	//}}CGEN_INSTALLCODE

	return O_K;
}

CDgen* CDgen::CreateInstance(const char* lpName)
{
	CDgen* lpNewInstance;
	ICREATEEX(CDgen,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CDgen::GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOACTIVATE;
	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CDgen::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CDgen::InstallProc;
	lpClassWord->ex.fct.lpProject   = "dgen";
	lpClassWord->ex.fct.lpBaseClass = "-";
	lpClassWord->lpComment          = "Document parser and generator";
	lpClassWord->ex.fct.lpAutoname  = "";
	lpClassWord->ex.fct.lpCname     = "CDgen";
	lpClassWord->ex.fct.lpAuthor    = "Matthias Wolff";

	dlp_strcpy(lpClassWord->lpName             ,"DGen");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"1.0.1");

	return O_K;
}

INT16 CDgen::GetInstanceInfo(SWord* lpClassWord)
{
	return CDgen::GetClassInfo(lpClassWord);
}

BOOL CDgen::IsKindOf(const char* lpClassName)
{
  if (dlp_strncmp(lpClassName,"DGen",L_NAMES) == 0) return TRUE;
  else return inherited::IsKindOf(lpClassName);
}

INT16 CDgen::ResetAllOptions(BOOL bInit)
{
	DEBUGMSG(-1,"CDgen::ResetAllOptions;",0,0,0);
	//{{CGEN_RESETALLOPTIONS
	_this->m_bBare = FALSE;
	//}}CGEN_RESETALLOPTIONS

	return inherited::ResetAllOptions(bInit);
}

// Generated primary method invocation functions

#ifndef __NOITP
//{{CGEN_PMIC
INT16 CDgen::OnEditSection()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	char* sOpname = MIC_GET_S(1,0);
	data* idText = MIC_GET_I_EX(idText,data,2,1);
	char* sMarkOff = MIC_GET_S(3,1);
	char* sMarkOn = MIC_GET_S(4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = EditSection(sMarkOn, sMarkOff, idText, sOpname);
	return __nErr;
}

INT16 CDgen::OnLoad()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	char* sFilename = MIC_GET_S(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Load(sFilename);
	return __nErr;
}

INT16 CDgen::OnParse()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nLtok = (INT32)MIC_GET_N(1,0);
	INT32 nFtok = (INT32)MIC_GET_N(2,1);
	fst* itDeps = MIC_GET_I_EX(itDeps,fst,3,1);
	char* sParser = MIC_GET_S(4,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Parse(sParser, itDeps, nFtok, nLtok);
	return __nErr;
}

INT16 CDgen::OnScan()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	fst* itDeps = MIC_GET_I_EX(itDeps,fst,1,1);
	char* sParser = MIC_GET_S(2,0);
	char* sFilename = MIC_GET_S(3,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Scan(sFilename, sParser, itDeps);
	return __nErr;
}

INT16 CDgen::OnSetup()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	char* sParser = MIC_GET_S(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Setup(sParser);
	return __nErr;
}

INT16 CDgen::OnTable()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	char* sSuf = MIC_GET_S(1,0);
	char* sDel = MIC_GET_S(2,1);
	char* sPre = MIC_GET_S(3,2);
	data* idTable = MIC_GET_I_EX(idTable,data,4,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Table(idTable, sPre, sDel, sSuf);
	return __nErr;
}

INT16 CDgen::OnTokenize()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	char* sFilename = MIC_GET_S(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Tokenize(sFilename);
	return __nErr;
}

INT16 CDgen::OnWrite()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	char* sFilename = MIC_GET_S(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Write(sFilename);
	return __nErr;
}

INT16 CDgen::OnAddText()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	char* sText = MIC_GET_S(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = AddText(sText);
	return __nErr;
}

//}}CGEN_PMIC
#endif /* #ifndef __NOITP */


// Generated secondary method invocation functions

//{{CGEN_SMIC
//}}CGEN_SMIC


// Generated option change callback functions

//{{CGEN_OCCF
//}}CGEN_OCCF


// Generated field change callback functions

//{{CGEN_FCCF
INT16 CDgen::OnIdelChanged()
{
    dlp_strconvert(SC_UNESCAPE,m_lpsIdel,m_lpsIdel);

	return O_K;
}

INT16 CDgen::OnSdelChanged()
{
    dlp_strconvert(SC_UNESCAPE,m_lpsSdel,m_lpsSdel);

	return O_K;
}

//}}CGEN_FCCF


// EOF
