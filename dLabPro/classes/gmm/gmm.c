/* dLabPro class CGmm (gmm)
 * - Multivariate multiclass Gaussian mixture models
 *
 * AUTHOR : Matthias Wolff, Rainer Schaffer
 * PACKAGE: dLabPro/classes
 *
 * This file was generated by dcg. DO NOT MODIFY! Modify gmm.def instead.
 * 
 * Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
 * - Chair of System Theory and Speech Technology, TU Dresden
 * - Chair of Communications Engineering, BTU Cottbus
 * 
 * This file is part of dLabPro.
 * 
 * dLabPro is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 * 
 * dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with dLabPro. If not, see <http://www.gnu.org/licenses/>.
 */

#include "dlp_cscope.h" /* Indicate C scope */
/*{{CGEN_INCLUDE */
/*}}CGEN_END */
#include "dlp_gmm.h"

/* Class CGmm */

void CGmm_Constructor(CGmm* _this, const char* lpInstanceName, BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CGmm_Constructor; (bCallVirtual=%d)",(int)bCallVirtual,0,0);

#ifndef __cplusplus

	/* Register instance */
	dlp_xalloc_register_object('J',_this,1,sizeof(CGmm),
		__FILE__,__LINE__,"gmm",lpInstanceName);

	/* Create base instance */
	_this->m_lpBaseInstance = calloc(1,sizeof(CDlpObject));
	CDlpObject_Constructor(_this->m_lpBaseInstance,lpInstanceName,FALSE);

	/* Override virtual member functions */
	_this->m_lpBaseInstance->AutoRegisterWords = CGmm_AutoRegisterWords;
	_this->m_lpBaseInstance->Reset             = CGmm_Reset;
	_this->m_lpBaseInstance->Init              = CGmm_Init;
	_this->m_lpBaseInstance->Serialize         = CGmm_Serialize;
	_this->m_lpBaseInstance->SerializeXml      = CGmm_SerializeXml;
	_this->m_lpBaseInstance->Deserialize       = CGmm_Deserialize;
	_this->m_lpBaseInstance->DeserializeXml    = CGmm_DeserializeXml;
	_this->m_lpBaseInstance->Copy              = CGmm_Copy;
	_this->m_lpBaseInstance->ClassProc         = CGmm_ClassProc;
	_this->m_lpBaseInstance->GetInstanceInfo   = CGmm_GetInstanceInfo;
	_this->m_lpBaseInstance->IsKindOf          = CGmm_IsKindOf;
	_this->m_lpBaseInstance->Destructor        = CGmm_Destructor;
	_this->m_lpBaseInstance->ResetAllOptions   = CGmm_ResetAllOptions;

	/* Override pointer to derived instance */
	_this->m_lpBaseInstance->m_lpDerivedInstance = _this;

	#endif /* #ifndef __cplusplus */

	dlp_strcpy(BASEINST(_this)->m_lpClassName,"gmm");
	dlp_strcpy(BASEINST(_this)->m_lpObsoleteName,"");
	dlp_strcpy(BASEINST(_this)->m_lpProjectName,"gmm");
	dlp_strcpy(BASEINST(_this)->m_version.no,"1.0.0");
	dlp_strcpy(BASEINST(_this)->m_version.date,"");
	BASEINST(_this)->m_nClStyle = CS_AUTOACTIVATE;

	if (bCallVirtual)
	{
		DLPASSERT(OK(INVOKE_VIRTUAL_0(AutoRegisterWords)));
		INVOKE_VIRTUAL_1(Init,TRUE);
	}
}

void CGmm_Destructor(CDlpObject* __this)
{
	GET_THIS_VIRTUAL(CGmm);
	{
	/*{{CGEN_DONECODE */
  DONE;
  CGmm_Precalc(_this,TRUE);
	/*}}CGEN_DONECODE */
	}

#ifndef __cplusplus

	/* Destroy base instance */
	CDlpObject_Destructor(_this->m_lpBaseInstance);
	dlp_free(_this->m_lpBaseInstance);
	_this->m_lpBaseInstance = NULL;

#endif /* #ifndef __cplusplus */
}

INT16 CGmm_AutoRegisterWords(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	DEBUGMSG(-1,"CGmm_AutoRegisterWords",0,0,0);

	/* Call base class implementation */
	IF_NOK(INVOKE_BASEINST_0(AutoRegisterWords)) return NOT_EXEC;

	/*{{CGEN_REGISTERWORDS */

	/* Register methods */
	REGISTER_METHOD("-density","",LPMF(CGmm,OnDensity),"Computes (log.) probability densities for a set of feature vectors.",0,"<data idX> <data idXmap> <data idDens> <gmm this>","")
	REGISTER_METHOD("-distance","",LPMF(CGmm,OnDistance),"Computes Mahalanobis distances for a set of feature vectors.",0,"<data idX> <data idXmap> <data idDist> <gmm this>","")
	REGISTER_METHOD("-extract","",LPMF(CGmm,OnExtract),"Extract mean vectors and inverse covariance matrices.",0,"<data idMean> <data idIcov> <gmm this>","")
	REGISTER_METHOD("-get_n_valid_gauss","",LPMF(CGmm,OnGetNValidGauss),"Determines the number of valid single Gaussians.",0,"<gmm this>","")
	REGISTER_METHOD("-noise","",LPMF(CGmm,OnNoise),"Create normally distributed noise",0,"<long nDim> <long nRecs> <data idDest> <gmm this>","")
	REGISTER_METHOD("-setup","",LPMF(CGmm,OnSetup),"Setup Gaussian mixture model",0,"<data idMean> <data idCov> <vmap iMmap> <gmm this>","")
	REGISTER_METHOD("-setup_ex","",LPMF(CGmm,OnSetupEx),"Setup Gaussian mixture model.",0,"<data idMean> <data idCov> <vmap iMmap> <data idCmap> <data idVar> <gmm this>","")
	REGISTER_METHOD("-split","",LPMF(CGmm,OnSplit),"Splits single Gaussians into two.",0,"<double nParam> <data idMap> <gmm this>","")
	REGISTER_METHOD("-status","",LPMF(CGmm,OnStatus),"Prints status information of the Gaussian mixture model.",0,"<gmm this>","")

	/* Register options */
	REGISTER_OPTION("/double","",LPMV(m_bDouble),NULL,"Use double precision floating point numbers.",0)
	REGISTER_OPTION("/float","",LPMV(m_bFloat),NULL,"Use single precision floating point numbers.",0)
	REGISTER_OPTION("/icov","",LPMV(m_bIcov),NULL,"Inverse covariance matrices",0)
	REGISTER_OPTION("/ldl","",LPMV(m_bLdl),NULL,"Use precalced values from LDL-Factorization for density calculation",0)
	REGISTER_OPTION("/log","",LPMV(m_bLog),NULL,"Compute logarihmic values.",0)
	REGISTER_OPTION("/neglog","",LPMV(m_bNeglog),NULL,"Compute negative logarihmic values.",0)
	REGISTER_OPTION("/nomix","",LPMV(m_bNomix),NULL,"Do not use mixture map",0)
	REGISTER_OPTION("/rand_gauss_bm","",LPMV(m_bRandGaussBm),NULL,"Use Box-Muller-Method for generating gaussian distributed noise.",0)
	REGISTER_OPTION("/rand_gauss_polar","",LPMV(m_bRandGaussPolar),NULL,"Use polar method for generating gaussian distributed noise.",0)
	REGISTER_OPTION("/sse2","",LPMV(m_bSse2),LPMF(CGmm,OnSse2Set),"Use SSE2 optimized algorithm.",0)

	/* Register fields */
	REGISTER_FIELD("alpha","",LPMV(m_lpAlpha),NULL,"",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6000,1,"void*",NULL)
	REGISTER_FIELD("beta","",LPMV(m_lpBeta),NULL,"",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6000,1,"void*",NULL)
	REGISTER_FIELD("cdet","",LPMV(m_idCdet),NULL,"Determinants of covariance matrices.",FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("cmap","",LPMV(m_idCmap),NULL,"(Co-)variance tying map.",FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("dceil","",LPMV(m_nDceil),NULL,"Distance limit.",0,3008,1,"double",(FLOAT64)1000)
	REGISTER_FIELD("delta","",LPMV(m_lpDelta),NULL,"",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6000,1,"void*",NULL)
	REGISTER_FIELD("gamma","",LPMV(m_lpGamma),NULL,"",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6000,1,"void*",NULL)
	REGISTER_FIELD("I","",LPMV(m_lpI),NULL,"",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6000,1,"void*",NULL)
	REGISTER_FIELD("icov","",LPMV(m_idIcov),NULL,"Inverse covariance matrices w/o main diagonal.",FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("ivar","",LPMV(m_idIvar),NULL,"Inverse variance vectors.",FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("K","",LPMV(m_nK),NULL,"",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,2008,1,"long",(INT64)0)
	REGISTER_FIELD("LDL","",LPMV(m_nLDL),NULL,"",FF_HIDDEN | FF_NOSET,2008,1,"long",(INT64)FALSE)
	REGISTER_FIELD("ldl_coef","",LPMV(m_nLdlCoef),NULL,"Number of unzero Values in the L matrix if LDL factorization is used.",0,2008,1,"long",(INT64)-1)
	REGISTER_FIELD("ldl_d","",LPMV(m_lpLdlD),NULL,"",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6000,1,"void*",NULL)
	REGISTER_FIELD("ldl_l","",LPMV(m_lpLdlL),NULL,"",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6000,1,"void*",NULL)
	REGISTER_FIELD("mean","",LPMV(m_idMean),NULL,"Mean vectors of Gaussians.",FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("mindet","",LPMV(m_nMindet),NULL,"Minimal acceptable determinant of covariance matrices.",0,3008,1,"double",(FLOAT64)1E-34)
	REGISTER_FIELD("mmap","",LPMV(m_iMmap),NULL,"Mixture map.",FF_NOSET,6002,1,"vmap",NULL)
	REGISTER_FIELD("N","",LPMV(m_nN),NULL,"",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,2008,1,"long",(INT64)0)
	REGISTER_FIELD("sse2_buf","",LPMV(m_lpSse2Buf),NULL,"",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6000,1,"void*",NULL)
	REGISTER_FIELD("sse2_icov","",LPMV(m_idSse2Icov),NULL,"",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6002,1,"data",NULL)
	REGISTER_FIELD("type","",LPMV(m_nType),NULL,"Floating point type code for calculations.",FF_NOSET,2002,1,"short",(INT16)T_DOUBLE)
	REGISTER_FIELD("V","",LPMV(m_lpV),NULL,"",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6000,1,"void*",NULL)

	/* Register errors */
	REGISTER_ERROR("~e1_0_0__1",EL_ERROR,GMM_NOTSETUP,"Model not properly set up%s.")
	REGISTER_ERROR("~e2_0_0__1",EL_ERROR,GMM_DIM,"Wrong %s dimensionality (should be %ld).")
	REGISTER_ERROR("~e3_0_0__1",EL_WARNING,GMM_RANK,"Cov. matrix %ld bad (det=%8.2g).")
	REGISTER_ERROR("~e4_0_0__1",EL_WARNING,GMM_IGNORE,"Extra %s ignored.")
	REGISTER_ERROR("~e5_0_0__1",EL_ERROR,GMM_INVALD,"Invalid distance or density computed from Gaussian (mixture) %ld.")
	/*}}CGEN_REGISTERWORDS */

	return O_K;
}

INT16 CGmm_Init(CDlpObject* __this, BOOL bCallVirtual)
{
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	DEBUGMSG(-1,"CGmm_Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	{
	/*{{CGEN_INITCODE */
  INIT;
	/*}}CGEN_INITCODE */
	}

	/* If last derivation call reset (do not reset members; already done by Init()) */
#ifndef __NORTTI
	if (bCallVirtual) return INVOKE_VIRTUAL_1(Reset,FALSE); else
#endif
	                  return O_K;
}

INT16 CGmm_Reset(CDlpObject* __this, BOOL bResetMembers)
{
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	DEBUGMSG(-1,"CGmm_Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	{
	/*{{CGEN_RESETCODE */
  RESET;
  CGmm_Precalc(_this,TRUE);
	/*}}CGEN_RESETCODE */
	}

	return O_K;
}

INT16 CGmm_ClassProc(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	{
	/*{{CGEN_CLASSCODE */
  return CLASSPROC;
	/*}}CGEN_CLASSCODE */
	}

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CGmm_Serialize(CDlpObject* __this, CDN3Stream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
  return SAVE;
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CGmm_SerializeXml(CDlpObject* __this, CXmlStream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
  return SAVE;
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CGmm_Deserialize(CDlpObject* __this, CDN3Stream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
  RESTORE;
  CGmm_Precalc(_this,FALSE);
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CGmm_DeserializeXml(CDlpObject* __this, CXmlStream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
  RESTORE;
  CGmm_Precalc(_this,FALSE);
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CGmm_Copy(CDlpObject* __this, CDlpObject* __iSrc)
{
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	{
	/*{{CGEN_COPYCODE */
  COPY;
  CGmm_Precalc(_this,FALSE);
	/*}}CGEN_COPYCODE */
	}

	return O_K;
}

/* Runtime class type information and class factory */
INT16 CGmm_InstallProc(void* lpItp)
{
	{
	/*{{CGEN_INSTALLCODE */
  return INSTALL;
	/*}}CGEN_INSTALLCODE */
	}

	return O_K;
}

CGmm* CGmm_CreateInstance(const char* lpName)
{
	CGmm* lpNewInstance;
	ICREATEEX(CGmm,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CGmm_GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOACTIVATE;

#ifdef __cplusplus

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CGmm::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CGmm::InstallProc;

#else /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CGmm_CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CGmm_InstallProc;

#endif /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpProject   = "gmm";
	lpClassWord->ex.fct.lpBaseClass = "-";
	lpClassWord->lpComment          = "Multivariate multiclass Gaussian mixture models";
	lpClassWord->ex.fct.lpAutoname  = "";
	lpClassWord->ex.fct.lpCname     = "CGmm";
	lpClassWord->ex.fct.lpAuthor    = "Matthias Wolff, Rainer Schaffer";

	dlp_strcpy(lpClassWord->lpName             ,"gmm");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"1.0.0");

	return O_K;
}

INT16 CGmm_GetInstanceInfo(CDlpObject* __this, SWord* lpClassWord)
{
	return CGmm_GetClassInfo(lpClassWord);
}

BOOL CGmm_IsKindOf(CDlpObject* __this, const char* lpClassName)
{
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);

  if (dlp_strncmp(lpClassName,"gmm",L_NAMES) == 0) return TRUE;
	else return INVOKE_BASEINST_1(IsKindOf,lpClassName);
}

INT16 CGmm_ResetAllOptions(CDlpObject* __this, BOOL bInit)
{
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	DEBUGMSG(-1,"CGmm_ResetAllOptions;",0,0,0);
	{
	/*{{CGEN_RESETALLOPTIONS*/
	_this->m_bDouble = FALSE;
	_this->m_bFloat = FALSE;
	_this->m_bIcov = FALSE;
	_this->m_bLdl = FALSE;
	_this->m_bLog = FALSE;
	_this->m_bNeglog = FALSE;
	_this->m_bNomix = FALSE;
	_this->m_bRandGaussBm = FALSE;
	_this->m_bRandGaussPolar = FALSE;
	_this->m_bSse2 = FALSE;
	/*}}CGEN_RESETALLOPTIONS*/
	}

	return INVOKE_BASEINST_1(ResetAllOptions,bInit);
}

/* Generated primary method invocation functions */

#ifndef __NOITP
/*{{CGEN_CPMIC */
INT16 CGmm_OnDensity(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idX;
	data* idXmap;
	data* idDens;
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idDens = MIC_GET_I_EX(idDens,data,1,1);
	idXmap = MIC_GET_I_EX(idXmap,data,2,2);
	idX = MIC_GET_I_EX(idX,data,3,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CGmm_Density(_this, idX, idXmap, idDens);
	return __nErr;
}

INT16 CGmm_OnDistance(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idX;
	data* idXmap;
	data* idDist;
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idDist = MIC_GET_I_EX(idDist,data,1,1);
	idXmap = MIC_GET_I_EX(idXmap,data,2,2);
	idX = MIC_GET_I_EX(idX,data,3,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CGmm_Distance(_this, idX, idXmap, idDist);
	return __nErr;
}

INT16 CGmm_OnExtract(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idMean;
	data* idIcov;
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idIcov = MIC_GET_I_EX(idIcov,data,1,1);
	idMean = MIC_GET_I_EX(idMean,data,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CGmm_Extract(_this, idMean, idIcov);
	return __nErr;
}

INT16 CGmm_OnGetNValidGauss(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_N(CGmm_GetNValidGauss(_this));
	return __nErr;
}

INT16 CGmm_OnNoise(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT64 nDim;
	INT64 nRecs;
	data* idDest;
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idDest = MIC_GET_I_EX(idDest,data,1,1);
	nRecs = (INT64)MIC_GET_N(2,0);
	nDim = (INT64)MIC_GET_N(3,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CGmm_Noise(_this, nDim, nRecs, idDest);
	return __nErr;
}

INT16 CGmm_OnSetup(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idMean;
	data* idCov;
	vmap* iMmap;
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	iMmap = MIC_GET_I_EX(iMmap,vmap,1,1);
	idCov = MIC_GET_I_EX(idCov,data,2,2);
	idMean = MIC_GET_I_EX(idMean,data,3,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CGmm_Setup(_this, idMean, idCov, iMmap);
	return __nErr;
}

INT16 CGmm_OnSetupEx(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idMean;
	data* idCov;
	vmap* iMmap;
	data* idCmap;
	data* idVar;
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idVar = MIC_GET_I_EX(idVar,data,1,1);
	idCmap = MIC_GET_I_EX(idCmap,data,2,2);
	iMmap = MIC_GET_I_EX(iMmap,vmap,3,3);
	idCov = MIC_GET_I_EX(idCov,data,4,4);
	idMean = MIC_GET_I_EX(idMean,data,5,5);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CGmm_SetupEx(_this, idMean, idCov, iMmap, idCmap, idVar);
	return __nErr;
}

INT16 CGmm_OnSplit(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	FLOAT64 nParam;
	data* idMap;
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idMap = MIC_GET_I_EX(idMap,data,1,1);
	nParam = MIC_GET_N(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CGmm_Split(_this, nParam, idMap);
	return __nErr;
}

INT16 CGmm_OnStatus(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CGmm_Status(_this);
	return __nErr;
}

/*}}CGEN_CPMIC */
#endif /* #ifndef __NOITP */


/* Generated secondary method invocation functions */

/*{{CGEN_CSMIC */
INT16 CGmm_Density(CGmm* _this, data* idX, data* idXmap, data* idDens)
{
    return
      CGmm_Gauss(_this,idX,idXmap,idDens,
        _this->m_bNeglog?GMMG_NLDENS:(_this->m_bLog?GMMG_LDENS:GMMG_DENS));
	return O_K;
}

INT16 CGmm_Distance(CGmm* _this, data* idX, data* idXmap, data* idDist)
{
    return CGmm_Gauss(_this,idX,idXmap,idDist,GMMG_MDIST);
	return O_K;
}

INT16 CGmm_Noise(CGmm* _this, INT64 nDim, INT64 nRecs, data* idDest)
{
    INT32 i = 0;
    INT32 j = 0;
    CData_Array(idDest,T_DOUBLE,nDim,nRecs);
    for (i=0; i<nDim; i++)
      for (j=0; j<nRecs; j++)
        if(_this->m_bRandGaussPolar == TRUE)
          CData_Dstore(idDest,dlm_rand_gauss_polar(),j,i);
        else
          CData_Dstore(idDest,dlm_rand_gauss_bm(),j,i);
	return O_K;
}

INT16 CGmm_Setup(CGmm* _this, data* idMean, data* idCov, vmap* iMmap)
{
    return CGmm_SetupEx(_this,idMean,idCov,iMmap,NULL,NULL);
	return O_K;
}

/*}}CGEN_CSMIC */


/* Generated option change callback functions */

/*{{CGEN_COCCF */
INT16 CGmm_OnSse2Set(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CGmm,NOT_EXEC);
	{
    if (!CGmm_Sse2())
    {
      _this->m_bSse2 = FALSE;
      return IERROR(_this,ERR_NOTSUPPORTED,"/sse2",0,0);
    }
	}

	return O_K;
}

/*}}CGEN_COCCF */


/* Generated field change callback functions */

/*{{CGEN_CFCCF */
/*}}CGEN_CFCCF */


/* C++ wrapper functions */
#ifdef __cplusplus

#define _this this

CGmm::CGmm(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	CGmm_Constructor(this,lpInstanceName,bCallVirtual);
}

CGmm::~CGmm()
{
	CGmm_Destructor(this);
}

INT16 CGmm::AutoRegisterWords()
{
	return CGmm_AutoRegisterWords(this);
}

INT16 CGmm::Init(BOOL bCallVirtual)
{
	return CGmm_Init(this,bCallVirtual);
}

INT16 CGmm::Reset(BOOL bResetMembers)
{
	return CGmm_Reset(this,bResetMembers);
}

INT16 CGmm::ClassProc()
{
	return CGmm_ClassProc(this);
}

INT16 CGmm::Serialize(CDN3Stream* lpDest)
{
	return CGmm_Serialize(this,lpDest);
}

INT16 CGmm::SerializeXml(CXmlStream* lpDest)
{
	return CGmm_SerializeXml(this,lpDest);
}

INT16 CGmm::Deserialize(CDN3Stream* lpSrc)
{
	return CGmm_Deserialize(this,lpSrc);
}

INT16 CGmm::DeserializeXml(CXmlStream* lpSrc)
{
	return CGmm_DeserializeXml(this,lpSrc);
}

INT16 CGmm::Copy(CDlpObject* __iSrc)
{
	return CGmm_Copy(this,__iSrc);
}

INT16 CGmm::InstallProc(void* lpItp)
{
	return CGmm_InstallProc(lpItp);
}

CGmm* CGmm::CreateInstance(const char* lpName)
{
	return CGmm_CreateInstance(lpName);
}

INT16 CGmm::GetClassInfo(SWord* lpClassWord)
{
	return CGmm_GetClassInfo(lpClassWord);
}

INT16 CGmm::GetInstanceInfo(SWord* lpClassWord)
{
	return CGmm_GetInstanceInfo(this,lpClassWord);
}

BOOL CGmm::IsKindOf(const char* lpClassName)
{
	return CGmm_IsKindOf(this,lpClassName);
}

INT16 CGmm::ResetAllOptions(BOOL bInit)
{
	return CGmm_ResetAllOptions(this,bInit);
}

#ifndef __NOITP
/*{{CGEN_PMIC */
INT16 CGmm::OnDensity()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CGmm_OnDensity(this);
}

INT16 CGmm::OnDistance()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CGmm_OnDistance(this);
}

INT16 CGmm::OnExtract()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CGmm_OnExtract(this);
}

INT16 CGmm::OnGetNValidGauss()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CGmm_OnGetNValidGauss(this);
}

INT16 CGmm::OnNoise()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CGmm_OnNoise(this);
}

INT16 CGmm::OnSetup()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CGmm_OnSetup(this);
}

INT16 CGmm::OnSetupEx()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CGmm_OnSetupEx(this);
}

INT16 CGmm::OnSplit()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CGmm_OnSplit(this);
}

INT16 CGmm::OnStatus()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CGmm_OnStatus(this);
}

/*}}CGEN_PMIC */
#endif /* #ifndef __NOITP */

/*{{CGEN_SMIC */
INT16 CGmm::Density(data* idX, data* idXmap, data* idDens)
{
	return CGmm_Density(this,idX, idXmap, idDens);
}

INT16 CGmm::Distance(data* idX, data* idXmap, data* idDist)
{
	return CGmm_Distance(this,idX, idXmap, idDist);
}

INT16 CGmm::Noise(INT64 nDim, INT64 nRecs, data* idDest)
{
	return CGmm_Noise(this,nDim, nRecs, idDest);
}

INT16 CGmm::Setup(data* idMean, data* idCov, vmap* iMmap)
{
	return CGmm_Setup(this,idMean, idCov, iMmap);
}

/*}}CGEN_SMIC */

/*{{CGEN_OCCF */
INT16 CGmm::OnSse2Set()
{
	return CGmm_OnSse2Set(this);
}

/*}}CGEN_OCCF */

/*{{CGEN_FCCF */
/*}}CGEN_FCCF */

/*{{CGEN_CXXWRAP */
INT16 CGmm::GetTypeEx(CData* idMean)
{
	return CGmm_GetTypeEx(this, idMean);
}

INT16 CGmm::GetType()
{
	return CGmm_GetType(this);
}

INT32 CGmm::GetDim()
{
	return CGmm_GetDim(this);
}

INT32 CGmm::GetNMix()
{
	return CGmm_GetNMix(this);
}

INT32 CGmm::GetNGauss()
{
	return CGmm_GetNGauss(this);
}

INT32 CGmm::GetNValidGauss()
{
	return CGmm_GetNValidGauss(this);
}

INT32 CGmm::GetNIcov()
{
	return CGmm_GetNIcov(this);
}

FLOAT64 CGmm::GetLimit(INT16 nMode)
{
	return CGmm_GetLimit(this, nMode);
}

INT16 CGmm::IsValidGauss(INT32 k)
{
	return CGmm_IsValidGauss(this, k);
}

INT16 CGmm::CheckMean()
{
	return CGmm_CheckMean(this);
}

INT16 CGmm::CheckIvar()
{
	return CGmm_CheckIvar(this);
}

INT16 CGmm::CheckCdet()
{
	return CGmm_CheckCdet(this);
}

INT16 CGmm::CheckIcov()
{
	return CGmm_CheckIcov(this);
}

INT16 CGmm::CheckMmap()
{
	return CGmm_CheckMmap(this);
}

INT16 CGmm::CheckCmap()
{
	return CGmm_CheckCmap(this);
}

INT16 CGmm::CheckPrecalc()
{
	return CGmm_CheckPrecalc(this);
}

INT16 CGmm::Check()
{
	return CGmm_Check(this);
}

INT16 CGmm::Status()
{
	return CGmm_Status(this);
}

FLOAT64 CGmm::Split_Icov(FLOAT64* lpMean, FLOAT64* lpCov, FLOAT64* lpMeanS1, FLOAT64* lpCovS1, FLOAT64* lpMeanS2, FLOAT64* lpCovS2, INT32 N)
{
	return CGmm_Split_Icov(this, lpMean, lpCov, lpMeanS1, lpCovS1, lpMeanS2, lpCovS2, N);
}

INT16 CGmm::Split(FLOAT64 nParam, CData* idMap)
{
	return CGmm_Split(this, nParam, idMap);
}

INT16 CGmm::SetupEx(CData* idMean, CData* idCov, CVmap* iMmap, CData* idCmap, CData* idVar)
{
	return CGmm_SetupEx(this, idMean, idCov, iMmap, idCmap, idVar);
}

INT16 CGmm::Extract(CData* idMean, CData* idIcov)
{
	return CGmm_Extract(this, idMean, idIcov);
}

BOOL CGmm::Sse2()
{
	return CGmm_Sse2();
}

INT32 CGmm::Icov(CData* idCov, BOOL bIcov)
{
	return CGmm_Icov(this, idCov, bIcov);
}

void CGmm::ClearGamma()
{
	CGmm_ClearGamma(this);
}

INT16 CGmm::Precalc(BOOL bCleanup)
{
	return CGmm_Precalc(this, bCleanup);
}

INT16 CGmm::Gauss(CData* idX, CData* idXmap, CData* idDest, INT16 nMode)
{
	return CGmm_Gauss(this, idX, idXmap, idDest, nMode);
}

/*}}CGEN_CXXWRAP */

#endif /* #ifdef __cplusplus */

/* EOF */
