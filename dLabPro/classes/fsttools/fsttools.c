/* dLabPro class CFsttools (fsttools)
 * - Tools for FST modification
 *
 * AUTHOR : frank.duckhorn
 * PACKAGE: dLabPro/classes
 *
 * This file was generated by dcg. DO NOT MODIFY! Modify fsttools.def instead.
 * 
 * Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
 * - Chair of System Theory and Speech Technology, TU Dresden
 * - Chair of Communications Engineering, BTU Cottbus
 * 
 * This file is part of dLabPro.
 * 
 * dLabPro is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 * 
 * dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with dLabPro. If not, see <http://www.gnu.org/licenses/>.
 */

#include "dlp_cscope.h" /* Indicate C scope */
/*{{CGEN_INCLUDE */
/*}}CGEN_END */
#include "dlp_fsttools.h"

/* Class CFsttools */

void CFsttools_Constructor(CFsttools* _this, const char* lpInstanceName, BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CFsttools_Constructor; (bCallVirtual=%d)",(int)bCallVirtual,0,0);

#ifndef __cplusplus

	/* Register instance */
	dlp_xalloc_register_object('J',_this,1,sizeof(CFsttools),
		__FILE__,__LINE__,"fsttools",lpInstanceName);

	/* Create base instance */
	_this->m_lpBaseInstance = calloc(1,sizeof(CDlpObject));
	CDlpObject_Constructor(_this->m_lpBaseInstance,lpInstanceName,FALSE);

	/* Override virtual member functions */
	_this->m_lpBaseInstance->AutoRegisterWords = CFsttools_AutoRegisterWords;
	_this->m_lpBaseInstance->Reset             = CFsttools_Reset;
	_this->m_lpBaseInstance->Init              = CFsttools_Init;
	_this->m_lpBaseInstance->Serialize         = CFsttools_Serialize;
	_this->m_lpBaseInstance->SerializeXml      = CFsttools_SerializeXml;
	_this->m_lpBaseInstance->Deserialize       = CFsttools_Deserialize;
	_this->m_lpBaseInstance->DeserializeXml    = CFsttools_DeserializeXml;
	_this->m_lpBaseInstance->Copy              = CFsttools_Copy;
	_this->m_lpBaseInstance->ClassProc         = CFsttools_ClassProc;
	_this->m_lpBaseInstance->GetInstanceInfo   = CFsttools_GetInstanceInfo;
	_this->m_lpBaseInstance->IsKindOf          = CFsttools_IsKindOf;
	_this->m_lpBaseInstance->Destructor        = CFsttools_Destructor;
	_this->m_lpBaseInstance->ResetAllOptions   = CFsttools_ResetAllOptions;

	/* Override pointer to derived instance */
	_this->m_lpBaseInstance->m_lpDerivedInstance = _this;

	#endif /* #ifndef __cplusplus */

	dlp_strcpy(BASEINST(_this)->m_lpClassName,"fsttools");
	dlp_strcpy(BASEINST(_this)->m_lpObsoleteName,"");
	dlp_strcpy(BASEINST(_this)->m_lpProjectName,"fsttools");
	dlp_strcpy(BASEINST(_this)->m_version.no,"1.00 DLC22");
	dlp_strcpy(BASEINST(_this)->m_version.date,"");
	BASEINST(_this)->m_nClStyle = CS_AUTOACTIVATE;

	if (bCallVirtual)
	{
		DLPASSERT(OK(INVOKE_VIRTUAL_0(AutoRegisterWords)));
		INVOKE_VIRTUAL_1(Init,TRUE);
	}
}

void CFsttools_Destructor(CDlpObject* __this)
{
	GET_THIS_VIRTUAL(CFsttools);
	{
	/*{{CGEN_DONECODE */
  DONE;
	/*}}CGEN_DONECODE */
	}

#ifndef __cplusplus

	/* Destroy base instance */
	CDlpObject_Destructor(_this->m_lpBaseInstance);
	dlp_free(_this->m_lpBaseInstance);
	_this->m_lpBaseInstance = NULL;

#endif /* #ifndef __cplusplus */
}

INT16 CFsttools_AutoRegisterWords(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	DEBUGMSG(-1,"CFsttools_AutoRegisterWords",0,0,0);

	/* Call base class implementation */
	IF_NOK(INVOKE_BASEINST_0(AutoRegisterWords)) return NOT_EXEC;

	/*{{CGEN_REGISTERWORDS */

	/* Register methods */
	REGISTER_METHOD("-compute_path","",LPMF(CFsttools,OnComputePath),"computes path weights for path length nIt",0,"<data idTrans> <long nIt> <data idPath> <fst itFst> <fsttools this>","")
	REGISTER_METHOD("-getlogprob","",LPMF(CFsttools,OnGetlogprob),"Get logarithmic probability of N-gram",0,"<short nSeqLen> <data idSeq> <long nUnit> <fst itFst> <fsttools this>","")
	REGISTER_METHOD("-lm_add_input_trans","",LPMF(CFsttools,OnLmAddInputTrans),"Insert input transitions into states for composition",0,"<fst itLM> <long nUnit> <fsttools this>","")
	REGISTER_METHOD("-lm_cluster_classes","",LPMF(CFsttools,OnLmClusterClasses),"Clusters words of a language model fst into classes",0,"<fst itLM> <long nNClass> <long nNLoops> <data idClassMap> <fsttools this>","")
	REGISTER_METHOD("-nmg2lm","",LPMF(CFsttools,OnNmg2lm),"Convert n-multi-gram fst into language model fst (composable with lexicon, acoustic model)",0,"<fst itSrc> <long nUnit> <long nNGram> <fst itDst> <fsttools this>","")
	REGISTER_METHOD("-one_tis_per_path","",LPMF(CFsttools,OnOneTisPerPath),"Each input symbol only once per path",0,"<long nUnit> <fst itFst> <fsttools this>","")
	REGISTER_METHOD("-rc_by_used_path","",LPMF(CFsttools,OnRcByUsedPath),"Adds trans.RCs and pathweight to histroy or initializes new trans.RCs from history",0,"<data idTransRC> <double nPathWeight> <long nUnit> <BOOL bReset> <data idUnitTransCount> <fst itFst> <fsttools this>","")
	REGISTER_METHOD("-remove_ex_loops","",LPMF(CFsttools,OnRemoveExLoops),"remove all follwing transitions with the same input symbol",0,"<long nUnit> <fst itFst> <fsttools this>","")
	REGISTER_METHOD("-remove_ml2","",LPMF(CFsttools,OnRemoveMl2),"Remove ml2 compostion transitions",0,"<fst itR> <fsttools this>","")
	REGISTER_METHOD("-restore_loops","",LPMF(CFsttools,OnRestoreLoops),"restores loops according to that in itSrc",0,"<fst itSrc> <long nUnit> <fst itDst> <fsttools this>","")
	REGISTER_METHOD("-smooth","",LPMF(CFsttools,OnSmooth),"(Re-)Estimates transition propabilities, add fallback transitions",0,"<short nKGt> <double nDelta> <long nUnit> <fst itFst> <fsttools this>","")
	REGISTER_METHOD("-sum_comp_id","",LPMF(CFsttools,OnSumCompId),"Sum component values according index comp. Cid (DstRecs = max index)",0,"<data Src> <long Cid> <long DstRecs> <data Dst> <fsttools this>","")

	/* Register options */
	REGISTER_OPTION("/add","",LPMV(m_bAdd),NULL,"Add-Delta-Smoothing",0)
	REGISTER_OPTION("/gt","",LPMV(m_bGt),NULL,"Good-Turing-Smoothing",0)
	REGISTER_OPTION("/wb","",LPMV(m_bWb),NULL,"Witten-Bell-Smoothing",0)

	/* Register errors */
	REGISTER_ERROR("~e1_0_0__1",EL_ERROR,FSTTOOLS_NOMEM,"Not enough memory available.")
	REGISTER_ERROR("~e2_0_0__1",EL_ERROR,FSTTOOLS_ARGUMENT,"Wrong type of argument '%s'.")
	REGISTER_ERROR("~e3_0_0__1",EL_ERROR,FSTTOOLS_NULL,"Argument '%s' must not be NULL.")
	REGISTER_ERROR("~e4_0_0__1",EL_ERROR,FSTTOOLS_EMPTY,"Argument '%s' must not be empty.")
	REGISTER_ERROR("~e5_0_0__1",EL_ERROR,FSTTOOLS_MISSCOMP,"Component %d not found in '%s'.")
	REGISTER_ERROR("~e6_0_0__1",EL_ERROR,FSTTOOLS_COMPTYPE,"Component %d in '%s' is not of %s type.")
	REGISTER_ERROR("~e7_0_0__1",EL_ERROR,FSTTOOLS_STAT,"Mean and covariances do not fit.")
	REGISTER_ERROR("~e8_0_0__1",EL_ERROR,FSTTOOLS_MAPPING_FAILED,"Mapping of state index for record %d failed.")
	/*}}CGEN_REGISTERWORDS */

	return O_K;
}

INT16 CFsttools_Init(CDlpObject* __this, BOOL bCallVirtual)
{
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	DEBUGMSG(-1,"CFsttools_Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	{
	/*{{CGEN_INITCODE */
  INIT;
	/*}}CGEN_INITCODE */
	}

	/* If last derivation call reset (do not reset members; already done by Init()) */
#ifndef __NORTTI
	if (bCallVirtual) return INVOKE_VIRTUAL_1(Reset,FALSE); else
#endif
	                  return O_K;
}

INT16 CFsttools_Reset(CDlpObject* __this, BOOL bResetMembers)
{
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	DEBUGMSG(-1,"CFsttools_Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	{
	/*{{CGEN_RESETCODE */
  RESET;
	/*}}CGEN_RESETCODE */
	}

	return O_K;
}

INT16 CFsttools_ClassProc(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	{
	/*{{CGEN_CLASSCODE */
  return CLASSPROC;
	/*}}CGEN_CLASSCODE */
	}

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CFsttools_Serialize(CDlpObject* __this, CDN3Stream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
  return SAVE;
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CFsttools_SerializeXml(CDlpObject* __this, CXmlStream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
  return SAVE;
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CFsttools_Deserialize(CDlpObject* __this, CDN3Stream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
  return RESTORE;
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CFsttools_DeserializeXml(CDlpObject* __this, CXmlStream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
  return RESTORE;
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CFsttools_Copy(CDlpObject* __this, CDlpObject* __iSrc)
{
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	{
	/*{{CGEN_COPYCODE */
  return COPY;
	/*}}CGEN_COPYCODE */
	}

	return O_K;
}

/* Runtime class type information and class factory */
INT16 CFsttools_InstallProc(void* lpItp)
{
	{
	/*{{CGEN_INSTALLCODE */
  return INSTALL;
	/*}}CGEN_INSTALLCODE */
	}

	return O_K;
}

CFsttools* CFsttools_CreateInstance(const char* lpName)
{
	CFsttools* lpNewInstance;
	ICREATEEX(CFsttools,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CFsttools_GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOACTIVATE;

#ifdef __cplusplus

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CFsttools::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CFsttools::InstallProc;

#else /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CFsttools_CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CFsttools_InstallProc;

#endif /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpProject   = "fsttools";
	lpClassWord->ex.fct.lpBaseClass = "-";
	lpClassWord->lpComment          = "Tools for FST modification";
	lpClassWord->ex.fct.lpAutoname  = "";
	lpClassWord->ex.fct.lpCname     = "CFsttools";
	lpClassWord->ex.fct.lpAuthor    = "frank.duckhorn";

	dlp_strcpy(lpClassWord->lpName             ,"fsttools");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"1.00 DLC22");

	return O_K;
}

INT16 CFsttools_GetInstanceInfo(CDlpObject* __this, SWord* lpClassWord)
{
	return CFsttools_GetClassInfo(lpClassWord);
}

BOOL CFsttools_IsKindOf(CDlpObject* __this, const char* lpClassName)
{
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);

  if (dlp_strncmp(lpClassName,"fsttools",L_NAMES) == 0) return TRUE;
	else return INVOKE_BASEINST_1(IsKindOf,lpClassName);
}

INT16 CFsttools_ResetAllOptions(CDlpObject* __this, BOOL bInit)
{
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	DEBUGMSG(-1,"CFsttools_ResetAllOptions;",0,0,0);
	{
	/*{{CGEN_RESETALLOPTIONS*/
	_this->m_bAdd = FALSE;
	_this->m_bGt = FALSE;
	_this->m_bWb = FALSE;
	/*}}CGEN_RESETALLOPTIONS*/
	}

	return INVOKE_BASEINST_1(ResetAllOptions,bInit);
}

/* Generated primary method invocation functions */

#ifndef __NOITP
/*{{CGEN_CPMIC */
INT16 CFsttools_OnComputePath(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idTrans;
	INT64 nIt;
	data* idPath;
	fst* itFst;
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itFst = MIC_GET_I_EX(itFst,fst,1,1);
	idPath = MIC_GET_I_EX(idPath,data,2,2);
	nIt = (INT64)MIC_GET_N(3,0);
	idTrans = MIC_GET_I_EX(idTrans,data,4,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFsttools_ComputePath(_this, idTrans, nIt, idPath, itFst);
	return __nErr;
}

INT16 CFsttools_OnGetlogprob(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT16 nSeqLen;
	data* idSeq;
	INT64 nUnit;
	fst* itFst;
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itFst = MIC_GET_I_EX(itFst,fst,1,1);
	nUnit = (INT64)MIC_GET_N(2,0);
	idSeq = MIC_GET_I_EX(idSeq,data,3,2);
	nSeqLen = (INT16)MIC_GET_N(4,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_N(CFsttools_Getlogprob(_this, nSeqLen, idSeq, nUnit, itFst));
	return __nErr;
}

INT16 CFsttools_OnLmAddInputTrans(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itLM;
	INT64 nUnit;
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT64)MIC_GET_N(1,0);
	itLM = MIC_GET_I_EX(itLM,fst,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFsttools_LmAddInputTrans(_this, itLM, nUnit);
	return __nErr;
}

INT16 CFsttools_OnLmClusterClasses(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itLM;
	INT64 nNClass;
	INT64 nNLoops;
	data* idClassMap;
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idClassMap = MIC_GET_I_EX(idClassMap,data,1,1);
	nNLoops = (INT64)MIC_GET_N(2,0);
	nNClass = (INT64)MIC_GET_N(3,1);
	itLM = MIC_GET_I_EX(itLM,fst,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFsttools_LmClusterClasses(_this, itLM, nNClass, nNLoops, idClassMap);
	return __nErr;
}

INT16 CFsttools_OnNmg2lm(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT64 nUnit;
	INT64 nNGram;
	fst* itDst;
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itDst = MIC_GET_I_EX(itDst,fst,1,1);
	nNGram = (INT64)MIC_GET_N(2,0);
	nUnit = (INT64)MIC_GET_N(3,1);
	itSrc = MIC_GET_I_EX(itSrc,fst,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFsttools_Nmg2lm(_this, itSrc, nUnit, nNGram, itDst);
	return __nErr;
}

INT16 CFsttools_OnOneTisPerPath(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT64 nUnit;
	fst* itFst;
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itFst = MIC_GET_I_EX(itFst,fst,1,1);
	nUnit = (INT64)MIC_GET_N(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFsttools_OneTisPerPath(_this, nUnit, itFst);
	return __nErr;
}

INT16 CFsttools_OnRcByUsedPath(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idTransRC;
	FLOAT64 nPathWeight;
	INT64 nUnit;
	BOOL bReset;
	data* idUnitTransCount;
	fst* itFst;
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itFst = MIC_GET_I_EX(itFst,fst,1,1);
	idUnitTransCount = MIC_GET_I_EX(idUnitTransCount,data,2,2);
	bReset = MIC_GET_B(3,0);
	nUnit = (INT64)MIC_GET_N(4,0);
	nPathWeight = MIC_GET_N(5,1);
	idTransRC = MIC_GET_I_EX(idTransRC,data,6,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFsttools_RcByUsedPath(_this, idTransRC, nPathWeight, nUnit, bReset, idUnitTransCount, itFst);
	return __nErr;
}

INT16 CFsttools_OnRemoveExLoops(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT64 nUnit;
	fst* itFst;
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itFst = MIC_GET_I_EX(itFst,fst,1,1);
	nUnit = (INT64)MIC_GET_N(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFsttools_RemoveExLoops(_this, nUnit, itFst);
	return __nErr;
}

INT16 CFsttools_OnRemoveMl2(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itR;
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itR = MIC_GET_I_EX(itR,fst,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFsttools_RemoveMl2(_this, itR);
	return __nErr;
}

INT16 CFsttools_OnRestoreLoops(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT64 nUnit;
	fst* itDst;
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itDst = MIC_GET_I_EX(itDst,fst,1,1);
	nUnit = (INT64)MIC_GET_N(2,0);
	itSrc = MIC_GET_I_EX(itSrc,fst,3,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFsttools_RestoreLoops(_this, itSrc, nUnit, itDst);
	return __nErr;
}

INT16 CFsttools_OnSmooth(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT16 nKGt;
	FLOAT64 nDelta;
	INT64 nUnit;
	fst* itFst;
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itFst = MIC_GET_I_EX(itFst,fst,1,1);
	nUnit = (INT64)MIC_GET_N(2,0);
	nDelta = MIC_GET_N(3,1);
	nKGt = (INT16)MIC_GET_N(4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFsttools_Smooth(_this, nKGt, nDelta, nUnit, itFst);
	return __nErr;
}

INT16 CFsttools_OnSumCompId(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* Src;
	INT64 Cid;
	INT64 DstRecs;
	data* Dst;
	GET_THIS_VIRTUAL_RV(CFsttools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	Dst = MIC_GET_I_EX(Dst,data,1,1);
	DstRecs = (INT64)MIC_GET_N(2,0);
	Cid = (INT64)MIC_GET_N(3,1);
	Src = MIC_GET_I_EX(Src,data,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFsttools_SumCompId(_this, Src, Cid, DstRecs, Dst);
	return __nErr;
}

/*}}CGEN_CPMIC */
#endif /* #ifndef __NOITP */


/* Generated secondary method invocation functions */

/*{{CGEN_CSMIC */
/*}}CGEN_CSMIC */


/* Generated option change callback functions */

/*{{CGEN_COCCF */
/*}}CGEN_COCCF */


/* Generated field change callback functions */

/*{{CGEN_CFCCF */
/*}}CGEN_CFCCF */


/* C++ wrapper functions */
#ifdef __cplusplus

#define _this this

CFsttools::CFsttools(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	CFsttools_Constructor(this,lpInstanceName,bCallVirtual);
}

CFsttools::~CFsttools()
{
	CFsttools_Destructor(this);
}

INT16 CFsttools::AutoRegisterWords()
{
	return CFsttools_AutoRegisterWords(this);
}

INT16 CFsttools::Init(BOOL bCallVirtual)
{
	return CFsttools_Init(this,bCallVirtual);
}

INT16 CFsttools::Reset(BOOL bResetMembers)
{
	return CFsttools_Reset(this,bResetMembers);
}

INT16 CFsttools::ClassProc()
{
	return CFsttools_ClassProc(this);
}

INT16 CFsttools::Serialize(CDN3Stream* lpDest)
{
	return CFsttools_Serialize(this,lpDest);
}

INT16 CFsttools::SerializeXml(CXmlStream* lpDest)
{
	return CFsttools_SerializeXml(this,lpDest);
}

INT16 CFsttools::Deserialize(CDN3Stream* lpSrc)
{
	return CFsttools_Deserialize(this,lpSrc);
}

INT16 CFsttools::DeserializeXml(CXmlStream* lpSrc)
{
	return CFsttools_DeserializeXml(this,lpSrc);
}

INT16 CFsttools::Copy(CDlpObject* __iSrc)
{
	return CFsttools_Copy(this,__iSrc);
}

INT16 CFsttools::InstallProc(void* lpItp)
{
	return CFsttools_InstallProc(lpItp);
}

CFsttools* CFsttools::CreateInstance(const char* lpName)
{
	return CFsttools_CreateInstance(lpName);
}

INT16 CFsttools::GetClassInfo(SWord* lpClassWord)
{
	return CFsttools_GetClassInfo(lpClassWord);
}

INT16 CFsttools::GetInstanceInfo(SWord* lpClassWord)
{
	return CFsttools_GetInstanceInfo(this,lpClassWord);
}

BOOL CFsttools::IsKindOf(const char* lpClassName)
{
	return CFsttools_IsKindOf(this,lpClassName);
}

INT16 CFsttools::ResetAllOptions(BOOL bInit)
{
	return CFsttools_ResetAllOptions(this,bInit);
}

#ifndef __NOITP
/*{{CGEN_PMIC */
INT16 CFsttools::OnComputePath()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFsttools_OnComputePath(this);
}

INT16 CFsttools::OnGetlogprob()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFsttools_OnGetlogprob(this);
}

INT16 CFsttools::OnLmAddInputTrans()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFsttools_OnLmAddInputTrans(this);
}

INT16 CFsttools::OnLmClusterClasses()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFsttools_OnLmClusterClasses(this);
}

INT16 CFsttools::OnNmg2lm()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFsttools_OnNmg2lm(this);
}

INT16 CFsttools::OnOneTisPerPath()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFsttools_OnOneTisPerPath(this);
}

INT16 CFsttools::OnRcByUsedPath()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFsttools_OnRcByUsedPath(this);
}

INT16 CFsttools::OnRemoveExLoops()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFsttools_OnRemoveExLoops(this);
}

INT16 CFsttools::OnRemoveMl2()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFsttools_OnRemoveMl2(this);
}

INT16 CFsttools::OnRestoreLoops()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFsttools_OnRestoreLoops(this);
}

INT16 CFsttools::OnSmooth()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFsttools_OnSmooth(this);
}

INT16 CFsttools::OnSumCompId()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFsttools_OnSumCompId(this);
}

/*}}CGEN_PMIC */
#endif /* #ifndef __NOITP */

/*{{CGEN_SMIC */
/*}}CGEN_SMIC */

/*{{CGEN_OCCF */
/*}}CGEN_OCCF */

/*{{CGEN_FCCF */
/*}}CGEN_FCCF */

/*{{CGEN_CXXWRAP */
INT16 CFsttools::RemoveExLoops(INT32 nUnit, CFst * itFst)
{
	return CFsttools_RemoveExLoops(this, nUnit, itFst);
}

INT16 CFsttools::OneTisPerPath(INT32 nUnit, CFst* itFst)
{
	return CFsttools_OneTisPerPath(this, nUnit, itFst);
}

INT16 CFsttools::RestoreLoops(CFst* itSrc, INT32 nUnit, CFst* itDst)
{
	return CFsttools_RestoreLoops(this, itSrc, nUnit, itDst);
}

INT16 CFsttools::ComputePath(CData* idTrans, INT32 nIt, CData* idPath, CFst* itFst)
{
	return CFsttools_ComputePath(this, idTrans, nIt, idPath, itFst);
}

INT16 CFsttools::RcByUsedPath(CData* idTransRC, FLOAT64 nPathWeight, INT32 nUnit, BOOL bReset, CData* idUnitTransCount, CFst* itFst)
{
	return CFsttools_RcByUsedPath(this, idTransRC, nPathWeight, nUnit, bReset, idUnitTransCount, itFst);
}

INT16 CFsttools::SumCompId(CData* Src, INT32 Cid, INT32 DstRecs, CData* Dst)
{
	return CFsttools_SumCompId(this, Src, Cid, DstRecs, Dst);
}

INT16 CFsttools::LmClusterClasses(CFst* itLM, INT32 nNClass, INT32 nNLoops, CData* idClassMap)
{
	return CFsttools_LmClusterClasses(this, itLM, nNClass, nNLoops, idClassMap);
}

INT16 CFsttools::Smooth(INT16 nKGt, FLOAT64 nDelta, INT32 nUnit, CFst* itFst)
{
	return CFsttools_Smooth(this, nKGt, nDelta, nUnit, itFst);
}

FLOAT64 CFsttools::Getlogprob(INT16 nSeqLen, CData* idSeq, INT32 nUnit, CFst* itFst)
{
	return CFsttools_Getlogprob(this, nSeqLen, idSeq, nUnit, itFst);
}

INT16 CFsttools::Nmg2lm(CFst* itSrc, INT32 nUnit, INT32 nNGram, CFst* itDst)
{
	return CFsttools_Nmg2lm(this, itSrc, nUnit, nNGram, itDst);
}

INT16 CFsttools::LmAddInputTrans(CFst* itLM, INT32 nUnit)
{
	return CFsttools_LmAddInputTrans(this, itLM, nUnit);
}

INT16 CFsttools::RemoveMl2(CFst* itR)
{
	return CFsttools_RemoveMl2(this, itR);
}

/*}}CGEN_CXXWRAP */

#endif /* #ifdef __cplusplus */

/* EOF */
