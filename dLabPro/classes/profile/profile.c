/* dLabPro class CProfile (profile)
 * - Profiler and debugging tools.
 *
 * AUTHOR : M. Eichner
 * PACKAGE: dLabPro/classes
 *
 * This file was generated by dcg. DO NOT MODIFY! Modify profile.def instead.
 * 
 * Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
 * - Chair of System Theory and Speech Technology, TU Dresden
 * - Chair of Communications Engineering, BTU Cottbus
 * 
 * This file is part of dLabPro.
 * 
 * dLabPro is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 * 
 * dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with dLabPro. If not, see <http://www.gnu.org/licenses/>.
 */

#include "dlp_cscope.h" /* Indicate C scope */
/*{{CGEN_INCLUDE */
#include <time.h>
/*}}CGEN_END */
#include "dlp_profile.h"

/* Class CProfile */

void CProfile_Constructor(CProfile* _this, const char* lpInstanceName, BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CProfile_Constructor; (bCallVirtual=%d)",(int)bCallVirtual,0,0);

#ifndef __cplusplus

	/* Register instance */
	dlp_xalloc_register_object('J',_this,1,sizeof(CProfile),
		__FILE__,__LINE__,"profile",lpInstanceName);

	/* Create base instance */
	_this->m_lpBaseInstance = calloc(1,sizeof(CDlpObject));
	CDlpObject_Constructor(_this->m_lpBaseInstance,lpInstanceName,FALSE);

	/* Override virtual member functions */
	_this->m_lpBaseInstance->AutoRegisterWords = CProfile_AutoRegisterWords;
	_this->m_lpBaseInstance->Reset             = CProfile_Reset;
	_this->m_lpBaseInstance->Init              = CProfile_Init;
	_this->m_lpBaseInstance->Serialize         = CProfile_Serialize;
	_this->m_lpBaseInstance->SerializeXml      = CProfile_SerializeXml;
	_this->m_lpBaseInstance->Deserialize       = CProfile_Deserialize;
	_this->m_lpBaseInstance->DeserializeXml    = CProfile_DeserializeXml;
	_this->m_lpBaseInstance->Copy              = CProfile_Copy;
	_this->m_lpBaseInstance->ClassProc         = CProfile_ClassProc;
	_this->m_lpBaseInstance->GetInstanceInfo   = CProfile_GetInstanceInfo;
	_this->m_lpBaseInstance->IsKindOf          = CProfile_IsKindOf;
	_this->m_lpBaseInstance->Destructor        = CProfile_Destructor;
	_this->m_lpBaseInstance->ResetAllOptions   = CProfile_ResetAllOptions;

	/* Override pointer to derived instance */
	_this->m_lpBaseInstance->m_lpDerivedInstance = _this;

	#endif /* #ifndef __cplusplus */

	dlp_strcpy(BASEINST(_this)->m_lpClassName,"profile");
	dlp_strcpy(BASEINST(_this)->m_lpObsoleteName,"");
	dlp_strcpy(BASEINST(_this)->m_lpProjectName,"profile");
	dlp_strcpy(BASEINST(_this)->m_version.no,"1.1");
	dlp_strcpy(BASEINST(_this)->m_version.date,"");
	BASEINST(_this)->m_nClStyle = CS_AUTOINSTANCE;

	if (bCallVirtual)
	{
		DLPASSERT(OK(INVOKE_VIRTUAL_0(AutoRegisterWords)));
		INVOKE_VIRTUAL_1(Init,TRUE);
	}
}

void CProfile_Destructor(CDlpObject* __this)
{
	GET_THIS_VIRTUAL(CProfile);
	{
	/*{{CGEN_DONECODE */
  DONE;
	/*}}CGEN_DONECODE */
	}

#ifndef __cplusplus

	/* Destroy base instance */
	CDlpObject_Destructor(_this->m_lpBaseInstance);
	dlp_free(_this->m_lpBaseInstance);
	_this->m_lpBaseInstance = NULL;

#endif /* #ifndef __cplusplus */
}

INT16 CProfile_AutoRegisterWords(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	DEBUGMSG(-1,"CProfile_AutoRegisterWords",0,0,0);

	/* Call base class implementation */
	IF_NOK(INVOKE_BASEINST_0(AutoRegisterWords)) return NOT_EXEC;

	/*{{CGEN_REGISTERWORDS */

	/* Register methods */
	REGISTER_METHOD("-assert","",LPMF(CProfile,OnAssert),"Assert if top of logic stack is FALSE",0,"<BOOL bCondition> <profile this>","")
	REGISTER_METHOD("-begin_timer","",LPMF(CProfile,OnBeginTimer),"Init and start timer.",0,"<profile this>","")
	REGISTER_METHOD("-break_timer","",LPMF(CProfile,OnBreakTimer),"Break timer.",0,"<profile this>","")
	REGISTER_METHOD("-check_heap","",LPMF(CProfile,OnCheckHeap),"Check heap integrity (only on windows platforms).",0,"<profile this>","")
	REGISTER_METHOD("-cont_timer","",LPMF(CProfile,OnContTimer),"Continue timer.",0,"<profile this>","")
	REGISTER_METHOD("-date","",LPMF(CProfile,OnDate),"Pushes the current date in the format 'yyyy-mm-dd' on the string stack.",0,"<profile this>","")
	REGISTER_METHOD("-end_timer","",LPMF(CProfile,OnEndTimer),"Stop timer and display measured time.",0,"<cstring sMsg> <profile this>","")
	REGISTER_METHOD("-reset_timer","",LPMF(CProfile,OnResetTimer),"Clear timer.",0,"<profile this>","")
	REGISTER_METHOD("-show_timer","",LPMF(CProfile,OnShowTimer),"Show timer.",0,"<cstring sMsg> <profile this>","")
	REGISTER_METHOD("-time","",LPMF(CProfile,OnTime),"Pushes the current time in the format 'hhmmss' on the string stack.",0,"<profile this>","")
	REGISTER_METHOD("-tstamp","",LPMF(CProfile,OnTstamp),"Pushes a time stamp in the format 'XXXXX-XXXXX' on the string stack.",0,"<profile this>","")

	/* Register fields */
	REGISTER_FIELD("calls","",LPMV(m_nCalls),NULL,"Number of measured timer intervals.",FF_NOSET,2004,1,"int",(INT32)0)
	REGISTER_FIELD("time","",LPMV(m_nTime),NULL,"Accumulated time im milliseconds.",FF_NOSET,2008,1,"long",(INT64)0)
	REGISTER_FIELD("time0","",LPMV(m_nTime0),NULL,"",FF_HIDDEN | FF_NOSET,2008,1,"long",(INT64)0)
	REGISTER_FIELD("tstamp","",LPMV(m_sTstamp),NULL,"Stores the date, time or timestamp.",FF_NOSET,24,24,"char[24]","")
	/*}}CGEN_REGISTERWORDS */

	return O_K;
}

INT16 CProfile_Init(CDlpObject* __this, BOOL bCallVirtual)
{
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	DEBUGMSG(-1,"CProfile_Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	{
	/*{{CGEN_INITCODE */
  INIT;
	/*}}CGEN_INITCODE */
	}

	/* If last derivation call reset (do not reset members; already done by Init()) */
#ifndef __NORTTI
	if (bCallVirtual) return INVOKE_VIRTUAL_1(Reset,FALSE); else
#endif
	                  return O_K;
}

INT16 CProfile_Reset(CDlpObject* __this, BOOL bResetMembers)
{
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	DEBUGMSG(-1,"CProfile_Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	{
	/*{{CGEN_RESETCODE */
  return RESET;
	/*}}CGEN_RESETCODE */
	}

	return O_K;
}

INT16 CProfile_ClassProc(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	{
	/*{{CGEN_CLASSCODE */
  return CLASSPROC;
	/*}}CGEN_CLASSCODE */
	}

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CProfile_Serialize(CDlpObject* __this, CDN3Stream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
  return SAVE;
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CProfile_SerializeXml(CDlpObject* __this, CXmlStream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
  return SAVE;
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CProfile_Deserialize(CDlpObject* __this, CDN3Stream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
  return RESTORE;
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CProfile_DeserializeXml(CDlpObject* __this, CXmlStream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
  return RESTORE;
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CProfile_Copy(CDlpObject* __this, CDlpObject* __iSrc)
{
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	{
	/*{{CGEN_COPYCODE */
  return COPY;
	/*}}CGEN_COPYCODE */
	}

	return O_K;
}

/* Runtime class type information and class factory */
INT16 CProfile_InstallProc(void* lpItp)
{
	{
	/*{{CGEN_INSTALLCODE */
  return INSTALL;
	/*}}CGEN_INSTALLCODE */
	}

	return O_K;
}

CProfile* CProfile_CreateInstance(const char* lpName)
{
	CProfile* lpNewInstance;
	ICREATEEX(CProfile,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CProfile_GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOINSTANCE;

#ifdef __cplusplus

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CProfile::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CProfile::InstallProc;

#else /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CProfile_CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CProfile_InstallProc;

#endif /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpProject   = "profile";
	lpClassWord->ex.fct.lpBaseClass = "-";
	lpClassWord->lpComment          = "Profiler and debugging tools.";
	lpClassWord->ex.fct.lpAutoname  = "stdprof";
	lpClassWord->ex.fct.lpCname     = "CProfile";
	lpClassWord->ex.fct.lpAuthor    = "M. Eichner";

	dlp_strcpy(lpClassWord->lpName             ,"profile");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"1.1");

	return O_K;
}

INT16 CProfile_GetInstanceInfo(CDlpObject* __this, SWord* lpClassWord)
{
	return CProfile_GetClassInfo(lpClassWord);
}

BOOL CProfile_IsKindOf(CDlpObject* __this, const char* lpClassName)
{
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);

  if (dlp_strncmp(lpClassName,"profile",L_NAMES) == 0) return TRUE;
	else return INVOKE_BASEINST_1(IsKindOf,lpClassName);
}

INT16 CProfile_ResetAllOptions(CDlpObject* __this, BOOL bInit)
{
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	DEBUGMSG(-1,"CProfile_ResetAllOptions;",0,0,0);
	{
	/*{{CGEN_RESETALLOPTIONS*/
	/*}}CGEN_RESETALLOPTIONS*/
	}

	return INVOKE_BASEINST_1(ResetAllOptions,bInit);
}

/* Generated primary method invocation functions */

#ifndef __NOITP
/*{{CGEN_CPMIC */
INT16 CProfile_OnAssert(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	BOOL bCondition;
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	bCondition = MIC_GET_B(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CProfile_Assert(_this, bCondition);
	return __nErr;
}

INT16 CProfile_OnBeginTimer(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CProfile_BeginTimer(_this);
	return __nErr;
}

INT16 CProfile_OnBreakTimer(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CProfile_BreakTimer(_this);
	return __nErr;
}

INT16 CProfile_OnCheckHeap(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CProfile_CheckHeap(_this);
	return __nErr;
}

INT16 CProfile_OnContTimer(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CProfile_ContTimer(_this);
	return __nErr;
}

INT16 CProfile_OnDate(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CProfile_Date(_this);
	return __nErr;
}

INT16 CProfile_OnEndTimer(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	const char* sMsg;
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	sMsg = MIC_GET_S(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CProfile_EndTimer(_this, sMsg);
	return __nErr;
}

INT16 CProfile_OnResetTimer(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CProfile_ResetTimer(_this);
	return __nErr;
}

INT16 CProfile_OnShowTimer(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	const char* sMsg;
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	sMsg = MIC_GET_S(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CProfile_ShowTimer(_this, sMsg);
	return __nErr;
}

INT16 CProfile_OnTime(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CProfile_Time(_this);
	return __nErr;
}

INT16 CProfile_OnTstamp(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CProfile,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CProfile_Tstamp(_this);
	return __nErr;
}

/*}}CGEN_CPMIC */
#endif /* #ifndef __NOITP */


/* Generated secondary method invocation functions */

/*{{CGEN_CSMIC */
INT16 CProfile_Assert(CProfile* _this, BOOL bCondition)
{
    if (!bCondition) DLPASSERT(FMSG(dLabPro Script Assertion));
	return O_K;
}

INT16 CProfile_BeginTimer(CProfile* _this)
{
    CProfile_ResetTimer(_this);
    CProfile_ContTimer(_this);
	return O_K;
}

INT16 CProfile_BreakTimer(CProfile* _this)
{
    #if (defined __GNUC__ || defined _MSC_VER || defined __TMS)
      if (_this->m_nTime0>0) _this->m_nTime += (INT32)(clock()/(INT32)((FLOAT64)CLOCKS_PER_SEC/1000.))-_this->m_nTime0;
    #else
      MMTIME rNow; timeGetSystemTime(&rNow,sizeof(MMTIME));
      if (_this->m_nTime0>0) _this->m_nTime += rNow.u.ms-_this->m_nTime0;
    #endif
    _this->m_nTime0=0;
    _this->m_nCalls++;
	return O_K;
}

INT16 CProfile_CheckHeap(CProfile* _this)
{
    #if (defined __MSVC && defined _DEBUG)
      DLPASSERT(_CrtCheckMemory());
    #else
      return IERROR(_this,ERR_NOTSUPPORTED,"-check_heap",0,0);
    #endif
	return O_K;
}

INT16 CProfile_ContTimer(CProfile* _this)
{
    #if (defined __GNUC__ || defined _MSC_VER || defined __TMS)
    _this->m_nTime0 = (INT32)(clock()/(INT32)((FLOAT64)CLOCKS_PER_SEC/1000.));
    #else
      MMTIME rNow; timeGetSystemTime(&rNow,sizeof(MMTIME));
      _this->m_nTime0 = rNow.u.ms;
    #endif
	return O_K;
}

INT16 CProfile_Date(CProfile* _this)
{
    time_t     tNow;
    struct tm* lpNow;
    time(&tNow);
    lpNow = localtime(&tNow);
    strftime(_this->m_sTstamp,23,"%Y-%m-%d",lpNow);
    MIC_PUT_S(_this->m_sTstamp);
	return O_K;
}

INT16 CProfile_EndTimer(CProfile* _this, const char* sMsg)
{
    CProfile_BreakTimer(_this);
    if (dlp_strlen(sMsg)) CProfile_ShowTimer(_this,sMsg);
	return O_K;
}

INT16 CProfile_ResetTimer(CProfile* _this)
{
    CProfile_BreakTimer(_this);
    _this->m_nTime = 0;
    _this->m_nCalls = 0;
	return O_K;
}

INT16 CProfile_ShowTimer(CProfile* _this, const char* sMsg)
{
    char* lpsMsg = (char*)dlp_calloc(dlp_strlen(sMsg)+1,sizeof(char));
    dlp_strcpy(lpsMsg,sMsg);
    printf( "%s%lu ms",(unsigned long)dlp_strlen(lpsMsg)?dlp_strconvert(SC_UNESCAPE,lpsMsg,lpsMsg):"",_this->m_nTime);
    dlp_free(lpsMsg);
	return O_K;
}

INT16 CProfile_Time(CProfile* _this)
{
    time_t     tNow;
    struct tm* lpNow;
    time(&tNow);
    lpNow = localtime(&tNow);
    strftime(_this->m_sTstamp,23,"%H%M%S",lpNow);
    MIC_PUT_S(_this->m_sTstamp);
	return O_K;
}

INT16 CProfile_Tstamp(CProfile* _this)
{
    UINT64 nTime = dlp_time();
    sprintf(_this->m_sTstamp,"%015lX",(unsigned long)nTime);
    memmove(&_this->m_sTstamp[0],&_this->m_sTstamp[5],5);
    memmove(&_this->m_sTstamp[6],&_this->m_sTstamp[10],5);
    _this->m_sTstamp[5]='-';
    _this->m_sTstamp[11]='\0';
    MIC_PUT_S(_this->m_sTstamp);
	return O_K;
}

/*}}CGEN_CSMIC */


/* Generated option change callback functions */

/*{{CGEN_COCCF */
/*}}CGEN_COCCF */


/* Generated field change callback functions */

/*{{CGEN_CFCCF */
/*}}CGEN_CFCCF */


/* C++ wrapper functions */
#ifdef __cplusplus

#define _this this

CProfile::CProfile(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	CProfile_Constructor(this,lpInstanceName,bCallVirtual);
}

CProfile::~CProfile()
{
	CProfile_Destructor(this);
}

INT16 CProfile::AutoRegisterWords()
{
	return CProfile_AutoRegisterWords(this);
}

INT16 CProfile::Init(BOOL bCallVirtual)
{
	return CProfile_Init(this,bCallVirtual);
}

INT16 CProfile::Reset(BOOL bResetMembers)
{
	return CProfile_Reset(this,bResetMembers);
}

INT16 CProfile::ClassProc()
{
	return CProfile_ClassProc(this);
}

INT16 CProfile::Serialize(CDN3Stream* lpDest)
{
	return CProfile_Serialize(this,lpDest);
}

INT16 CProfile::SerializeXml(CXmlStream* lpDest)
{
	return CProfile_SerializeXml(this,lpDest);
}

INT16 CProfile::Deserialize(CDN3Stream* lpSrc)
{
	return CProfile_Deserialize(this,lpSrc);
}

INT16 CProfile::DeserializeXml(CXmlStream* lpSrc)
{
	return CProfile_DeserializeXml(this,lpSrc);
}

INT16 CProfile::Copy(CDlpObject* __iSrc)
{
	return CProfile_Copy(this,__iSrc);
}

INT16 CProfile::InstallProc(void* lpItp)
{
	return CProfile_InstallProc(lpItp);
}

CProfile* CProfile::CreateInstance(const char* lpName)
{
	return CProfile_CreateInstance(lpName);
}

INT16 CProfile::GetClassInfo(SWord* lpClassWord)
{
	return CProfile_GetClassInfo(lpClassWord);
}

INT16 CProfile::GetInstanceInfo(SWord* lpClassWord)
{
	return CProfile_GetInstanceInfo(this,lpClassWord);
}

BOOL CProfile::IsKindOf(const char* lpClassName)
{
	return CProfile_IsKindOf(this,lpClassName);
}

INT16 CProfile::ResetAllOptions(BOOL bInit)
{
	return CProfile_ResetAllOptions(this,bInit);
}

#ifndef __NOITP
/*{{CGEN_PMIC */
INT16 CProfile::OnAssert()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CProfile_OnAssert(this);
}

INT16 CProfile::OnBeginTimer()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CProfile_OnBeginTimer(this);
}

INT16 CProfile::OnBreakTimer()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CProfile_OnBreakTimer(this);
}

INT16 CProfile::OnCheckHeap()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CProfile_OnCheckHeap(this);
}

INT16 CProfile::OnContTimer()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CProfile_OnContTimer(this);
}

INT16 CProfile::OnDate()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CProfile_OnDate(this);
}

INT16 CProfile::OnEndTimer()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CProfile_OnEndTimer(this);
}

INT16 CProfile::OnResetTimer()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CProfile_OnResetTimer(this);
}

INT16 CProfile::OnShowTimer()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CProfile_OnShowTimer(this);
}

INT16 CProfile::OnTime()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CProfile_OnTime(this);
}

INT16 CProfile::OnTstamp()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CProfile_OnTstamp(this);
}

/*}}CGEN_PMIC */
#endif /* #ifndef __NOITP */

/*{{CGEN_SMIC */
INT16 CProfile::Assert(BOOL bCondition)
{
	return CProfile_Assert(this,bCondition);
}

INT16 CProfile::BeginTimer()
{
	return CProfile_BeginTimer(this);
}

INT16 CProfile::BreakTimer()
{
	return CProfile_BreakTimer(this);
}

INT16 CProfile::CheckHeap()
{
	return CProfile_CheckHeap(this);
}

INT16 CProfile::ContTimer()
{
	return CProfile_ContTimer(this);
}

INT16 CProfile::Date()
{
	return CProfile_Date(this);
}

INT16 CProfile::EndTimer(const char* sMsg)
{
	return CProfile_EndTimer(this,sMsg);
}

INT16 CProfile::ResetTimer()
{
	return CProfile_ResetTimer(this);
}

INT16 CProfile::ShowTimer(const char* sMsg)
{
	return CProfile_ShowTimer(this,sMsg);
}

INT16 CProfile::Time()
{
	return CProfile_Time(this);
}

INT16 CProfile::Tstamp()
{
	return CProfile_Tstamp(this);
}

/*}}CGEN_SMIC */

/*{{CGEN_OCCF */
/*}}CGEN_OCCF */

/*{{CGEN_FCCF */
/*}}CGEN_FCCF */

/*{{CGEN_CXXWRAP */
/*}}CGEN_CXXWRAP */

#endif /* #ifdef __cplusplus */

/* EOF */
