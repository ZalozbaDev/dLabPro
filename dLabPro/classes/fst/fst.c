/* dLabPro class CFst (fst)
 * - Finite state transducers
 *
 * AUTHOR : M. Wolff, M. Cuevas and M. Eichner
 * PACKAGE: dLabPro/classes
 *
 * This file was generated by dcg. DO NOT MODIFY! Modify fst.def instead.
 * 
 * Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
 * - Chair of System Theory and Speech Technology, TU Dresden
 * - Chair of Communications Engineering, BTU Cottbus
 * 
 * This file is part of dLabPro.
 * 
 * dLabPro is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 * 
 * dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with dLabPro. If not, see <http://www.gnu.org/licenses/>.
 */

#include "dlp_cscope.h" /* Indicate C scope */
/*{{CGEN_INCLUDE */
/*}}CGEN_END */
#include "dlp_fst.h"

/* Class CFst */

void CFst_Constructor(CFst* _this, const char* lpInstanceName, BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CFst_Constructor; (bCallVirtual=%d)",(int)bCallVirtual,0,0);

#ifndef __cplusplus

	/* Register instance */
	dlp_xalloc_register_object('J',_this,1,sizeof(CFst),
		__FILE__,__LINE__,"fst",lpInstanceName);

	/* Create base instance */
	_this->m_lpBaseInstance = calloc(1,sizeof(CDlpObject));
	CDlpObject_Constructor(_this->m_lpBaseInstance,lpInstanceName,FALSE);

	/* Override virtual member functions */
	_this->m_lpBaseInstance->AutoRegisterWords = CFst_AutoRegisterWords;
	_this->m_lpBaseInstance->Reset             = CFst_Reset;
	_this->m_lpBaseInstance->Init              = CFst_Init;
	_this->m_lpBaseInstance->Serialize         = CFst_Serialize;
	_this->m_lpBaseInstance->SerializeXml      = CFst_SerializeXml;
	_this->m_lpBaseInstance->Deserialize       = CFst_Deserialize;
	_this->m_lpBaseInstance->DeserializeXml    = CFst_DeserializeXml;
	_this->m_lpBaseInstance->Copy              = CFst_Copy;
	_this->m_lpBaseInstance->ClassProc         = CFst_ClassProc;
	_this->m_lpBaseInstance->GetInstanceInfo   = CFst_GetInstanceInfo;
	_this->m_lpBaseInstance->IsKindOf          = CFst_IsKindOf;
	_this->m_lpBaseInstance->Destructor        = CFst_Destructor;
	_this->m_lpBaseInstance->ResetAllOptions   = CFst_ResetAllOptions;

	/* Override pointer to derived instance */
	_this->m_lpBaseInstance->m_lpDerivedInstance = _this;

	#endif /* #ifndef __cplusplus */

	dlp_strcpy(BASEINST(_this)->m_lpClassName,"fst");
	dlp_strcpy(BASEINST(_this)->m_lpObsoleteName,"");
	dlp_strcpy(BASEINST(_this)->m_lpProjectName,"fst");
	dlp_strcpy(BASEINST(_this)->m_version.no,"1.0.1");
	dlp_strcpy(BASEINST(_this)->m_version.date,"");
	BASEINST(_this)->m_nClStyle = CS_AUTOACTIVATE;

	if (bCallVirtual)
	{
		DLPASSERT(OK(INVOKE_VIRTUAL_0(AutoRegisterWords)));
		INVOKE_VIRTUAL_1(Init,TRUE);
	}
}

void CFst_Destructor(CDlpObject* __this)
{
	GET_THIS_VIRTUAL(CFst);
	{
	/*{{CGEN_DONECODE */

  if (_this->m_idDetRt) { IDESTROY(_this->m_idDetRt); _this->m_idDetRt=NULL; }
  if (_this->m_lpDetSt) { CFst_Ssr_Done(_this->m_lpDetSt); _this->m_lpDetSt=NULL; }

  DONE;

	/*}}CGEN_DONECODE */
	}

#ifndef __cplusplus

	/* Destroy base instance */
	CDlpObject_Destructor(_this->m_lpBaseInstance);
	dlp_free(_this->m_lpBaseInstance);
	_this->m_lpBaseInstance = NULL;

#endif /* #ifndef __cplusplus */
}

INT16 CFst_AutoRegisterWords(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	DEBUGMSG(-1,"CFst_AutoRegisterWords",0,0,0);

	/* Call base class implementation */
	IF_NOK(INVOKE_BASEINST_0(AutoRegisterWords)) return NOT_EXEC;

	/*{{CGEN_REGISTERWORDS */

	/* Register methods */
	REGISTER_METHOD("-addseq","",LPMF(CFst,OnAddseq),"Adds a symbol sequence to an acceptor",0,"<data idSrc> <int nIcTis> <int nIcTer> <int nIcRci> <int nUnit> <fst this>","")
	REGISTER_METHOD("-addstates","",LPMF(CFst,OnAddstatesIam),"Adds new states",0,"<int nUnit> <int nCount> <fst this>","{ ... }")
	REGISTER_METHOD("-addtrans","",LPMF(CFst,OnAddtransIam),"Adds one transition",0,"<int nUnit> <int nIni> <int nTer> <fst this>","{ ... }")
	REGISTER_METHOD("-addunit","",LPMF(CFst,OnAddunitIam),"Adds one new unit",0,"<string sName> <fst this>","{ ... }")
	REGISTER_METHOD("-analyze","",LPMF(CFst,OnAnalyze),"Analyze automaton for specified properties",0,"<int nUnit> <int nMask> <fst this>","")
	REGISTER_METHOD("-analyze_multigram","",LPMF(CFst,OnAnalyzeMultigram),"Checks a multigram tree and counts the contained n-grams",0,"<data idCtrs> <int nUnit> <fst this>","")
	REGISTER_METHOD("-best_n","",LPMF(CFst,OnBestN),"Creates a tree with the best N paths taken from the source Fsm",0,"<fst itSrc> <int nUnit> <int nPaths> <int nPathlength> <fst this>","")
	REGISTER_METHOD("-cat","",LPMF(CFst,OnCat),"Concatenates automata",0,"<fst itSrc> <fst this>","")
	REGISTER_METHOD("-chain","",LPMF(CFst,OnChain),"Chains all states",0,"<int nUnit> <fst this>","{...}")
	REGISTER_METHOD("-close","",LPMF(CFst,OnClose),"Kleene closure",0,"<fst itSrc> <int nUnit> <fst this>","")
	REGISTER_METHOD("-compile","",LPMF(CFst,OnCompile),"Compiles strings into FSA/FST",0,"<data idSrc> <int nIcStr> <int nIcName> <data idAlp> <fst this>","")
	REGISTER_METHOD("-compose","",LPMF(CFst,OnCompose),"Composes weighted transducers",0,"<fst itSrc1> <fst itSrc2> <int nUnit1> <int nUnit2> <fst this>","")
	REGISTER_METHOD("-copy_ui","",LPMF(CFst,OnCopyUi),"Copies units according to a copying index.",0,"<fst itSrc> <data idIndex> <int nPar> <fst this>","")
	REGISTER_METHOD("-debug","",LPMF(CFst,OnDebug),"Debugging method, opcode ? displays a list of options",0,"<double nParam> <string sOp> <fst this>","")
	REGISTER_METHOD("-delstate","",LPMF(CFst,OnDelstate),"Deletes state <nState> from unit <nUnit>",0,"<int nUnit> <int nState> <fst this>","")
	REGISTER_METHOD("-deltrans","",LPMF(CFst,OnDeltrans),"Deletes transition <nTrans> from unit <nUnit>",0,"<int nUnit> <int nTrans> <fst this>","")
	REGISTER_METHOD("-delunit","",LPMF(CFst,OnDelunit),"Deletes unit <nUnit>",0,"<int nUnit> <fst this>","")
	REGISTER_METHOD("-determinize","",LPMF(CFst,OnDeterminize),"Determinizes a (weighted) acceptor or transducer",0,"<fst itSrc> <int nUnit> <fst this>","")
	REGISTER_METHOD("-discount","",LPMF(CFst,OnDiscount),"Discounts transitions by nDiscount and removes open paths.",0,"<int nDiscount> <int nUnit> <fst this>","")
	REGISTER_METHOD("-epsdist","",LPMF(CFst,OnEpsdist),"Computes the epsilon distance between any two states",0,"<fst itSrc> <int nUnit> <fst this>","")
	REGISTER_METHOD("-epsremove","",LPMF(CFst,OnEpsremove),"Removes epsilon transitions from automata",0,"<fst itSrc> <int nUnit> <fst this>","")
	REGISTER_METHOD("-excerpt","",LPMF(CFst,OnExcerpt),"Extracts partial automata containing specified states.",0,"<fst itSrc> <int nUnit> <data idStates> <int nIcSates> <data idIs> <int nParam> <fst this>","")
	REGISTER_METHOD("-fslist","",LPMF(CFst,OnFslist),"Lists final states",0,"<int nUnit> <data idDst> <fst this>","")
	REGISTER_METHOD("-fsunify","",LPMF(CFst,OnFsunify),"Unifies final states",0,"<int nUnit> <fst this>","")
	REGISTER_METHOD("-get_type","",LPMF(CFst,OnGetType),"Determines the automaton type",0,"<int nMask> <fst this>","")
	REGISTER_METHOD("-hmm","",LPMF(CFst,OnHmm),"Convert to HMM-style (weighted) acceptor or transducer",0,"<fst itSrc> <int nUnit> <fst this>","")
	REGISTER_METHOD("-intersect","",LPMF(CFst,OnIntersect),"Calculates the intersection of weighted automata",0,"<fst itSrc1> <fst itSrc2> <int nUnit1> <int nUnit2> <fst this>","")
	REGISTER_METHOD("-invert","",LPMF(CFst,OnInvert),"Swap input and output symbols",0,"<int nUnit> <fst this>","")
	REGISTER_METHOD("-loops","",LPMF(CFst,OnLoops),"Add self loops to all states",0,"<int nUnit> <fst this>","{...}")
	REGISTER_METHOD("-minimize","",LPMF(CFst,OnMinimize),"Minimizes a (weighted) acceptor or transducer",0,"<fst itSrc> <int nUnit> <fst this>","")
	REGISTER_METHOD("-multigram","",LPMF(CFst,OnMultigram),"Creates a weighted segment acceptor for a symbol sequence from a multigram tree",0,"<data idSeq> <int nComp> <data idWeights> <fst itDst> <int nUnit> <fst this>","")
	REGISTER_METHOD("-order","",LPMF(CFst,OnOrder),"Orders the automaton (topologically)",0,"<fst itSrc> <data idMap> <int nComp> <int nUnit> <fst this>","")
	REGISTER_METHOD("-potential","",LPMF(CFst,OnPotential),"Computes the minimal distance from each state to the final state",0,"<int nUnit> <fst this>","")
	REGISTER_METHOD("-print","",LPMF(CFst,OnPrint),"Prints automaton data content at stdout",0,"<fst this>","")
	REGISTER_METHOD("-probs","",LPMF(CFst,OnProbs),"(Re-)Estimates transition probabilities",0,"<int nUnit> <fst this>","")
	REGISTER_METHOD("-product","",LPMF(CFst,OnProduct),"Calculates the cartesian product of two graphs",0,"<fst itSrc1> <fst itSrc2> <int nUnit1> <int nUnit2> <fst this>","")
	REGISTER_METHOD("-project","",LPMF(CFst,OnProject),"Remove output symbols",0,"<fst this>","")
	REGISTER_METHOD("-push_weights","",LPMF(CFst,OnPushWeights),"Pushes weights towards initial states",0,"<fst itSrc> <int nUnit> <fst this>","")
	REGISTER_METHOD("-rank","",LPMF(CFst,OnRank),"Determines the rank of all states.",0,"<int nUnit> <data idDst> <fst this>","")
	REGISTER_METHOD("-rcs","",LPMF(CFst,OnRcs),"Calculates reference counters from transition probabilities",0,"<int nUnit> <double nSeed> <fst this>","")
	REGISTER_METHOD("-regex_compile","",LPMF(CFst,OnRegexCompile),"Generate a regular expression fst",0,"<string sRgx> <fst this>","")
	REGISTER_METHOD("-regex_match","",LPMF(CFst,OnRegexMatch),"Match a string against a regular expression fst",0,"<string sStr> <fst this>","")
	REGISTER_METHOD("-reverse","",LPMF(CFst,OnReverse),"Reverses a (weighted) automaton",0,"<int nUnit> <fst this>","")
	REGISTER_METHOD("-rndwalk","",LPMF(CFst,OnRndwalk),"Extracts random paths from the source unit.",0,"<fst itSrc> <int nUnit> <int nPaths> <double nWInfluence> <fst this>","")
	REGISTER_METHOD("-sdp","",LPMF(CFst,OnSdp),"Synchroneous dynamic programming",0,"<fst itSrc> <int nUnit> <data idWeights> <fst this>","")
	REGISTER_METHOD("-status","-descr",LPMF(CFst,OnStatus),"Prints status information of the FST instance.",0,"<fst this>","")
	REGISTER_METHOD("-stp","",LPMF(CFst,OnStp),"find best n paths via tokenpassing",0,"<fst itSrc> <int nUnit> <int nPaths> <data idWeights> <fst this>","")
	REGISTER_METHOD("-tree","",LPMF(CFst,OnTree),"Expands automaton graphs into trees",0,"<fst itSrc> <int nUnit> <fst this>","")
	REGISTER_METHOD("-trim","",LPMF(CFst,OnTrim),"Removes heavy weighted transitions and unconnected states",0,"<int nUnit> <double nWlim> <fst this>","")
	REGISTER_METHOD("-typerepair","",LPMF(CFst,OnTyperepair),"Converts the typs of all data instances inside the fst into dlabpro compile settings",0,"<fst this>","")
	REGISTER_METHOD("-union","",LPMF(CFst,OnUnion),"Union",0,"<fst iSrc> <fst this>","")
	REGISTER_METHOD("-unweight","",LPMF(CFst,OnUnweight),"Remove transition weights",0,"<fst this>","")
	REGISTER_METHOD("-wire","",LPMF(CFst,OnWire),"Connects units using a wiring table / bigram",0,"<fst iSrc> <data idBigram> <fst this>","{ ... }")
	REGISTER_METHOD("-wsr_convert","",LPMF(CFst,OnCFst_WsrConvert_Iam),"Converts the weights to another semiring",0,"<fst this>","")
	REGISTER_METHOD("-x1","",LPMF(CFst,OnX1),"EXPERIMENTAL - DO NOT USE!",0,"<fst itSrc> <int nUnit> <fst this>","")
	REGISTER_METHOD("-x2","",LPMF(CFst,OnX2),"EXPERIMENTAL - DO NOT USE!",0,"<int nUnit> <fst this>","")

	/* Register options */
	REGISTER_OPTION("/backward","",LPMV(m_bBackward),NULL,"Process backward (right to left).",0)
	REGISTER_OPTION("/climit","",LPMV(m_bClimit),NULL,"Limits passes through cycles",0)
	REGISTER_OPTION("/different_is","",LPMV(m_bDifferentIs),NULL,"Output only paths with different input symbols",0)
	REGISTER_OPTION("/different_os","",LPMV(m_bDifferentOs),NULL,"Output only paths with different output symbols",0)
	REGISTER_OPTION("/epsremove","",LPMV(m_bEpsremove),NULL,"Removes epsilon transitions",0)
	REGISTER_OPTION("/final","",LPMV(m_bFinal),NULL,"Make final state(s).",0)
	REGISTER_OPTION("/forward","",LPMV(m_bForward),NULL,"Process forward (left to right).",0)
	REGISTER_OPTION("/fsa","",LPMV(m_bFsa),NULL,"Acceptor",0)
	REGISTER_OPTION("/fst","",LPMV(m_bFst),NULL,"Transducer",0)
	REGISTER_OPTION("/fwd","",LPMV(m_bFwd),NULL,"Do forward algorithm instead of sdp",0)
	REGISTER_OPTION("/greedy","/lmatch",LPMV(m_bGreedy),NULL,"Greedy match (use longest matching sequence).",0)
	REGISTER_OPTION("/implicit","",LPMV(m_bImplicit),NULL,"Wire units implicitely",0)
	REGISTER_OPTION("/index","",LPMV(m_bIndex),NULL,"Append or use index",0)
	REGISTER_OPTION("/lazy","",LPMV(m_bLazy),NULL,"Lazy minimization",0)
	REGISTER_OPTION("/local","",LPMV(m_bLocal),NULL,"Local (instead of global) operation",0)
	REGISTER_OPTION("/lsr","",LPMV(m_bLsr),NULL,"Weighted (logarithmic semiring)",0)
	REGISTER_OPTION("/markx","",LPMV(m_bMarkx),NULL,"Mark composition result in left operator",0)
	REGISTER_OPTION("/marky","",LPMV(m_bMarky),NULL,"Mark composition result in right operator",0)
	REGISTER_OPTION("/multigram","",LPMV(m_bMultigram),NULL,"Multigram mode (instead of sequence mode)",0)
	REGISTER_OPTION("/noeps","",LPMV(m_bNoeps),NULL,"Epsilon loops must be explicitly given for -compose",0)
	REGISTER_OPTION("/noint","",LPMV(m_bNoint),NULL,"Discard intermediate symbols",0)
	REGISTER_OPTION("/noloops","",LPMV(m_bNoloops),NULL,"Disregard trivial cycles (self loops)",0)
	REGISTER_OPTION("/prune","",LPMV(m_bPrune),NULL,"Constant pruning",0)
	REGISTER_OPTION("/psr","",LPMV(m_bPsr),NULL,"Weighted (probability semiring)",0)
	REGISTER_OPTION("/push","",LPMV(m_bPush),NULL,"Push weights/output symbols towards final states (instead of leave them)",0)
	REGISTER_OPTION("/segment","",LPMV(m_bSegment),NULL,"Segmentation mode (instead of sequence mode)",0)
	REGISTER_OPTION("/trans","",LPMV(m_bTrans),NULL,"Use transitions (instead of states)",0)
	REGISTER_OPTION("/tsr","",LPMV(m_bTsr),NULL,"Weighted (tropical semiring)",0)
	REGISTER_OPTION("/usemap","",LPMV(m_bUsemap),NULL,"Use MAP approximation",0)

	/* Register fields */
	REGISTER_FIELD("climit","",LPMV(m_nClimit),NULL,"Limit of cycle passes when traversing graphs",0,2004,1,"int",(INT32)1)
	REGISTER_FIELD("cps_hash","",LPMV(m_lpCpsHash),NULL,"Composition: Composed state hash map",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6000,1,"void*",NULL)
	REGISTER_FIELD("cps_hnpool","",LPMV(m_lpCpsHnpool),NULL,"Composition: Hash node pool table",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6000,1,"void**",NULL)
	REGISTER_FIELD("cps_hnpool_size","",LPMV(m_nCpsHnpoolSize),NULL,"Composition: Hash node pool size",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,2004,1,"int",(INT32)0)
	REGISTER_FIELD("cps_keybuf","",LPMV(m_lpCpsKeybuf),NULL,"Composition: Temporary hash key buffer",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,10000,3,"FST_ITYPE",0)
	REGISTER_FIELD("det_rt","",LPMV(m_idDetRt),NULL,"Determinization: Residual table",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6002,1,"data",NULL)
	REGISTER_FIELD("det_st","",LPMV(m_lpDetSt),NULL,"Determinization: String table",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6000,1,"FST_SST_TYPE*",NULL)
	REGISTER_FIELD("ftol","",LPMV(m_nFtol),NULL,"Tolerance of floating point comparison",0,3008,1,"double",(FLOAT64)1E-10)
	REGISTER_FIELD("fts","",LPMV(m_lpFts),NULL,"Internal use: Transition sorting index",FF_HIDDEN | FF_NOSET | FF_NOSAVE,6000,1,"FST_ITYPE*",NULL)
	REGISTER_FIELD("grany","",LPMV(m_nGrany),NULL,"Granularity of data table (re)allocations",0,2004,1,"int",(INT32)1000)
	REGISTER_FIELD("gw","",LPMV(m_nGw),NULL,"Global path weight (-sdp)",0,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("ic_sd_aux","",LPMV(m_nIcSdAux),NULL,"Internal use: First component of auxilary state data",FF_HIDDEN | FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)-1L)
	REGISTER_FIELD("IC_SD_DATA","",LPMV(m_nICSDDATA),NULL,"First component of <sd> containing additional data",FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)IC_SD_DATA)
	REGISTER_FIELD("IC_SD_FLAG","",LPMV(m_nICSDFLAG),NULL,"Component of <sd> containing final state flag",FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)IC_SD_FLAG)
	REGISTER_FIELD("ic_td_aux","",LPMV(m_nIcTdAux),NULL,"Internal use: First component of auxilary transition data",FF_HIDDEN | FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)-1L)
	REGISTER_FIELD("IC_TD_DATA","",LPMV(m_nICTDDATA),NULL,"First component of <td> containing additional data",FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)IC_TD_DATA)
	REGISTER_FIELD("IC_TD_INI","",LPMV(m_nICTDINI),NULL,"Component of <td> containing initial state of transition",FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)IC_TD_INI)
	REGISTER_FIELD("IC_TD_TER","",LPMV(m_nICTDTER),NULL,"Component of <td> containing terminal state of transition",FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)IC_TD_TER)
	REGISTER_FIELD("ic_tis","",LPMV(m_nIcTis),NULL,"Internal use: Input symbol component of td",FF_HIDDEN | FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)-1L)
	REGISTER_FIELD("ic_tos","",LPMV(m_nIcTos),NULL,"Internal use: Output symbol component of td",FF_HIDDEN | FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)-1L)
	REGISTER_FIELD("IC_UD_DATA","",LPMV(m_nICUDDATA),NULL,"First component of <ud> containing additional data",FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)IC_UD_DATA)
	REGISTER_FIELD("IC_UD_FS","",LPMV(m_nICUDFS),NULL,"Component of <ud> containing index of first state of unit",FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)IC_UD_FS)
	REGISTER_FIELD("IC_UD_FT","",LPMV(m_nICUDFT),NULL,"Component of <ud> containing index of first transition of unit",FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)IC_UD_FT)
	REGISTER_FIELD("IC_UD_NAME","",LPMV(m_nICUDNAME),NULL,"Component of <ud> containing unit names",FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)IC_UD_NAME)
	REGISTER_FIELD("IC_UD_XS","",LPMV(m_nICUDXS),NULL,"Component of <ud> containing state count of unit",FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)IC_UD_XS)
	REGISTER_FIELD("IC_UD_XT","",LPMV(m_nICUDXT),NULL,"Component of <ud> containing transition count of unit",FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)IC_UD_XT)
	REGISTER_FIELD("ic_w","",LPMV(m_nIcW),NULL,"Internal use: Weight component of td",FF_HIDDEN | FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)-1L)
	REGISTER_FIELD("is","",LPMV(is),NULL,"Input symbol table",0,6002,1,"data",NULL)
	REGISTER_FIELD("mapexp","",LPMV(m_nMapexp),NULL,"Exponent for MAP transition probability smoothing",0,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("max_len","",LPMV(m_nMaxLen),NULL,"Maximal path length when traversing graphs or building multigrams",0,2004,1,"int",(INT32)1000000)
	REGISTER_FIELD("NC_SD_POT","",LPMV(m_lpsNCSDPOT),NULL,"Component of <sd> containing state potential",FF_NOSET | FF_NOSAVE,5,5,"char[5]","~POT")
	REGISTER_FIELD("NC_SD_RC","",LPMV(m_lpsNCSDRC),NULL,"Component of <sd> containing state reference counter",FF_NOSET | FF_NOSAVE,5,5,"char[5]","~RC")
	REGISTER_FIELD("NC_SD_RNK","",LPMV(m_lpsNCSDRNK),NULL,"Component of <sd> containing state rank (topological order)",FF_NOSET | FF_NOSAVE,5,5,"char[5]","~RNK")
	REGISTER_FIELD("NC_TD_LSR","",LPMV(m_lpsNCTDLSR),NULL,"Component of <td> containing negative log. trans. prob. (log semiring)",FF_NOSET | FF_NOSAVE,5,5,"char[5]","~LSR")
	REGISTER_FIELD("NC_TD_PSR","",LPMV(m_lpsNCTDPSR),NULL,"Component of <td> containing transition probability (prob. semiring)",FF_NOSET | FF_NOSAVE,5,5,"char[5]","~PSR")
	REGISTER_FIELD("NC_TD_RC","",LPMV(m_lpsNCTDRC),NULL,"Component of <td> containing transition reference counter",FF_NOSET | FF_NOSAVE,5,5,"char[5]","~RC")
	REGISTER_FIELD("NC_TD_TIS","",LPMV(m_lpsNCTDTIS),NULL,"Component of <sd> containing transducer input symbol",FF_NOSET | FF_NOSAVE,5,5,"char[5]","~TIS")
	REGISTER_FIELD("NC_TD_TOS","",LPMV(m_lpsNCTDTOS),NULL,"Component of <sd> containing transducer output symbol",FF_NOSET | FF_NOSAVE,5,5,"char[5]","~TOS")
	REGISTER_FIELD("NC_TD_TSR","",LPMV(m_lpsNCTDTSR),NULL,"Component of <td> containing transition weight (tropical semiring)",FF_NOSET | FF_NOSAVE,5,5,"char[5]","~TSR")
	REGISTER_FIELD("nmg_t","",LPMV(m_lpNmgT),NULL,"Multigram calculations: Transition sequence buffer",FF_HIDDEN | FF_NOSET | FF_NOSAVE,6000,1,"FST_ITYPE*",NULL)
	REGISTER_FIELD("nmg_w","",LPMV(m_lpNmgW),NULL,"Multigram calculations: Interpolation weigth buffer",FF_HIDDEN | FF_NOSET | FF_NOSAVE,6000,1,"FST_WTYPE*",NULL)
	REGISTER_FIELD("os","",LPMV(os),NULL,"Output symbol table",0,6002,1,"data",NULL)
	REGISTER_FIELD("printstop","",LPMV(m_nPrintstop),NULL,"Internal use: Break listings in verbose mode",FF_HIDDEN | FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)0)
	REGISTER_FIELD("prn_const","",LPMV(m_nPrnConst),NULL,"Pruning constant",0,3008,1,"double",(FLOAT64)0.15)
	REGISTER_FIELD("rcfloor","",LPMV(m_nRcfloor),NULL,"Reference counter floor for Jeffrey smoothing of deterministic acceptors",0,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("sd","",LPMV(sd),NULL,"State description table",0,6002,1,"data",NULL)
	REGISTER_FIELD("symbols","",LPMV(m_nSymbols),NULL,"Number of symbols in input alphabet",0,2004,1,"int",(INT32)-1L)
	REGISTER_FIELD("td","",LPMV(td),NULL,"Transition description table",0,6002,1,"data",NULL)
	REGISTER_FIELD("ud","",LPMV(ud),NULL,"Unit description table",0,6002,1,"data",NULL)
	REGISTER_FIELD("wceil","",LPMV(m_nWceil),NULL,"Maximal log. or tropical weight; minimal probability is exp(-wceil)",0,3008,1,"double",(FLOAT64)T_DOUBLE_MAX)
	REGISTER_FIELD("WLRs","",LPMV(m_nWLRs),NULL,"Internal use: keep track of memory used by WLRs (to be deleted after finishing -stp) (Thomas Hutschenreuther)",FF_HIDDEN,2004,1,"int",(INT32)0)
	REGISTER_FIELD("wsr","",LPMV(m_nWsr),NULL,"Internal use: Weight semiring type",FF_HIDDEN | FF_NOSET | FF_NOSAVE,2002,1,"short",(INT16)-1)
	REGISTER_FIELD("x_fts","",LPMV(m_nXFts),NULL,"Internal use: Transition sorting index size",FF_HIDDEN | FF_NOSET | FF_NOSAVE,2004,1,"int",(INT32)0)

	/* Register errors */
	REGISTER_ERROR("~e1_0_0__1",EL_ERROR,FST_INTERNAL,"Internal error at %s(%ld)")
	REGISTER_ERROR("~e2_0_0__1",EL_ERROR,FST_BADID,"Invalid %s index %ld")
	REGISTER_ERROR("~e3_0_0__1",EL_WARNING2,FST_BADID2,"Invalid %s index %ld")
	REGISTER_ERROR("~e4_0_0__1",EL_ERROR,FST_BADCTYPE,"Invalid type of %s table component %ld")
	REGISTER_ERROR("~e5_0_0__1",EL_ERROR,FST_MISS,"Missing %s %s in %s")
	REGISTER_ERROR("~e6_0_0__1",EL_ERROR,FST_BIGRAM,"Data instance '%s' is not a valid %s bigram. See manual of '-wire'")
	REGISTER_ERROR("~e7_0_0__1",EL_WARNING,FST_EMPTY,"%s is empty.")
	REGISTER_ERROR("~e8_0_0__1",EL_WARNING,FST_UNITEMPTY,"Unit %ld is empty")
	REGISTER_ERROR("~e9_0_0__1",EL_WARNING,FST_PATHTOOLONG,"Path too long %s unit %ld")
	REGISTER_ERROR("~e0_1_0__1",EL_ERROR,FST_PATHNOTUNIQUE,"Path not unique in unit %ld at state %ld (%s traversal)")
	REGISTER_ERROR("~e1_1_0__1",EL_ERROR,FST_PATHBROKEN,"Broken path in unit %ld at state %ld (%s traversal)")
	REGISTER_ERROR("~e2_1_0__1",EL_ERROR,FST_BADTYPE,"fst instance is not %s.")
	REGISTER_ERROR("~e3_1_0__1",EL_ERROR,FST_INCOMPATIBLE,"Incompatibe %s in %s.")
	REGISTER_ERROR("~e4_1_0__1",EL_ERROR,FST_SYMBOLNOTFOUND,"Symbol '%s' not found.")
	REGISTER_ERROR("~e5_1_0__1",EL_WARNING,FST_NOSDPW,"No synchroneous weights for %s %ld.")
	REGISTER_ERROR("~e6_1_0__1",EL_WARNING,FST_DELETE,"Deleting %s %s from %s.")
	REGISTER_ERROR("~e7_1_0__1",EL_WARNING,FST_CHANGE,"Changing %s to %s.")
	REGISTER_ERROR("~e8_1_0__1",EL_ERROR,FST_UNWEIGHTED,"Automaton is unweighted.")
	REGISTER_ERROR("~e9_1_0__1",EL_ERROR,FST_INVALID,"Invalid %s.")
	REGISTER_ERROR("~e0_2_0__1",EL_ERROR,FST_EPSINWORD,"Internal epsilon transition in phoneme model.")
	REGISTER_ERROR("~e1_2_0__1",EL_WARNING,FST_INTERNALW,"%s at %s(%ld).")
	REGISTER_ERROR("~e2_2_0__1",EL_ERROR,FST_SYMBOLCRASH,"Symbol crash.")
	REGISTER_ERROR("~e3_2_0__1",EL_ERROR,FST_NOSYMBOL,"Final state reached without collecting output symbol.")
	/*}}CGEN_REGISTERWORDS */

	return O_K;
}

INT16 CFst_Init(CDlpObject* __this, BOOL bCallVirtual)
{
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	DEBUGMSG(-1,"CFst_Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	{
	/*{{CGEN_INITCODE */
  INIT;
	/*}}CGEN_INITCODE */
	}

	/* If last derivation call reset (do not reset members; already done by Init()) */
#ifndef __NORTTI
	if (bCallVirtual) return INVOKE_VIRTUAL_1(Reset,FALSE); else
#endif
	                  return O_K;
}

INT16 CFst_Reset(CDlpObject* __this, BOOL bResetMembers)
{
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	DEBUGMSG(-1,"CFst_Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	{
	/*{{CGEN_RESETCODE */

#ifndef __NORTTI
  RESET;

  IFIELD_RESET(CData,"ud");
  IFIELD_RESET(CData,"sd");
  IFIELD_RESET(CData,"td");
  IFIELD_RESET(CData,"is");
  IFIELD_RESET(CData,"os");
#else
  CDlpTable_Reset(AS(CData,_this->ud)->m_lpTable);
  CDlpTable_Reset(AS(CData,_this->td)->m_lpTable);
  CDlpTable_Reset(AS(CData,_this->sd)->m_lpTable);
  CDlpTable_Reset(AS(CData,_this->is)->m_lpTable);
  CDlpTable_Reset(AS(CData,_this->os)->m_lpTable);
#endif

  CData_AddComp(AS(CData,_this->ud),"~NAM",32                 );
  CData_AddComp(AS(CData,_this->ud),"~XS" ,DLP_TYPE(FST_ITYPE));
  CData_AddComp(AS(CData,_this->ud),"~XT" ,DLP_TYPE(FST_ITYPE));
  CData_AddComp(AS(CData,_this->ud),"~FS" ,DLP_TYPE(FST_ITYPE));
  CData_AddComp(AS(CData,_this->ud),"~FT" ,DLP_TYPE(FST_ITYPE));
  CData_AddComp(AS(CData,_this->sd),"~FLG",T_BYTE             );
  CData_AddComp(AS(CData,_this->td),"~TER",DLP_TYPE(FST_ITYPE));
  CData_AddComp(AS(CData,_this->td),"~INI",DLP_TYPE(FST_ITYPE));

  if (_this->m_idDetRt) CData_Reset(_this->m_idDetRt,TRUE);
  if (_this->m_lpDetSt) { CFst_Ssr_Done(_this->m_lpDetSt); _this->m_lpDetSt=CFst_Ssr_Init(_this->m_nGrany); }

	/*}}CGEN_RESETCODE */
	}

	return O_K;
}

INT16 CFst_ClassProc(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	{
	/*{{CGEN_CLASSCODE */
  return CLASSPROC;
	/*}}CGEN_CLASSCODE */
	}

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CFst_Serialize(CDlpObject* __this, CDN3Stream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
  return SAVE;
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CFst_SerializeXml(CDlpObject* __this, CXmlStream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
  return SAVE;
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CFst_Deserialize(CDlpObject* __this, CDN3Stream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
  RESTORE;
  CFst_Typerepair(_this);
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CFst_DeserializeXml(CDlpObject* __this, CXmlStream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
  RESTORE;
  CFst_Typerepair(_this);
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CFst_Copy(CDlpObject* __this, CDlpObject* __iSrc)
{
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	{
	/*{{CGEN_COPYCODE */
  return COPY;
	/*}}CGEN_COPYCODE */
	}

	return O_K;
}

/* Runtime class type information and class factory */
INT16 CFst_InstallProc(void* lpItp)
{
	{
	/*{{CGEN_INSTALLCODE */
  return INSTALL;
	/*}}CGEN_INSTALLCODE */
	}

	return O_K;
}

CFst* CFst_CreateInstance(const char* lpName)
{
	CFst* lpNewInstance;
	ICREATEEX(CFst,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CFst_GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOACTIVATE;

#ifdef __cplusplus

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CFst::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CFst::InstallProc;

#else /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CFst_CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CFst_InstallProc;

#endif /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpProject   = "fst";
	lpClassWord->ex.fct.lpBaseClass = "-";
	lpClassWord->lpComment          = "Finite state transducers";
	lpClassWord->ex.fct.lpAutoname  = "";
	lpClassWord->ex.fct.lpCname     = "CFst";
	lpClassWord->ex.fct.lpAuthor    = "M. Wolff, M. Cuevas and M. Eichner";

	dlp_strcpy(lpClassWord->lpName             ,"fst");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"1.0.1");

	return O_K;
}

INT16 CFst_GetInstanceInfo(CDlpObject* __this, SWord* lpClassWord)
{
	return CFst_GetClassInfo(lpClassWord);
}

BOOL CFst_IsKindOf(CDlpObject* __this, const char* lpClassName)
{
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);

  if (dlp_strncmp(lpClassName,"fst",L_NAMES) == 0) return TRUE;
	else return INVOKE_BASEINST_1(IsKindOf,lpClassName);
}

INT16 CFst_ResetAllOptions(CDlpObject* __this, BOOL bInit)
{
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	DEBUGMSG(-1,"CFst_ResetAllOptions;",0,0,0);
	{
	/*{{CGEN_RESETALLOPTIONS*/
	_this->m_bBackward = FALSE;
	_this->m_bClimit = FALSE;
	_this->m_bDifferentIs = FALSE;
	_this->m_bDifferentOs = FALSE;
	_this->m_bEpsremove = FALSE;
	_this->m_bFinal = FALSE;
	_this->m_bForward = FALSE;
	_this->m_bFsa = FALSE;
	_this->m_bFst = FALSE;
	_this->m_bFwd = FALSE;
	_this->m_bGreedy = FALSE;
	_this->m_bImplicit = FALSE;
	_this->m_bIndex = FALSE;
	_this->m_bLazy = FALSE;
	_this->m_bLocal = FALSE;
	_this->m_bLsr = FALSE;
	_this->m_bMarkx = FALSE;
	_this->m_bMarky = FALSE;
	_this->m_bMultigram = FALSE;
	_this->m_bNoeps = FALSE;
	_this->m_bNoint = FALSE;
	_this->m_bNoloops = FALSE;
	_this->m_bPrune = FALSE;
	_this->m_bPsr = FALSE;
	_this->m_bPush = FALSE;
	_this->m_bSegment = FALSE;
	_this->m_bTrans = FALSE;
	_this->m_bTsr = FALSE;
	_this->m_bUsemap = FALSE;
	/*}}CGEN_RESETALLOPTIONS*/
	}

	return INVOKE_BASEINST_1(ResetAllOptions,bInit);
}

/* Generated primary method invocation functions */

#ifndef __NOITP
/*{{CGEN_CPMIC */
INT16 CFst_OnAddseq(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	INT32 nIcTis;
	INT32 nIcTer;
	INT32 nIcRci;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	nIcRci = (INT32)MIC_GET_N(2,1);
	nIcTer = (INT32)MIC_GET_N(3,2);
	nIcTis = (INT32)MIC_GET_N(4,3);
	idSrc = MIC_GET_I_EX(idSrc,data,5,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_N(CFst_Addseq(_this, idSrc, nIcTis, nIcTer, nIcRci, nUnit));
	return __nErr;
}

INT16 CFst_OnAddstatesIam(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	INT32 nCount;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nCount = (INT32)MIC_GET_N(1,0);
	nUnit = (INT32)MIC_GET_N(2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_AddstatesIam(_this, nUnit, nCount);
	return __nErr;
}

INT16 CFst_OnAddtransIam(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	INT32 nIni;
	INT32 nTer;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nTer = (INT32)MIC_GET_N(1,0);
	nIni = (INT32)MIC_GET_N(2,1);
	nUnit = (INT32)MIC_GET_N(3,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_AddtransIam(_this, nUnit, nIni, nTer);
	return __nErr;
}

INT16 CFst_OnAddunitIam(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	char* sName;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	sName = MIC_GET_S(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_AddunitIam(_this, sName);
	return __nErr;
}

INT16 CFst_OnAnalyze(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	INT32 nMask;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nMask = (INT32)MIC_GET_N(1,0);
	nUnit = (INT32)MIC_GET_N(2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_N(CFst_Analyze(_this, nUnit, nMask));
	return __nErr;
}

INT16 CFst_OnAnalyzeMultigram(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idCtrs;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	idCtrs = MIC_GET_I_EX(idCtrs,data,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_AnalyzeMultigram(_this, idCtrs, nUnit);
	return __nErr;
}

INT16 CFst_OnBestN(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT32 nUnit;
	INT32 nPaths;
	INT32 nPathlength;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nPathlength = (INT32)MIC_GET_N(1,0);
	nPaths = (INT32)MIC_GET_N(2,1);
	nUnit = (INT32)MIC_GET_N(3,2);
	itSrc = MIC_GET_I_EX(itSrc,fst,4,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_BestN(_this, itSrc, nUnit, nPaths, nPathlength);
	return __nErr;
}

INT16 CFst_OnCat(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itSrc = MIC_GET_I_EX(itSrc,fst,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Cat(_this, itSrc);
	return __nErr;
}

INT16 CFst_OnChain(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Chain(_this, nUnit);
	return __nErr;
}

INT16 CFst_OnClose(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	itSrc = MIC_GET_I_EX(itSrc,fst,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Close(_this, itSrc, nUnit);
	return __nErr;
}

INT16 CFst_OnCompile(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSrc;
	INT32 nIcStr;
	INT32 nIcName;
	data* idAlp;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idAlp = MIC_GET_I_EX(idAlp,data,1,1);
	nIcName = (INT32)MIC_GET_N(2,0);
	nIcStr = (INT32)MIC_GET_N(3,1);
	idSrc = MIC_GET_I_EX(idSrc,data,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Compile(_this, idSrc, nIcStr, nIcName, idAlp);
	return __nErr;
}

INT16 CFst_OnCompose(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc1;
	fst* itSrc2;
	INT32 nUnit1;
	INT32 nUnit2;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit2 = (INT32)MIC_GET_N(1,0);
	nUnit1 = (INT32)MIC_GET_N(2,1);
	itSrc2 = MIC_GET_I_EX(itSrc2,fst,3,1);
	itSrc1 = MIC_GET_I_EX(itSrc1,fst,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Compose(_this, itSrc1, itSrc2, nUnit1, nUnit2);
	return __nErr;
}

INT16 CFst_OnCopyUi(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	data* idIndex;
	INT32 nPar;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nPar = (INT32)MIC_GET_N(1,0);
	idIndex = MIC_GET_I_EX(idIndex,data,2,1);
	itSrc = MIC_GET_I_EX(itSrc,fst,3,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_CopyUi(_this, itSrc, idIndex, nPar);
	return __nErr;
}

INT16 CFst_OnDebug(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	FLOAT64 nParam;
	char* sOp;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	sOp = MIC_GET_S(1,0);
	nParam = MIC_GET_N(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Debug(_this, nParam, sOp);
	return __nErr;
}

INT16 CFst_OnDelstate(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	INT32 nState;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nState = (INT32)MIC_GET_N(1,0);
	nUnit = (INT32)MIC_GET_N(2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Delstate(_this, nUnit, nState);
	return __nErr;
}

INT16 CFst_OnDeltrans(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	INT32 nTrans;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nTrans = (INT32)MIC_GET_N(1,0);
	nUnit = (INT32)MIC_GET_N(2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Deltrans(_this, nUnit, nTrans);
	return __nErr;
}

INT16 CFst_OnDelunit(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Delunit(_this, nUnit);
	return __nErr;
}

INT16 CFst_OnDeterminize(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	itSrc = MIC_GET_I_EX(itSrc,fst,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Determinize(_this, itSrc, nUnit);
	return __nErr;
}

INT16 CFst_OnDiscount(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nDiscount;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	nDiscount = (INT32)MIC_GET_N(2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Discount(_this, nDiscount, nUnit);
	return __nErr;
}

INT16 CFst_OnEpsdist(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	itSrc = MIC_GET_I_EX(itSrc,fst,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Epsdist(_this, itSrc, nUnit);
	return __nErr;
}

INT16 CFst_OnEpsremove(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	itSrc = MIC_GET_I_EX(itSrc,fst,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Epsremove(_this, itSrc, nUnit);
	return __nErr;
}

INT16 CFst_OnExcerpt(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT32 nUnit;
	data* idStates;
	INT32 nIcSates;
	data* idIs;
	INT32 nParam;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nParam = (INT32)MIC_GET_N(1,0);
	idIs = MIC_GET_I_EX(idIs,data,2,1);
	nIcSates = (INT32)MIC_GET_N(3,1);
	idStates = MIC_GET_I_EX(idStates,data,4,2);
	nUnit = (INT32)MIC_GET_N(5,2);
	itSrc = MIC_GET_I_EX(itSrc,fst,6,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Excerpt(_this, itSrc, nUnit, idStates, nIcSates, idIs, nParam);
	return __nErr;
}

INT16 CFst_OnFslist(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	data* idDst;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idDst = MIC_GET_I_EX(idDst,data,1,1);
	nUnit = (INT32)MIC_GET_N(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Fslist(_this, nUnit, idDst);
	return __nErr;
}

INT16 CFst_OnFsunify(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Fsunify(_this, nUnit);
	return __nErr;
}

INT16 CFst_OnGetType(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nMask;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nMask = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_N(CFst_GetType(_this, nMask));
	return __nErr;
}

INT16 CFst_OnHmm(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	itSrc = MIC_GET_I_EX(itSrc,fst,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Hmm(_this, itSrc, nUnit);
	return __nErr;
}

INT16 CFst_OnIntersect(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc1;
	fst* itSrc2;
	INT32 nUnit1;
	INT32 nUnit2;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit2 = (INT32)MIC_GET_N(1,0);
	nUnit1 = (INT32)MIC_GET_N(2,1);
	itSrc2 = MIC_GET_I_EX(itSrc2,fst,3,1);
	itSrc1 = MIC_GET_I_EX(itSrc1,fst,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Intersect(_this, itSrc1, itSrc2, nUnit1, nUnit2);
	return __nErr;
}

INT16 CFst_OnInvert(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Invert(_this, nUnit);
	return __nErr;
}

INT16 CFst_OnLoops(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Loops(_this, nUnit);
	return __nErr;
}

INT16 CFst_OnMinimize(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	itSrc = MIC_GET_I_EX(itSrc,fst,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Minimize(_this, itSrc, nUnit);
	return __nErr;
}

INT16 CFst_OnMultigram(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	data* idSeq;
	INT32 nComp;
	data* idWeights;
	fst* itDst;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	itDst = MIC_GET_I_EX(itDst,fst,2,1);
	idWeights = MIC_GET_I_EX(idWeights,data,3,2);
	nComp = (INT32)MIC_GET_N(4,1);
	idSeq = MIC_GET_I_EX(idSeq,data,5,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Multigram(_this, idSeq, nComp, idWeights, itDst, nUnit);
	return __nErr;
}

INT16 CFst_OnOrder(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	data* idMap;
	INT32 nComp;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	nComp = (INT32)MIC_GET_N(2,1);
	idMap = MIC_GET_I_EX(idMap,data,3,1);
	itSrc = MIC_GET_I_EX(itSrc,fst,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Order(_this, itSrc, idMap, nComp, nUnit);
	return __nErr;
}

INT16 CFst_OnPotential(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Potential(_this, nUnit);
	return __nErr;
}

INT16 CFst_OnPrint(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Print(_this);
	return __nErr;
}

INT16 CFst_OnProbs(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Probs(_this, nUnit);
	return __nErr;
}

INT16 CFst_OnProduct(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc1;
	fst* itSrc2;
	INT32 nUnit1;
	INT32 nUnit2;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit2 = (INT32)MIC_GET_N(1,0);
	nUnit1 = (INT32)MIC_GET_N(2,1);
	itSrc2 = MIC_GET_I_EX(itSrc2,fst,3,1);
	itSrc1 = MIC_GET_I_EX(itSrc1,fst,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Product(_this, itSrc1, itSrc2, nUnit1, nUnit2);
	return __nErr;
}

INT16 CFst_OnProject(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Project(_this);
	return __nErr;
}

INT16 CFst_OnPushWeights(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	itSrc = MIC_GET_I_EX(itSrc,fst,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_PushWeights(_this, itSrc, nUnit);
	return __nErr;
}

INT16 CFst_OnRank(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	data* idDst;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idDst = MIC_GET_I_EX(idDst,data,1,1);
	nUnit = (INT32)MIC_GET_N(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Rank(_this, nUnit, idDst);
	return __nErr;
}

INT16 CFst_OnRcs(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	FLOAT64 nSeed;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nSeed = MIC_GET_N(1,0);
	nUnit = (INT32)MIC_GET_N(2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Rcs(_this, nUnit, nSeed);
	return __nErr;
}

INT16 CFst_OnRegexCompile(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	char* sRgx;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	sRgx = MIC_GET_S(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_RegexCompile(_this, sRgx);
	return __nErr;
}

INT16 CFst_OnRegexMatch(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	char* sStr;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	sStr = MIC_GET_S(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_RegexMatch(_this, sStr);
	return __nErr;
}

INT16 CFst_OnReverse(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Reverse(_this, nUnit);
	return __nErr;
}

INT16 CFst_OnRndwalk(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT32 nUnit;
	INT32 nPaths;
	FLOAT64 nWInfluence;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nWInfluence = MIC_GET_N(1,0);
	nPaths = (INT32)MIC_GET_N(2,1);
	nUnit = (INT32)MIC_GET_N(3,2);
	itSrc = MIC_GET_I_EX(itSrc,fst,4,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Rndwalk(_this, itSrc, nUnit, nPaths, nWInfluence);
	return __nErr;
}

INT16 CFst_OnSdp(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT32 nUnit;
	data* idWeights;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idWeights = MIC_GET_I_EX(idWeights,data,1,1);
	nUnit = (INT32)MIC_GET_N(2,0);
	itSrc = MIC_GET_I_EX(itSrc,fst,3,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Sdp(_this, itSrc, nUnit, idWeights);
	return __nErr;
}

INT16 CFst_OnStatus(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Status(_this);
	return __nErr;
}

INT16 CFst_OnStp(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT32 nUnit;
	INT32 nPaths;
	data* idWeights;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idWeights = MIC_GET_I_EX(idWeights,data,1,1);
	nPaths = (INT32)MIC_GET_N(2,0);
	nUnit = (INT32)MIC_GET_N(3,1);
	itSrc = MIC_GET_I_EX(itSrc,fst,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Stp(_this, itSrc, nUnit, nPaths, idWeights);
	return __nErr;
}

INT16 CFst_OnTree(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	itSrc = MIC_GET_I_EX(itSrc,fst,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Tree(_this, itSrc, nUnit);
	return __nErr;
}

INT16 CFst_OnTrim(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	FLOAT64 nWlim;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nWlim = MIC_GET_N(1,0);
	nUnit = (INT32)MIC_GET_N(2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Trim(_this, nUnit, nWlim);
	return __nErr;
}

INT16 CFst_OnTyperepair(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Typerepair(_this);
	return __nErr;
}

INT16 CFst_OnUnion(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* iSrc;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	iSrc = MIC_GET_I_EX(iSrc,fst,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Union(_this, iSrc);
	return __nErr;
}

INT16 CFst_OnUnweight(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Unweight(_this);
	return __nErr;
}

INT16 CFst_OnWire(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* iSrc;
	data* idBigram;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	idBigram = MIC_GET_I_EX(idBigram,data,1,1);
	iSrc = MIC_GET_I_EX(iSrc,fst,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_Wire(_this, iSrc, idBigram);
	return __nErr;
}

INT16 CFst_OnCFst_WsrConvert_Iam(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_CFst_WsrConvert_Iam(_this);
	return __nErr;
}

INT16 CFst_OnX1(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSrc;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	itSrc = MIC_GET_I_EX(itSrc,fst,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_X1(_this, itSrc, nUnit);
	return __nErr;
}

INT16 CFst_OnX2(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nUnit;
	GET_THIS_VIRTUAL_RV(CFst,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	nUnit = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFst_X2(_this, nUnit);
	return __nErr;
}

/*}}CGEN_CPMIC */
#endif /* #ifndef __NOITP */


/* Generated secondary method invocation functions */

/*{{CGEN_CSMIC */
INT16 CFst_CFst_WsrConvert_Iam(CFst* _this)
{
    if (_this->m_bPsr) return CFst_Wsr_Convert(_this,FST_WSR_PROB);
    if (_this->m_bLsr) return CFst_Wsr_Convert(_this,FST_WSR_LOG );
    if (_this->m_bTsr) return CFst_Wsr_Convert(_this,FST_WSR_TROP);
    return O_K;
	return O_K;
}

INT16 CFst_X2(CFst* _this, INT32 nUnit)
{
    CFst_MarkConnected(_this,nUnit);
	return O_K;
}

/*}}CGEN_CSMIC */


/* Generated option change callback functions */

/*{{CGEN_COCCF */
/*}}CGEN_COCCF */


/* Generated field change callback functions */

/*{{CGEN_CFCCF */
/*}}CGEN_CFCCF */


/* C++ wrapper functions */
#ifdef __cplusplus

#define _this this

CFst::CFst(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	CFst_Constructor(this,lpInstanceName,bCallVirtual);
}

CFst::~CFst()
{
	CFst_Destructor(this);
}

INT16 CFst::AutoRegisterWords()
{
	return CFst_AutoRegisterWords(this);
}

INT16 CFst::Init(BOOL bCallVirtual)
{
	return CFst_Init(this,bCallVirtual);
}

INT16 CFst::Reset(BOOL bResetMembers)
{
	return CFst_Reset(this,bResetMembers);
}

INT16 CFst::ClassProc()
{
	return CFst_ClassProc(this);
}

INT16 CFst::Serialize(CDN3Stream* lpDest)
{
	return CFst_Serialize(this,lpDest);
}

INT16 CFst::SerializeXml(CXmlStream* lpDest)
{
	return CFst_SerializeXml(this,lpDest);
}

INT16 CFst::Deserialize(CDN3Stream* lpSrc)
{
	return CFst_Deserialize(this,lpSrc);
}

INT16 CFst::DeserializeXml(CXmlStream* lpSrc)
{
	return CFst_DeserializeXml(this,lpSrc);
}

INT16 CFst::Copy(CDlpObject* __iSrc)
{
	return CFst_Copy(this,__iSrc);
}

INT16 CFst::InstallProc(void* lpItp)
{
	return CFst_InstallProc(lpItp);
}

CFst* CFst::CreateInstance(const char* lpName)
{
	return CFst_CreateInstance(lpName);
}

INT16 CFst::GetClassInfo(SWord* lpClassWord)
{
	return CFst_GetClassInfo(lpClassWord);
}

INT16 CFst::GetInstanceInfo(SWord* lpClassWord)
{
	return CFst_GetInstanceInfo(this,lpClassWord);
}

BOOL CFst::IsKindOf(const char* lpClassName)
{
	return CFst_IsKindOf(this,lpClassName);
}

INT16 CFst::ResetAllOptions(BOOL bInit)
{
	return CFst_ResetAllOptions(this,bInit);
}

#ifndef __NOITP
/*{{CGEN_PMIC */
INT16 CFst::OnAddseq()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnAddseq(this);
}

INT16 CFst::OnAddstatesIam()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnAddstatesIam(this);
}

INT16 CFst::OnAddtransIam()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnAddtransIam(this);
}

INT16 CFst::OnAddunitIam()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnAddunitIam(this);
}

INT16 CFst::OnAnalyze()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnAnalyze(this);
}

INT16 CFst::OnAnalyzeMultigram()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnAnalyzeMultigram(this);
}

INT16 CFst::OnBestN()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnBestN(this);
}

INT16 CFst::OnCat()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnCat(this);
}

INT16 CFst::OnChain()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnChain(this);
}

INT16 CFst::OnClose()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnClose(this);
}

INT16 CFst::OnCompile()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnCompile(this);
}

INT16 CFst::OnCompose()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnCompose(this);
}

INT16 CFst::OnCopyUi()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnCopyUi(this);
}

INT16 CFst::OnDebug()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnDebug(this);
}

INT16 CFst::OnDelstate()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnDelstate(this);
}

INT16 CFst::OnDeltrans()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnDeltrans(this);
}

INT16 CFst::OnDelunit()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnDelunit(this);
}

INT16 CFst::OnDeterminize()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnDeterminize(this);
}

INT16 CFst::OnDiscount()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnDiscount(this);
}

INT16 CFst::OnEpsdist()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnEpsdist(this);
}

INT16 CFst::OnEpsremove()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnEpsremove(this);
}

INT16 CFst::OnExcerpt()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnExcerpt(this);
}

INT16 CFst::OnFslist()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnFslist(this);
}

INT16 CFst::OnFsunify()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnFsunify(this);
}

INT16 CFst::OnGetType()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnGetType(this);
}

INT16 CFst::OnHmm()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnHmm(this);
}

INT16 CFst::OnIntersect()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnIntersect(this);
}

INT16 CFst::OnInvert()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnInvert(this);
}

INT16 CFst::OnLoops()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnLoops(this);
}

INT16 CFst::OnMinimize()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnMinimize(this);
}

INT16 CFst::OnMultigram()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnMultigram(this);
}

INT16 CFst::OnOrder()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnOrder(this);
}

INT16 CFst::OnPotential()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnPotential(this);
}

INT16 CFst::OnPrint()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnPrint(this);
}

INT16 CFst::OnProbs()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnProbs(this);
}

INT16 CFst::OnProduct()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnProduct(this);
}

INT16 CFst::OnProject()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnProject(this);
}

INT16 CFst::OnPushWeights()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnPushWeights(this);
}

INT16 CFst::OnRank()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnRank(this);
}

INT16 CFst::OnRcs()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnRcs(this);
}

INT16 CFst::OnRegexCompile()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnRegexCompile(this);
}

INT16 CFst::OnRegexMatch()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnRegexMatch(this);
}

INT16 CFst::OnReverse()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnReverse(this);
}

INT16 CFst::OnRndwalk()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnRndwalk(this);
}

INT16 CFst::OnSdp()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnSdp(this);
}

INT16 CFst::OnStatus()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnStatus(this);
}

INT16 CFst::OnStp()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnStp(this);
}

INT16 CFst::OnTree()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnTree(this);
}

INT16 CFst::OnTrim()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnTrim(this);
}

INT16 CFst::OnTyperepair()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnTyperepair(this);
}

INT16 CFst::OnUnion()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnUnion(this);
}

INT16 CFst::OnUnweight()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnUnweight(this);
}

INT16 CFst::OnWire()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnWire(this);
}

INT16 CFst::OnCFst_WsrConvert_Iam()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnCFst_WsrConvert_Iam(this);
}

INT16 CFst::OnX1()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnX1(this);
}

INT16 CFst::OnX2()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFst_OnX2(this);
}

/*}}CGEN_PMIC */
#endif /* #ifndef __NOITP */

/*{{CGEN_SMIC */
INT16 CFst::CFst_WsrConvert_Iam()
{
	return CFst_CFst_WsrConvert_Iam(this);
}

INT16 CFst::X2(INT32 nUnit)
{
	return CFst_X2(this,nUnit);
}

/*}}CGEN_SMIC */

/*{{CGEN_OCCF */
/*}}CGEN_OCCF */

/*{{CGEN_FCCF */
/*}}CGEN_FCCF */

/*{{CGEN_CXXWRAP */
void CFst::Check()
{
	CFst_Check(this);
}

INT32 CFst::GetType(INT32 nMask)
{
	return CFst_GetType(this, nMask);
}

INT32 CFst::Analyze(INT32 nUnit, INT32 nMask)
{
	return CFst_Analyze(this, nUnit, nMask);
}

INT16 CFst::Status()
{
	return CFst_Status(this);
}

INT16 CFst::Print()
{
	return CFst_Print(this);
}

void CFst::ResetStateFlag(INT32 nUnit, BYTE bMask)
{
	CFst_ResetStateFlag(this, nUnit, bMask);
}

INT16 CFst::Typerepair()
{
	return CFst_Typerepair(this);
}

INT16 CFst::Compose(CFst* itSrc1, CFst* itSrc2, INT32 nUnit1, INT32 nUnit2)
{
	return CFst_Compose(this, itSrc1, itSrc2, nUnit1, nUnit2);
}

INT16 CFst::Intersect(CFst* itSrc1, CFst* itSrc2, INT32 nUnit1, INT32 nUnit2)
{
	return CFst_Intersect(this, itSrc1, itSrc2, nUnit1, nUnit2);
}

INT16 CFst::Product(CFst* itSrc1, CFst* itSrc2, INT32 nUnit1, INT32 nUnit2)
{
	return CFst_Product(this, itSrc1, itSrc2, nUnit1, nUnit2);
}

INT32 CFst::Addunit(const char* lpsName)
{
	return CFst_Addunit(this, lpsName);
}

INT16 CFst::AddunitIam(const char* lpsName)
{
	return CFst_AddunitIam(this, lpsName);
}

INT32 CFst::Addstates(INT32 nUnit, INT32 nCount, BOOL bFinal)
{
	return CFst_Addstates(this, nUnit, nCount, bFinal);
}

INT16 CFst::AddstatesIam(INT32 nUnit, INT32 nCount)
{
	return CFst_AddstatesIam(this, nUnit, nCount);
}

FST_ITYPE CFst::AddstateCopy(INT32 nUnit, CFst* itSrc, FST_ITYPE nSsrc)
{
	return CFst_AddstateCopy(this, nUnit, itSrc, nSsrc);
}

INT32 CFst::Addtrans(INT32 nUnit, FST_ITYPE nIni, FST_ITYPE nTer)
{
	return CFst_Addtrans(this, nUnit, nIni, nTer);
}

INT32 CFst::AddtransEx(INT32 nUnit, FST_ITYPE nIni, FST_ITYPE nTer, FST_STYPE nTis, FST_STYPE nTos, FST_WTYPE nW)
{
	return CFst_AddtransEx(this, nUnit, nIni, nTer, nTis, nTos, nW);
}

INT16 CFst::AddtransIam(INT32 nUnit, INT32 nIni, INT32 nTer)
{
	return CFst_AddtransIam(this, nUnit, nIni, nTer);
}

INT32 CFst::AddtransCopy(INT32 nUnit, FST_ITYPE nIni, FST_ITYPE nTer, CFst* itSrc, FST_ITYPE nTsrc)
{
	return CFst_AddtransCopy(this, nUnit, nIni, nTer, itSrc, nTsrc);
}

INT16 CFst::Delunit(INT32 nUnit)
{
	return CFst_Delunit(this, nUnit);
}

INT16 CFst::Delstate(INT32 nUnit, INT32 nState)
{
	return CFst_Delstate(this, nUnit, nState);
}

INT16 CFst::Deltrans(INT32 nUnit, INT32 nTrans)
{
	return CFst_Deltrans(this, nUnit, nTrans);
}

INT16 CFst::Reverse(INT32 nUnit)
{
	return CFst_Reverse(this, nUnit);
}

INT16 CFst::Trim(INT32 nUnit, FLOAT64 nWlim)
{
	return CFst_Trim(this, nUnit, nWlim);
}

INT16 CFst::Chain(INT32 nUnit)
{
	return CFst_Chain(this, nUnit);
}

INT16 CFst::Loops(INT32 nUnit)
{
	return CFst_Loops(this, nUnit);
}

INT16 CFst::Project()
{
	return CFst_Project(this);
}

INT16 CFst::Invert(INT32 nUnit)
{
	return CFst_Invert(this, nUnit);
}

INT16 CFst::Unweight()
{
	return CFst_Unweight(this);
}

void CFst::Edist_Fwd(FST_TID_TYPE* lpTI, FST_ITYPE nS, FST_WTYPE nDist, FST_WTYPE* lpW, FST_ITYPE* lpTos)
{
	CFst_Edist_Fwd(this, lpTI, nS, nDist, lpW, lpTos);
}

INT16 CFst::Epsdist(CFst* itSrc, INT32 nUnit)
{
	return CFst_Epsdist(this, itSrc, nUnit);
}

FST_ITYPE CFst::Erm_GetDestTerState(FST_TID_TYPE* lpTIsrc, FST_ITYPE nTerSrc)
{
	return CFst_Erm_GetDestTerState(this, lpTIsrc, nTerSrc);
}

BOOL CFst::Erm_EpsDistFromStart(FST_TID_TYPE* lpTIedt, FST_ITYPE nSsrc, FST_WTYPE* lpEpsWFZ)
{
	return CFst_Erm_EpsDistFromStart(lpTIedt, nSsrc, lpEpsWFZ);
}

INT16 CFst::Epsremove(CFst* itSrc, INT32 nUnit)
{
	return CFst_Epsremove(this, itSrc, nUnit);
}

void CFst::Det_LoadAuxTable_AddRec(CData* idAuxTab, FST_ITYPE nResStr, FST_WTYPE nResW, FST_ITYPE nTer, FST_STYPE nTis, FST_STYPE nTos, FST_WTYPE nW, BOOL bFinal)
{
	CFst_Det_LoadAuxTable_AddRec(this, idAuxTab, nResStr, nResW, nTer, nTis, nTos, nW, bFinal);
}

void CFst::Det_LoadAuxTable_Walk(FST_TID_TYPE* lpTI, FST_ITYPE nIniSrc, FST_ITYPE nResStr, FST_WTYPE nResW, CData* idAuxTab)
{
	CFst_Det_LoadAuxTable_Walk(this, lpTI, nIniSrc, nResStr, nResW, idAuxTab);
}

BOOL CFst::Det_LoadAuxTable(CFst* itSrc, INT32 nUnit, FST_ITYPE nIniSrc, FST_ITYPE nResStr, FST_WTYPE nResW, CData* idAuxTab, FST_TID_TYPE* lpTI)
{
	return CFst_Det_LoadAuxTable(this, itSrc, nUnit, nIniSrc, nResStr, nResW, idAuxTab, lpTI);
}

void CFst::Det_PrintAuxTable(CData* idAuxTab)
{
	CFst_Det_PrintAuxTable(this, idAuxTab);
}

FST_ITYPE CFst::Det_AddState(BOOL bFinal)
{
	return CFst_Det_AddState(this, bFinal);
}

FST_ITYPE CFst::Det_AddPath(FST_ITYPE nIni, FST_STYPE nTis, FST_ITYPE nTosStr, FST_WTYPE nW)
{
	return CFst_Det_AddPath(this, nIni, nTis, nTosStr, nW);
}

void CFst::Det_AddResidual(FST_ITYPE nSdst, FST_ITYPE nSsrc, FST_ITYPE nResStr, FST_WTYPE nResW)
{
	CFst_Det_AddResidual(this, nSdst, nSsrc, nResStr, nResW);
}

void CFst::Det_PrtResidual(FST_ITYPE nR)
{
	CFst_Det_PrtResidual(this, nR);
}

BOOL CFst::Det_CmpResiduals(FST_ITYPE nS1, FST_ITYPE nS2, FST_ITYPE** lpMap, INT32* nMapSi)
{
	return CFst_Det_CmpResiduals(this, nS1, nS2, lpMap, nMapSi);
}

INT16 CFst::DeterminizeUnit(CFst* itSrc, INT32 nUnit)
{
	return CFst_DeterminizeUnit(this, itSrc, nUnit);
}

INT16 CFst::Determinize(CFst* itSrc, INT32 nUnit)
{
	return CFst_Determinize(this, itSrc, nUnit);
}

INT16 CFst::MinimizeUnit(CFst* itSrc, INT32 nUnit)
{
	return CFst_MinimizeUnit(this, itSrc, nUnit);
}

INT16 CFst::Lazymin()
{
	return CFst_Lazymin(this);
}

INT16 CFst::Minimize(CFst* itSrc, INT32 nUnit)
{
	return CFst_Minimize(this, itSrc, nUnit);
}

FST_ITYPE CFst::Hmm_FindAddState(FST_TID_TYPE* lpTIsrc, FST_ITYPE nSsrc, FST_STYPE nTisSrc)
{
	return CFst_Hmm_FindAddState(this, lpTIsrc, nSsrc, nTisSrc);
}

INT16 CFst::HmmUnit(CFst* itSrc, INT32 nUnit)
{
	return CFst_HmmUnit(this, itSrc, nUnit);
}

INT16 CFst::Hmm(CFst* itSrc, INT32 nUnit)
{
	return CFst_Hmm(this, itSrc, nUnit);
}

FST_TID_TYPE* CFst::STI_Init(CFst* iFst, INT32 nUnit, INT32 nMode)
{
	return CFst_STI_Init(iFst, nUnit, nMode);
}

void CFst::STI_UnitChanged(FST_TID_TYPE* lpTI, INT16 nMode)
{
	CFst_STI_UnitChanged(lpTI, nMode);
}

void CFst::STI_Done(FST_TID_TYPE* lpTI)
{
	CFst_STI_Done(lpTI);
}

BOOL CFst::STI_IsSorted(FST_TID_TYPE* lpTI, INT32 nMode, FST_ITYPE* lpFSunsrtd, FST_ITYPE* lpFTunsrtd)
{
	return CFst_STI_IsSorted(lpTI, nMode, lpFSunsrtd, lpFTunsrtd);
}

void CFst::STI_Sort(FST_TID_TYPE* lpTI)
{
	CFst_STI_Sort(lpTI);
}

BYTE* CFst::STI_GetTransPtr(FST_TID_TYPE* lpTI, INT32 nTrans)
{
	return CFst_STI_GetTransPtr(lpTI, nTrans);
}

FST_ITYPE CFst::STI_GetTransId(FST_TID_TYPE* lpTI, BYTE* lpTrans)
{
	return CFst_STI_GetTransId(lpTI, lpTrans);
}

FST_ITYPE* CFst::STI_TIni(FST_TID_TYPE* lpTI, BYTE* lpTrans)
{
	return CFst_STI_TIni(lpTI, lpTrans);
}

FST_ITYPE* CFst::STI_TTer(FST_TID_TYPE* lpTI, BYTE* lpTrans)
{
	return CFst_STI_TTer(lpTI, lpTrans);
}

FST_STYPE* CFst::STI_TTis(FST_TID_TYPE* lpTI, BYTE* lpTrans)
{
	return CFst_STI_TTis(lpTI, lpTrans);
}

FST_STYPE* CFst::STI_TTos(FST_TID_TYPE* lpTI, BYTE* lpTrans)
{
	return CFst_STI_TTos(lpTI, lpTrans);
}

FST_ITYPE* CFst::STI_TRc(FST_TID_TYPE* lpTI, BYTE* lpTrans)
{
	return CFst_STI_TRc(lpTI, lpTrans);
}

FST_WTYPE* CFst::STI_TW(FST_TID_TYPE* lpTI, BYTE* lpTrans)
{
	return CFst_STI_TW(lpTI, lpTrans);
}

BYTE* CFst::STI_TfromS(FST_TID_TYPE* lpTI, FST_ITYPE nState, BYTE* lpTrans)
{
	return CFst_STI_TfromS(lpTI, nState, lpTrans);
}

BYTE* CFst::STI_TtoS(FST_TID_TYPE* lpTI, INT32 nState, BYTE* lpTrans)
{
	return CFst_STI_TtoS(lpTI, nState, lpTrans);
}

BOOL CFst::STI_Walk(FST_TID_TYPE* lpTI, FST_WALKFUNC_TYPE* lpWalkFunc, void* lpWalkFuncData, FST_ITYPE nState, BOOL bBwd)
{
	return CFst_STI_Walk(lpTI, lpWalkFunc, lpWalkFuncData, nState, bBwd);
}

BOOL CFst::STI_WalkInt(FST_TID_TYPE* lpTI, FST_WALKFUNC_TYPE* lpWalkFunc, void* lpWalkFuncData, FST_ITYPE nState, BOOL bBwd, INT32 nDepth)
{
	return CFst_STI_WalkInt(lpTI, lpWalkFunc, lpWalkFuncData, nState, bBwd, nDepth);
}

INT16 CFst::CatEx(CFst* itSrc, INT32 nFirstUnit, INT32 nCount)
{
	return CFst_CatEx(this, itSrc, nFirstUnit, nCount);
}

INT16 CFst::Cat(CFst* itSrc)
{
	return CFst_Cat(this, itSrc);
}

INT16 CFst::CopyUi(CFst* itSrc, CData* idIndex, INT32 nPar)
{
	return CFst_CopyUi(this, itSrc, idIndex, nPar);
}

INT32 CFst::Nmg_StoreSeq(INT32 nUnit, FST_ITYPE nSeqId, FST_SEQ_TYPE* lpSseq, FST_SEQ_TYPE* lpCseq, BOOL bSubSeq)
{
	return CFst_Nmg_StoreSeq(this, nUnit, nSeqId, lpSseq, lpCseq, bSubSeq);
}

INT16 CFst::Addseq(CData* idSrc, INT32 nIcTis, INT32 nIcTer, INT32 nIcRci, INT32 nUnit)
{
	return CFst_Addseq(this, idSrc, nIcTis, nIcTer, nIcRci, nUnit);
}

INT32 CFst::Nmg_FetchSeq(FST_TID_TYPE* lpTI, FST_SEQ_TYPE Sseq, FST_ITYPE* lpTseq)
{
	return CFst_Nmg_FetchSeq(this, lpTI, Sseq, lpTseq);
}

void CFst::Nmg_GetMgiWeights(CData* idWeights, FST_WTYPE* lpW, INT16 nLen)
{
	CFst_Nmg_GetMgiWeights(this, idWeights, lpW, nLen);
}

FST_WTYPE CFst::Nmg_CalcCondProb(FST_TID_TYPE* lpTI, FST_SEQ_TYPE Sseq, const FST_WTYPE* lpW, INT16* lpActualOrder)
{
	return CFst_Nmg_CalcCondProb(this, lpTI, Sseq, lpW, lpActualOrder);
}

FST_WTYPE CFst::Nmg_CalcSeqProb(FST_TID_TYPE* lpTI, FST_SEQ_TYPE Sseq, INT32 nOrder, CData* idWeights, FST_ITYPE* lpSid, INT16* lpActualOrder)
{
	return CFst_Nmg_CalcSeqProb(this, lpTI, Sseq, nOrder, idWeights, lpSid, lpActualOrder);
}

INT16 CFst::Multigram(CData* idSeq, INT32 nComp, CData* idWeights, CFst* itDst, INT32 nUnit)
{
	return CFst_Multigram(this, idSeq, nComp, idWeights, itDst, nUnit);
}

INT16 CFst::AnalyzeMultigram(CData* idCtrs, INT32 nUnit)
{
	return CFst_AnalyzeMultigram(this, idCtrs, nUnit);
}

INT16 CFst::Discount(INT32 nDiscount, INT32 nUnit)
{
	return CFst_Discount(this, nDiscount, nUnit);
}

void CFst::Mc_Fwd(FST_TID_TYPE* lpTI, FST_ITYPE nS)
{
	CFst_Mc_Fwd(this, lpTI, nS);
}

void CFst::Mc_Bkw(FST_TID_TYPE* lpTI, FST_ITYPE nS)
{
	CFst_Mc_Bkw(this, lpTI, nS);
}

INT16 CFst::MarkConnected(INT32 nUnit)
{
	return CFst_MarkConnected(this, nUnit);
}

INT16 CFst::TrimStates(INT32 nU)
{
	return CFst_TrimStates(this, nU);
}

INT16 CFst::MakeTopoOrderMap(INT32 nUnit, CData* idMap)
{
	return CFst_MakeTopoOrderMap(this, nUnit, idMap);
}

void CFst::Rank_Rcsn(FST_TID_TYPE* lpTI, INT32 nRank, FST_ITYPE nS, CData* idDst)
{
	CFst_Rank_Rcsn(lpTI, nRank, nS, idDst);
}

INT16 CFst::Rank_Unit(INT32 nUnit, CData* idDst)
{
	return CFst_Rank_Unit(this, nUnit, idDst);
}

INT16 CFst::Rank(INT32 nUnit, CData* idDst)
{
	return CFst_Rank(this, nUnit, idDst);
}

INT16 CFst::Order(CFst* itSrc, CData* idMap, INT32 nComp, INT32 nUnit)
{
	return CFst_Order(this, itSrc, idMap, nComp, nUnit);
}

INT16 CFst::Fslist(INT32 nUnit, CData* idDst)
{
	return CFst_Fslist(this, nUnit, idDst);
}

INT16 CFst::Fsunify(INT32 nUnit)
{
	return CFst_Fsunify(this, nUnit);
}

INT16 CFst::TreeUnit_Walk(FST_TID_TYPE* lpTI, FST_ITYPE nSsrc, FST_ITYPE nSdst, INT32 nDepth)
{
	return CFst_TreeUnit_Walk(this, lpTI, nSsrc, nSdst, nDepth);
}

INT16 CFst::TreeUnit(CFst* itSrc, INT32 nUnit)
{
	return CFst_TreeUnit(this, itSrc, nUnit);
}

INT16 CFst::Tree(CFst* itSrc, INT32 nUnit)
{
	return CFst_Tree(this, itSrc, nUnit);
}

BOOL CFst::ExcerptWalk(FST_TID_TYPE* lpTI, FST_EXCR_TYPE* lpED, FST_ITYPE nS, FST_ITYPE nIis, FST_ITYPE nDepth)
{
	return CFst_ExcerptWalk(lpTI, lpED, nS, nIis, nDepth);
}

INT16 CFst::Excerpt(CFst* itSrc, INT32 nUnit, CData* idStates, INT32 nIcStates, CData* idIs, INT32 nParam)
{
	return CFst_Excerpt(this, itSrc, nUnit, idStates, nIcStates, idIs, nParam);
}

INT16 CFst::Potential(INT32 nUnit)
{
	return CFst_Potential(this, nUnit);
}

INT16 CFst::Rndwalk(CFst* itSrc, INT32 nUnit, INT32 nPaths, FLOAT64 nWInfluence)
{
	return CFst_Rndwalk(this, itSrc, nUnit, nPaths, nWInfluence);
}

INT16 CFst::PushWeights(CFst* itSrc, INT32 nUnit)
{
	return CFst_PushWeights(this, itSrc, nUnit);
}

FST_BT_TYPE* CFst::Sdp_BtInit(FST_TID_TYPE* lpTI, INT32 nGrany)
{
	return CFst_Sdp_BtInit(lpTI, nGrany);
}

void CFst::Sdp_BtDone(FST_BT_TYPE* lpBT)
{
	CFst_Sdp_BtDone(lpBT);
}

void CFst::Sdp_BtStore(FST_BT_TYPE* lpBT, BYTE* lpT, BYTE* lpTprev, INT16 bEps)
{
	CFst_Sdp_BtStore(lpBT, lpT, lpTprev, bEps);
}

BYTE* CFst::Sdp_BtFetch(FST_BT_TYPE* lpBT, INT32 nT)
{
	return CFst_Sdp_BtFetch(lpBT, nT);
}

void CFst::Sdp_BtPrint(FST_BT_TYPE* lpBT)
{
	CFst_Sdp_BtPrint(lpBT);
}

void CFst::Sdp_GetSWeights(FST_WTYPE* lpSWa, INT32 t, INT32 nXW, FST_WTYPE** lpSW)
{
	CFst_Sdp_GetSWeights(this, lpSWa, t, nXW, lpSW);
}

void CFst::Sdp_ClearLB(FST_LB_TYPE* lpLB, INT32 nXS)
{
	CFst_Sdp_ClearLB(this, lpLB, nXS);
}

INT32 CFst::Sdp_ExpandState(FST_TID_TYPE* lpTI, FST_WTYPE* lpSW, INT32 t, FST_ITYPE nS, FST_WTYPE nD, FST_LB_TYPE* lpLBwr, INT16 bFlags)
{
	return CFst_Sdp_ExpandState(this, lpTI, lpSW, t, nS, nD, lpLBwr, bFlags);
}

INT32 CFst::Sdp_ExpandLayer(FST_TID_TYPE* lpTI, FST_WTYPE* lpSW, INT32 t, INT32 nTmax, FST_LB_TYPE** lpLBrd, FST_LB_TYPE** lpLBwr, FST_BT_TYPE* lpBT, INT16 bFlags)
{
	return CFst_Sdp_ExpandLayer(this, lpTI, lpSW, t, nTmax, lpLBrd, lpLBwr, lpBT, bFlags);
}

INT16 CFst::Sdp_Backtracking(FST_BT_TYPE* lpBT, INT32 nET, INT32 nEL, FST_ITYPE nES, FST_WTYPE nED, CData* idWeights)
{
	return CFst_Sdp_Backtracking(this, lpBT, nET, nEL, nES, nED, idWeights);
}

void CFst::Sdp_Order()
{
	CFst_Sdp_Order(this);
}

void CFst::Sdp_Epsremove()
{
	CFst_Sdp_Epsremove(this);
}

INT16 CFst::SdpUnit(CFst* itSrc, INT32 nUnit, CData* idWeights)
{
	return CFst_SdpUnit(this, itSrc, nUnit, idWeights);
}

INT16 CFst::Sdp(CFst* itSrc, INT32 nUnit, CData* idWeights)
{
	return CFst_Sdp(this, itSrc, nUnit, idWeights);
}

INT16 CFst::Stp_checkArgs(CData* idWeights)
{
	return CFst_Stp_checkArgs(this, idWeights);
}

void CFst::Stp_printWLR(FST_WLR_TYPE* lpWLR)
{
	CFst_Stp_printWLR(lpWLR);
}

void CFst::Stp_destroyWLR(FST_WLR_TYPE** lpWLR)
{
	CFst_Stp_destroyWLR(this, lpWLR);
}

INT16 CFst::Stp_updateTable(FST_WLR_TYPE*** lpBestTable, FST_WLR_TYPE** lpWLR, INT32 t, INT32 nPaths)
{
	return CFst_Stp_updateTable(this, lpBestTable, lpWLR, t, nPaths);
}

void CFst::Stp_freeBackTrackTable(FST_WLR_TYPE*** lpBestTable, INT32 nLength, INT32 nPaths)
{
	CFst_Stp_freeBackTrackTable(this, lpBestTable, nLength, nPaths);
}

INT16 CFst::stp_backtrackTable(FST_WLR_TYPE*** lpBestTable, INT32 nLength, INT32 nPaths)
{
	return CFst_stp_backtrackTable(this, lpBestTable, nLength, nPaths);
}

INT16 CFst::Stp_propagateEntryTokens(INT32 t, INT32 nUnit, INT32 nPaths, FST_TID_TYPE* lpTI, FST_WTYPE* lpSW, FST_TOK_TYPE*** lpNewTokens, FST_WLR_TYPE*** lpBestTable, CFst* itSrc)
{
	return CFst_Stp_propagateEntryTokens(this, t, nUnit, nPaths, lpTI, lpSW, lpNewTokens, lpBestTable, itSrc);
}

INT16 CFst::Stp_updateWeights(CFst* itSrc, FST_TOK_TYPE*** lpNewTokens, FST_TOK_TYPE*** lpOldTokens, FST_WLR_TYPE*** lpBestTable, FST_TID_TYPE* lpTI, BYTE* lpTX, FST_WTYPE* lpSW, INT32 t, INT32 nPaths, INT32* nPassings, char bEps)
{
	return CFst_Stp_updateWeights(this, itSrc, lpNewTokens, lpOldTokens, lpBestTable, lpTI, lpTX, lpSW, t, nPaths, nPassings, bEps);
}

INT32 CFst::Stp_passTokens(INT32 t, INT32 nUnit, INT32 nPaths, char bEps, FST_TID_TYPE* lpTI, FST_WTYPE* lpSW, FST_TOK_TYPE*** lpOldTokens, FST_TOK_TYPE*** lpNewTokens, FST_WLR_TYPE*** lpBestTable, CFst* itSrc)
{
	return CFst_Stp_passTokens(this, t, nUnit, nPaths, bEps, lpTI, lpSW, lpOldTokens, lpNewTokens, lpBestTable, itSrc);
}

void CFst::Stp_initializeTokens(CFst* itSrc, INT32 nUnit, FST_TOK_TYPE*** lpTokens)
{
	CFst_Stp_initializeTokens(this, itSrc, nUnit, lpTokens);
}

void CFst::Stp_Done(CFst* itSrc, FST_TOK_TYPE*** lpOldTokens, FST_TOK_TYPE*** lpNewTokens, FST_WLR_TYPE*** lpBtTable, FST_TID_TYPE** lpTI, INT32 nPaths, INT32 nLength, INT32 nUnit)
{
	CFst_Stp_Done(this, itSrc, lpOldTokens, lpNewTokens, lpBtTable, lpTI, nPaths, nLength, nUnit);
}

INT16 CFst::StpUnit(CFst* itSrc, INT32 nUnit, INT32 nPaths, CData* idWeights)
{
	return CFst_StpUnit(this, itSrc, nUnit, nPaths, idWeights);
}

INT16 CFst::Stp(CFst* itSrc, INT32 nUnit, INT32 nPaths, CData* idWeights)
{
	return CFst_Stp(this, itSrc, nUnit, nPaths, idWeights);
}

INT16 CFst::ClearUnitLookupTable(hash_t* lpLookupTable)
{
	return CFst_ClearUnitLookupTable(lpLookupTable);
}

INT16 CFst::Compile(CData* idSrc, INT32 nIcStr, INT32 nIcName, CData* idAlp)
{
	return CFst_Compile(this, idSrc, nIcStr, nIcName, idAlp);
}

INT16 CFst::Wire(CFst* lpsSrc, CData* lpdBigram)
{
	return CFst_Wire(this, lpsSrc, lpdBigram);
}

INT16 CFst::Union(CFst* itSrc)
{
	return CFst_Union(this, itSrc);
}

INT16 CFst::CloseUnit(CFst* itSrc, INT32 nUnit)
{
	return CFst_CloseUnit(this, itSrc, nUnit);
}

INT16 CFst::Close(CFst* itSrc, INT32 nUnit)
{
	return CFst_Close(this, itSrc, nUnit);
}

FST_SST_TYPE* CFst::Ssr_Init(INT32 nGrany)
{
	return CFst_Ssr_Init(nGrany);
}

void CFst::Ssr_Done(FST_SST_TYPE* lpST)
{
	CFst_Ssr_Done(lpST);
}

FST_ITYPE CFst::Ssr_Find(FST_SST_TYPE* lpST, FST_ITYPE* lpBuf)
{
	return CFst_Ssr_Find(lpST, lpBuf);
}

FST_ITYPE CFst::Ssr_Store(FST_SST_TYPE* lpST, FST_ITYPE* lpBuf)
{
	return CFst_Ssr_Store(lpST, lpBuf);
}

void CFst::Ssr_Fetch(FST_SST_TYPE* lpST, FST_ITYPE nS, FST_ITYPE* lpBuf, INT32 nMaxLen)
{
	CFst_Ssr_Fetch(lpST, nS, lpBuf, nMaxLen);
}

FST_STYPE CFst::Ssr_GetAt(FST_SST_TYPE* lpST, FST_ITYPE nS, FST_ITYPE nPos)
{
	return CFst_Ssr_GetAt(lpST, nS, nPos);
}

INT32 CFst::Ssr_Len(FST_SST_TYPE* lpST, FST_ITYPE nS)
{
	return CFst_Ssr_Len(lpST, nS);
}

FST_ITYPE CFst::Ssr_NeMult()
{
	return CFst_Ssr_NeMult();
}

FST_ITYPE CFst::Ssr_NeAdd()
{
	return CFst_Ssr_NeAdd();
}

FST_ITYPE CFst::Ssr_Mult(FST_SST_TYPE* lpST, FST_ITYPE nS1, FST_ITYPE nS2)
{
	return CFst_Ssr_Mult(lpST, nS1, nS2);
}

FST_ITYPE CFst::Ssr_Add(FST_SST_TYPE* lpST, FST_ITYPE nS1, FST_ITYPE nS2)
{
	return CFst_Ssr_Add(lpST, nS1, nS2);
}

FST_ITYPE CFst::Ssr_Dif(FST_SST_TYPE* lpST, FST_ITYPE nS1, FST_ITYPE nS2)
{
	return CFst_Ssr_Dif(lpST, nS1, nS2);
}

void CFst::Ssr_Print(FST_SST_TYPE* lpST, FST_ITYPE nS)
{
	CFst_Ssr_Print(lpST, nS);
}

INT16 CFst::Wsr_GetType(INT32* lpnComp)
{
	return CFst_Wsr_GetType(this, lpnComp);
}

const char* CFst::Wsr_GetName(INT16 nWsrType)
{
	return CFst_Wsr_GetName(nWsrType);
}

FST_WTYPE CFst::Wsr_Op(FST_WTYPE nW1, FST_WTYPE nW2, INT16 nOpc)
{
	return CFst_Wsr_Op(this, nW1, nW2, nOpc);
}

FST_WTYPE CFst::Wsr_NeAdd(INT16 nSrType)
{
	return CFst_Wsr_NeAdd(nSrType);
}

FST_WTYPE CFst::Wsr_NeMult(INT16 nSrType)
{
	return CFst_Wsr_NeMult(nSrType);
}

INT16 CFst::Wsr_Convert(INT16 nSrType)
{
	return CFst_Wsr_Convert(this, nSrType);
}

INT16 CFst::Probs(INT32 nUnit)
{
	return CFst_Probs(this, nUnit);
}

INT16 CFst::Rcs(INT32 nUnit, FLOAT64 nSeed)
{
	return CFst_Rcs(this, nUnit, nSeed);
}

INT16 CFst::RegexCompile(const char* sRgx)
{
	return CFst_RegexCompile(this, sRgx);
}

INT16 CFst::RegexMatch_int(const char* sStr, INT32* nS, INT32* nL)
{
	return CFst_RegexMatch_int(this, sStr, nS, nL);
}

INT16 CFst::RegexMatch(const char* sStr)
{
	return CFst_RegexMatch(this, sStr);
}

void CFst::Cps_HashPrint()
{
	CFst_Cps_HashPrint(this);
}

void CFst::Cps_HashResolveKey(const void* lpKey, FST_ITYPE* lpSX, FST_ITYPE* lpSY, BYTE* lpFlagXY)
{
	CFst_Cps_HashResolveKey(this, lpKey, lpSX, lpSY, lpFlagXY);
}

void* CFst::Cps_HashMakeTmpKey(FST_ITYPE nSX, FST_ITYPE nSY, FST_ITYPE nFlagXY)
{
	return CFst_Cps_HashMakeTmpKey(this, nSX, nSY, nFlagXY);
}

hash_val_t CFst::Cps_HashFn(const void* lpKey, void* lpContext)
{
	return CFst_Cps_HashFn(lpKey, lpContext);
}

int CFst::Cps_HashCmp(const void* lpKey1, const void* lpKey2, void* lpContext)
{
	return CFst_Cps_HashCmp(lpKey1, lpKey2, lpContext);
}

void CFst::Cps_AddSdAux()
{
	CFst_Cps_AddSdAux(this);
}

void CFst::Cps_DelSdAux()
{
	CFst_Cps_DelSdAux(this);
}

void CFst::Cps_SetSdAux(FST_ITYPE nS, FST_ITYPE nSX, FST_ITYPE nSY, BYTE nFlagXY)
{
	CFst_Cps_SetSdAux(this, nS, nSX, nSY, nFlagXY);
}

FST_ITYPE CFst::Cps_FindState(FST_ITYPE nSX, FST_ITYPE nSY, BYTE nFlagXY)
{
	return CFst_Cps_FindState(this, nSX, nSY, nFlagXY);
}

int CFst::Bsn_CompUp(const void* lpElem1, const void* lpElem2)
{
	return CFst_Bsn_CompUp(lpElem1, lpElem2);
}

int CFst::Bsn_CompDown(const void* lpElem1, const void* lpElem2)
{
	return CFst_Bsn_CompDown(lpElem1, lpElem2);
}

INT16 CFst::BestNUnit(CFst* itSrc, INT32 nUnit, INT32 nPaths, INT32 nPathlength)
{
	return CFst_BestNUnit(this, itSrc, nUnit, nPaths, nPathlength);
}

INT16 CFst::BestN(CFst* itSrc, INT32 nUnit, INT32 nPaths, INT32 nPathlength)
{
	return CFst_BestN(this, itSrc, nUnit, nPaths, nPathlength);
}

INT16 CFst::X1(CFst* itSrc, INT32 nUnit)
{
	return CFst_X1(this, itSrc, nUnit);
}

INT16 CFst::BestNUnitLocal(CFst* itSrc, INT32 nUnit, INT32 nPaths)
{
	return CFst_BestNUnitLocal(this, itSrc, nUnit, nPaths);
}

INT16 CFst::Debug(FLOAT64 nParam, const char* sOp)
{
	return CFst_Debug(this, nParam, sOp);
}

/*}}CGEN_CXXWRAP */

#endif /* #ifdef __cplusplus */

/* EOF */
