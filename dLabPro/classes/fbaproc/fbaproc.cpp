// dLabPro class CFBAproc (FBAproc)
// - Base class for frame based analysis classes.
//
// AUTHOR : Matthias Eichner
// PACKAGE: dLabPro/classes
//
// This file was generated by dcg. DO NOT MODIFY! Modify fbaproc.def instead.
// 
// Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
// - Chair of System Theory and Speech Technology, TU Dresden
// - Chair of Communications Engineering, BTU Cottbus
// 
// This file is part of dLabPro.
// 
// dLabPro is free software: you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
// 
// dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
// details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with dLabPro. If not, see <http://www.gnu.org/licenses/>.


//{{CGEN_INCLUDE
//}}CGEN_END
#include "dlp_fbaproc.h"

// Class CFBAproc

CFBAproc::CFBAproc(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	DEBUGMSG(-1,"CFBAproc::CFBAproc; (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	dlp_strcpy(m_lpClassName,"FBAproc");
	dlp_strcpy(m_lpObsoleteName,"");
	dlp_strcpy(m_lpProjectName,"FBAproc");
	dlp_strcpy(m_version.no,"1.0");
	dlp_strcpy(m_version.date,"");
	m_nClStyle = CS_AUTOACTIVATE;

	if (bCallVirtual)
	{
		DLPASSERT(OK(AutoRegisterWords()));
		Init(TRUE);
	}
}

CFBAproc::~CFBAproc()
{
  //{{CGEN_DONECODE

  if (m_idWindow   ) IDESTROY(m_idWindow   );
  if (m_idRealFrame) IDESTROY(m_idRealFrame);
  if (m_idImagFrame) IDESTROY(m_idImagFrame);
  if (m_idEnergy   ) IDESTROY(m_idEnergy   );
  if (m_idLabels   ) IDESTROY(m_idLabels   );
  if (m_idWarp     ) IDESTROY(m_idWarp     );

  DONE;
  //}}CGEN_DONECODE
}

INT16 CFBAproc::AutoRegisterWords()
{
	DEBUGMSG(-1,"CFBAproc::AutoRegisterWords",0,0,0);
	IF_NOK(inherited::AutoRegisterWords()) return NOT_EXEC;

	//{{CGEN_REGISTERWORDS

	// Register methods
	REGISTER_METHOD("-adjust_speech_rate","",LPMF(CFBAproc,OnAdjustSpeechRate),"Resamples pitch to new speech rate.",0,"<data idPitch> <data idNewPitch> <data idFea> <data idNewFea> <float rate> <FBAproc this>","")
	REGISTER_METHOD("-align_frames_to_pitch","",LPMF(CFBAproc,OnAlignFramesToPitch),"aligns frames to pitch to match number of pitches",0,"<data idPitch> <data idFea> <data idNewFea> <FBAproc this>","")
	REGISTER_METHOD("-analyze","",LPMF(CFBAproc,OnAnalyze),"Convert signal to sequence of frames.",0,"<data idSignal> <data idPitch> <data idReal> <data idImag> <FBAproc this>","")
	REGISTER_METHOD("-compress_pitch","",LPMF(CFBAproc,OnCompressPitch),"Resamples pitch with compressed pitch contour.",0,"<data idPitch> <data idNewPitch> <float factor> <FBAproc this>","")
	REGISTER_METHOD("-delta","",LPMF(CFBAproc,OnDelta),"Calculate delta and acceleration coefficients.",0,"<data in> <data out> <FBAproc this>","")
	REGISTER_METHOD("-fixed2floating","",LPMF(CFBAproc,OnFixed2floating),"Dequantization of numeric components from fixed point (short) to floating point.",0,"<data in> <data out> <FBAproc this>","")
	REGISTER_METHOD("-floating2fixed","",LPMF(CFBAproc,OnFloating2fixed),"Quantization of numeric components from floating point to fixed point (short).",0,"<data in> <data out> <FBAproc this>","")
	REGISTER_METHOD("-gen_pitch","",LPMF(CFBAproc,OnGenPitch),"Generates the pitch from prosodic information.",0,"<data idProso> <data idPitch> <FBAproc this>","")
	REGISTER_METHOD("-get_durations_from_inventory","",LPMF(CFBAproc,OnGetDurationsFromInventory),"Replaces zero entries of phoneme durations of into data instance with inventory durations.",0,"<data idFea> <data idInto> <FBAproc this>","")
	REGISTER_METHOD("-modEx","",LPMF(CFBAproc,OnModEx),"Generates amplitude modulated excitation data from pitch.",0,"<data dPitch> <data dExcite> <FBAproc this>","")
	REGISTER_METHOD("-resample_pitch","",LPMF(CFBAproc,OnResamplePitch),"Resamples excitation to new mean F0 for voice conversion.",0,"<data idPitch> <data idNewPitch> <int nFFreq> <FBAproc this>","")
	REGISTER_METHOD("-roots_track","",LPMF(CFBAproc,OnRootsTrack),"Calculates roots via iterative root tracking.",0,"<data idFea> <data idReal> <data idImag> <data idVUV> <FBAproc this>","")
	REGISTER_METHOD("-smooth","",LPMF(CFBAproc,OnSmooth),"Smoothes input array along records.",0,"<data idIn> <data idPm> <data idOut> <FBAproc this>","")
	REGISTER_METHOD("-status","",LPMF(CFBAproc,Status),"Display status information.",0,"<FBAproc this>","")
	REGISTER_METHOD("-synthesize","",LPMF(CFBAproc,OnSynthesize),"Synthesis. Convert sequence of frames to signal.",0,"<data idFea> <data idControl> <data idSyn> <FBAproc this>","")

	// Register options
	REGISTER_OPTION("/ana_smooth_fea","",LPMV(m_bAnaSmoothFea),NULL,"Smoothes features after analysis.",0)
	REGISTER_OPTION("/ana_smooth_roots","",LPMV(m_bAnaSmoothRoots),NULL,"Smoothes roots of features after analysis.",0)
	REGISTER_OPTION("/delta_mf","",LPMV(m_bDeltaMf),NULL,"Alternative delta computation algorithm.",0)
	REGISTER_OPTION("/energy","",LPMV(m_bEnergy),NULL,"Compute energy for every frame and save to field <energy>.",0)
	REGISTER_OPTION("/log_energy","",LPMV(m_bLogEnergy),NULL,"Compute logarithmic energy for every frame and save to field <energy>.",0)
	REGISTER_OPTION("/quantize_8","",LPMV(m_bQuantize8),NULL,"Quantize to 8 bit instead of 16 bit.",0)
	REGISTER_OPTION("/rmdc","",LPMV(m_bRmdc),NULL,"Remove DC mean from signal.",0)
	REGISTER_OPTION("/syn_enhancement","",LPMV(m_bSynEnhancement),NULL,"Apply feature dependend signal/feature enhancement methods.",0)
	REGISTER_OPTION("/syn_smooth_fea","",LPMV(m_bSynSmoothFea),NULL,"Smoothes features during synthesis.",0)
	REGISTER_OPTION("/syn_smooth_roots","",LPMV(m_bSynSmoothRoots),NULL,"Smoothes roots of features during synthesis.",0)
	REGISTER_OPTION("/time_domain_warping","",LPMV(m_bTimeDomainWarping),NULL,"Do warping in time domain.",0)

	// Register fields
	REGISTER_FIELD("base_f0","",LPMV(m_nBaseF0),NULL,"Mean base frequency (Hz) used for synthesis.",0,3004,1,"float",(FLOAT32)100.0)
	REGISTER_FIELD("base_i0","",LPMV(m_nBaseI0),NULL,"Mean intensity (dB) used for synthesis.",0,3004,1,"float",(FLOAT32)0.0)
	REGISTER_FIELD("crate","",LPMV(m_nCrate),NULL,"Continuation rate.",0,2004,1,"int",(INT32)160)
	REGISTER_FIELD("DC","",LPMV(m_nDC),NULL,"DC of input signal.",FF_NOSET,3008,1,"double",(FLOAT64)0.)
	REGISTER_FIELD("delta_table","",LPMV(m_idDeltaTable),NULL,"Table for controlling delta and delta-delta computation.",0,6002,1,"data",NULL)
	REGISTER_FIELD("delta_weights","",LPMV(m_idDeltaWeights),NULL,"Delta and delta-delta weighting vector.",0,6002,1,"data",NULL)
	REGISTER_FIELD("energy","",LPMV(m_idEnergy),NULL,"Energy per frame.",0,6002,1,"data",NULL)
	REGISTER_FIELD("exc","",LPMV(m_idExc),NULL,"Excitation signal used for synthesis.",0,6002,1,"data",NULL)
	REGISTER_FIELD("exc_type","",LPMV(m_lpsExcType),NULL,"Type of excitation generation.",0,2,2,"char[2]","R")
	REGISTER_FIELD("imag_frame","",LPMV(m_idImagFrame),NULL,"Internal field that holds the current analysis frame.",FF_HIDDEN | FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("labels","",LPMV(m_idLabels),NULL,"Label sequence.",0,6002,1,"data",NULL)
	REGISTER_FIELD("len","",LPMV(m_nLen),LPMF(CFBAproc,OnLenChanged),"Analysis length [samples].",0,2004,1,"int",(INT32)512)
	REGISTER_FIELD("matrix_analysis","",LPMV(m_nMatrixAnalysis),NULL,"Enable/disable matrix analysis.",0,2002,1,"short",(INT16)0)
	REGISTER_FIELD("min_log","",LPMV(m_nMinLog),NULL,"Floor value for logarithm.",FF_HIDDEN | FF_NOSET,3008,1,"double",(FLOAT64)-10.39720770839917918)
	REGISTER_FIELD("n_periods","",LPMV(m_nNPeriods),NULL,"Maximum number of periods per frame used in synchronuous analysis mode.",0,2002,1,"short",(INT16)2)
	REGISTER_FIELD("nse_flr","",LPMV(m_idNseFlr),LPMF(CFBAproc,OnNseFlrChanged),"Noise floor used for noise reduction",0,6002,1,"data",NULL)
	REGISTER_FIELD("nse_len","",LPMV(m_nNseLen),LPMF(CFBAproc,OnNseLenChanged),"Number frames in noise buffer",0,2004,1,"int",(INT32)300)
	REGISTER_FIELD("nse_prc","",LPMV(m_nNsePrc),LPMF(CFBAproc,OnNsePrcChanged),"Percentage for frames in noise buffer used for noise estimation",0,3008,1,"double",(FLOAT64)0.3)
	REGISTER_FIELD("nse_use","",LPMV(m_bNseUse),LPMF(CFBAproc,OnNseUseChanged),"Should the frames be use for noise estimation",0,1000,1,"bool",(BOOL)TRUE)
	REGISTER_FIELD("out_dim","",LPMV(m_nOutDim),NULL,"Number of output components.",0,2004,1,"int",(INT32)0)
	REGISTER_FIELD("pfa_lambda","",LPMV(m_nPfaLambda),LPMF(CFBAproc,OnPfaLambdaChanged),"Warping constant for bilinear transform at analysis.",0,3008,1,"double",(FLOAT64)0.0)
	REGISTER_FIELD("preem","",LPMV(m_nPreem),NULL,"Preemphasis coefficient.",0,3008,1,"double",(FLOAT64)0.0)
	REGISTER_FIELD("quantization","",LPMV(m_nQuantization),LPMF(CFBAproc,OnQuantizationChanged),"Resolution of input signal [Bit].",0,2002,1,"short",(INT16)16)
	REGISTER_FIELD("real_frame","",LPMV(m_idRealFrame),NULL,"Internal field that holds the current analysis frame.",FF_HIDDEN | FF_NOSET,6002,1,"data",NULL)
	REGISTER_FIELD("srate","",LPMV(m_nSrate),LPMF(CFBAproc,OnSrateChanged),"Sample rate.",0,3008,1,"double",(FLOAT64)16000.0)
	REGISTER_FIELD("syn_lambda","",LPMV(m_nSynLambda),NULL,"Warping constant for bilinear transform at synthesis.",0,3008,1,"double",(FLOAT64)0.0)
	REGISTER_FIELD("sync","",LPMV(m_nSync),NULL,"Pitch synchron/asynchron analysis/synthesis.",FF_NOSET,2002,1,"short",(INT16)FALSE)
	REGISTER_FIELD("type","",LPMV(m_lpsType),NULL,"Type of analysis used by classes derived from FBAproc.",0,255,255,"char[255]","LogFFT")
	REGISTER_FIELD("warp","",LPMV(m_idWarp),NULL,"Warping matrix for bilinear transform (used for VTN).",0,6002,1,"data",NULL)
	REGISTER_FIELD("window","",LPMV(m_idWindow),LPMF(CFBAproc,OnWindowChanged),"Wighting window data.",0,6002,1,"data",NULL)
	REGISTER_FIELD("wlen","",LPMV(m_nWlen),LPMF(CFBAproc,OnWlenChanged),"Window length [samples].",0,2004,1,"int",(INT32)400)
	REGISTER_FIELD("wnorm","",LPMV(m_nWnorm),NULL,"Enable/disable normalization of window energy.",0,2002,1,"short",(INT16)0)
	REGISTER_FIELD("wtype","",LPMV(m_lpsWtype),LPMF(CFBAproc,OnWtypeChanged),"Window type.",0,255,255,"char[255]","Blackman")

	// Register errors
	REGISTER_ERROR("~e1_0_0__1",EL_ERROR,FBA_BADNAME,"'%s' is not a valid %s type.")
	REGISTER_ERROR("~e2_0_0__1",EL_ERROR,FBA_BADINPUT,"'%s' does not contain valid input data. Make sure it has one numeric component. It may optionally have one symbolic label component.")
	REGISTER_ERROR("~e3_0_0__1",EL_ERROR,FBA_BADARG,"'%s' is not a valid argument for '%s'. Use '%s'.")
	REGISTER_ERROR("~e4_0_0__1",EL_ERROR,FBA_EXTWIN,"'%s' does not contain valid window data. Make sure it has one component and %d (wlen) records.")
	REGISTER_ERROR("~e5_0_0__1",EL_ERROR,FBA_BADPITCH,"'%s' does not contain valid pitch data. Make sure it has 2 numeric components at component 0 and 1.")
	REGISTER_ERROR("~e6_0_0__1",EL_ERROR,FBA_BADINTO,"'%s' does not contain valid into information. Make sure it has the right format.")
	REGISTER_ERROR("~e7_0_0__1",EL_ERROR,FBA_BADDELTATABLE,"The field delta_table does not hold a valid delta component lookup table. The table must have %d numeric components and 2 records!")
	REGISTER_ERROR("~e8_0_0__1",EL_WARNING,FBA_BADDELTAWEIGHTS,"Invalid delta weighting vector (field delta_weights) replaced by standard vector.")
	REGISTER_ERROR("~e9_0_0__1",EL_WARNING,FBA_BADSAMP,"Sampling rate of input data %s and %s are different.")
	REGISTER_ERROR("~e0_1_0__1",EL_WARNING,FBA_BADFRAMELEN,"Frame length %d not supported for analysis method %s.")
	REGISTER_ERROR("~e1_1_0__1",EL_WARNING,FBA_BADEXCLEN,"Length of excitation signal less then desired synthesis length.")
	REGISTER_ERROR("~e2_1_0__1",EL_WARNING,FBA_ANALYSE,"Analysis of frame %d failed.")
	REGISTER_ERROR("~e3_1_0__1",EL_WARNING,FBA_LABEL,"Loosing label(s) while framing due to short label length or high continuous rate or big frame length.")
	REGISTER_ERROR("~e4_1_0__1",EL_WARNING,FBA_SYNTHESISE,"Synthesis of frame %d failed. %s")
	REGISTER_ERROR("~e5_1_0__1",EL_WARNING,FBA_CRATE,"Continuous rate (%d) exceeds window len (%d).")
	REGISTER_ERROR("~e6_1_0__1",EL_ERROR,FBA_SYNINTOLAB,"Label of feature vectors does not match intonation control at label %s (no. %d).")
	REGISTER_ERROR("~e7_1_0__1",EL_ERROR,FBA_NOTIMPLEMENTED,"Feature %s currently not implemented.")
	//}}CGEN_REGISTERWORDS

	return O_K;
}

INT16 CFBAproc::Init(BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CFBAproc::Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	//{{CGEN_INITCODE
  INIT;

  // Adjust Output dimension
  m_nOutDim = m_nLen;
  if (m_idWindow   ) IDESTROY(m_idWindow   );
  if (m_idRealFrame) IDESTROY(m_idRealFrame);
  if (m_idImagFrame) IDESTROY(m_idImagFrame);
  if (m_idEnergy   ) IDESTROY(m_idEnergy   );

	//}}CGEN_INITCODE

	// If last derivation call reset (do not reset members; already done by Init())
	if (bCallVirtual) return Reset(FALSE);
	else              return O_K;
}

INT16 CFBAproc::Reset(BOOL bResetMembers)
{
	DEBUGMSG(-1,"CFBAproc::Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	//{{CGEN_RESETCODE

  RESET;

  // Init internal instances
  DeltaCheckWeights(TRUE);
  if (m_idWindow   ) IDESTROY(m_idWindow   );
  if (m_idRealFrame) IDESTROY(m_idRealFrame);
  if (m_idImagFrame) IDESTROY(m_idImagFrame);
  if (m_idEnergy   ) IDESTROY(m_idEnergy   );

	//}}CGEN_RESETCODE

	return O_K;
}

INT16 CFBAproc::ClassProc()
{
	//{{CGEN_CLASSCODE
  return CLASSPROC;
	//}}CGEN_CLASSCODE

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CFBAproc::Serialize(CDN3Stream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CFBAproc::SerializeXml(CXmlStream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CFBAproc::Deserialize(CDN3Stream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CFBAproc::DeserializeXml(CXmlStream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CFBAproc::Copy(CDlpObject* __iSrc)
{
	//{{CGEN_COPYCODE
  return COPY;
	//}}CGEN_COPYCODE

	return O_K;
}

// Runtime class type information and class factory
INT16 CFBAproc::InstallProc(void* lpItp)
{
	//{{CGEN_INSTALLCODE
  return INSTALL;
	//}}CGEN_INSTALLCODE

	return O_K;
}

CFBAproc* CFBAproc::CreateInstance(const char* lpName)
{
	CFBAproc* lpNewInstance;
	ICREATEEX(CFBAproc,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CFBAproc::GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOACTIVATE;
	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CFBAproc::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CFBAproc::InstallProc;
	lpClassWord->ex.fct.lpProject   = "FBAproc";
	lpClassWord->ex.fct.lpBaseClass = "-";
	lpClassWord->lpComment          = "Base class for frame based analysis classes.";
	lpClassWord->ex.fct.lpAutoname  = "";
	lpClassWord->ex.fct.lpCname     = "CFBAproc";
	lpClassWord->ex.fct.lpAuthor    = "Matthias Eichner";

	dlp_strcpy(lpClassWord->lpName             ,"FBAproc");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"1.0");

	return O_K;
}

INT16 CFBAproc::GetInstanceInfo(SWord* lpClassWord)
{
	return CFBAproc::GetClassInfo(lpClassWord);
}

BOOL CFBAproc::IsKindOf(const char* lpClassName)
{
  if (dlp_strncmp(lpClassName,"FBAproc",L_NAMES) == 0) return TRUE;
  else return inherited::IsKindOf(lpClassName);
}

INT16 CFBAproc::ResetAllOptions(BOOL bInit)
{
	DEBUGMSG(-1,"CFBAproc::ResetAllOptions;",0,0,0);
	//{{CGEN_RESETALLOPTIONS
	_this->m_bAnaSmoothFea = FALSE;
	_this->m_bAnaSmoothRoots = FALSE;
	_this->m_bDeltaMf = FALSE;
	_this->m_bEnergy = FALSE;
	_this->m_bLogEnergy = FALSE;
	_this->m_bQuantize8 = FALSE;
	_this->m_bRmdc = FALSE;
	_this->m_bSynEnhancement = FALSE;
	_this->m_bSynSmoothFea = FALSE;
	_this->m_bSynSmoothRoots = FALSE;
	_this->m_bTimeDomainWarping = FALSE;
	//}}CGEN_RESETALLOPTIONS

	return inherited::ResetAllOptions(bInit);
}

// Generated primary method invocation functions

#ifndef __NOITP
//{{CGEN_PMIC
INT16 CFBAproc::OnAdjustSpeechRate()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	FLOAT32 rate = (FLOAT32)MIC_GET_N(1,0);
	data* idNewFea = MIC_GET_I_EX(idNewFea,data,2,1);
	data* idFea = MIC_GET_I_EX(idFea,data,3,2);
	data* idNewPitch = MIC_GET_I_EX(idNewPitch,data,4,3);
	data* idPitch = MIC_GET_I_EX(idPitch,data,5,4);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = AdjustSpeechRate(idPitch, idNewPitch, idFea, idNewFea, rate);
	return __nErr;
}

INT16 CFBAproc::OnAlignFramesToPitch()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idNewFea = MIC_GET_I_EX(idNewFea,data,1,1);
	data* idFea = MIC_GET_I_EX(idFea,data,2,2);
	data* idPitch = MIC_GET_I_EX(idPitch,data,3,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = AlignFramesToPitch(idPitch, idFea, idNewFea);
	return __nErr;
}

INT16 CFBAproc::OnAnalyze()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idImag = MIC_GET_I_EX(idImag,data,1,1);
	data* idReal = MIC_GET_I_EX(idReal,data,2,2);
	data* idPitch = MIC_GET_I_EX(idPitch,data,3,3);
	data* idSignal = MIC_GET_I_EX(idSignal,data,4,4);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Analyze(idSignal, idPitch, idReal, idImag);
	return __nErr;
}

INT16 CFBAproc::OnCompressPitch()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	FLOAT32 factor = (FLOAT32)MIC_GET_N(1,0);
	data* idNewPitch = MIC_GET_I_EX(idNewPitch,data,2,1);
	data* idPitch = MIC_GET_I_EX(idPitch,data,3,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CompressPitch(idPitch, idNewPitch, factor);
	return __nErr;
}

INT16 CFBAproc::OnDelta()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* out = MIC_GET_I_EX(out,data,1,1);
	data* in = MIC_GET_I_EX(in,data,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Delta(in, out);
	return __nErr;
}

INT16 CFBAproc::OnFixed2floating()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* out = MIC_GET_I_EX(out,data,1,1);
	data* in = MIC_GET_I_EX(in,data,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Fixed2floating(in, out);
	return __nErr;
}

INT16 CFBAproc::OnFloating2fixed()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* out = MIC_GET_I_EX(out,data,1,1);
	data* in = MIC_GET_I_EX(in,data,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Floating2fixed(in, out);
	return __nErr;
}

INT16 CFBAproc::OnGenPitch()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idPitch = MIC_GET_I_EX(idPitch,data,1,1);
	data* idProso = MIC_GET_I_EX(idProso,data,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = GenPitch(idProso, idPitch);
	return __nErr;
}

INT16 CFBAproc::OnGetDurationsFromInventory()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idInto = MIC_GET_I_EX(idInto,data,1,1);
	data* idFea = MIC_GET_I_EX(idFea,data,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = GetDurationsFromInventory(idFea, idInto);
	return __nErr;
}

INT16 CFBAproc::OnModEx()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* dExcite = MIC_GET_I_EX(dExcite,data,1,1);
	data* dPitch = MIC_GET_I_EX(dPitch,data,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = ModEx(dPitch, dExcite);
	return __nErr;
}

INT16 CFBAproc::OnResamplePitch()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nFFreq = (INT32)MIC_GET_N(1,0);
	data* idNewPitch = MIC_GET_I_EX(idNewPitch,data,2,1);
	data* idPitch = MIC_GET_I_EX(idPitch,data,3,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = ResamplePitch(idPitch, idNewPitch, nFFreq);
	return __nErr;
}

INT16 CFBAproc::OnRootsTrack()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idVUV = MIC_GET_I_EX(idVUV,data,1,1);
	data* idImag = MIC_GET_I_EX(idImag,data,2,2);
	data* idReal = MIC_GET_I_EX(idReal,data,3,3);
	data* idFea = MIC_GET_I_EX(idFea,data,4,4);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = RootsTrack(idFea, idReal, idImag, idVUV);
	return __nErr;
}

INT16 CFBAproc::OnSmooth()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idOut = MIC_GET_I_EX(idOut,data,1,1);
	data* idPm = MIC_GET_I_EX(idPm,data,2,2);
	data* idIn = MIC_GET_I_EX(idIn,data,3,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Smooth(idIn, idPm, idOut);
	return __nErr;
}

INT16 CFBAproc::OnSynthesize()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idSyn = MIC_GET_I_EX(idSyn,data,1,1);
	data* idControl = MIC_GET_I_EX(idControl,data,2,2);
	data* idFea = MIC_GET_I_EX(idFea,data,3,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Synthesize(idFea, idControl, idSyn);
	return __nErr;
}

//}}CGEN_PMIC
#endif /* #ifndef __NOITP */


// Generated secondary method invocation functions

//{{CGEN_SMIC
INT16 CFBAproc::Delta(data* in, data* out)
{
    if (m_bDeltaMf)
      DeltaMF(in,out);
    else
      DeltaFBA(in,out);
	return O_K;
}

INT16 CFBAproc::Fixed2floating(data* in, data* out)
{
    IERROR(this,ERR_GENERIC,           "This method is deprecated. Use Used method -dequantize of class data instead.",0,0);
    CData_Quantize(in,out);
	return O_K;
}

INT16 CFBAproc::Floating2fixed(data* in, data* out)
{
    IERROR(this,ERR_GENERIC,           "This method is deprecated. Use Used method -quantize of class data instead.",0,0);
    CData_Dequantize(in,out);
	return O_K;
}

//}}CGEN_SMIC


// Generated option change callback functions

//{{CGEN_OCCF
//}}CGEN_OCCF


// Generated field change callback functions

//{{CGEN_FCCF
INT16 CFBAproc::OnLenChanged()
{
    if (m_idWindow   ) IDESTROY(m_idWindow   );
    if (m_idRealFrame) IDESTROY(m_idRealFrame);
    if (m_idImagFrame) IDESTROY(m_idImagFrame);
    if (m_idEnergy   ) IDESTROY(m_idEnergy   );

	return O_K;
}

INT16 CFBAproc::OnNseFlrChanged()
{
    if(CData_GetNComps(m_idNseFlr)!=1 || CData_GetCompType(m_idNseFlr,0)!=T_FLOAT){
      m_idNseFlr=NULL;
      IERROR(this,ERR_GENERIC,            "Noise floor data object does not contain only one component of type float.",0,0);
    }
    return dlm_noisesetup(m_nNseLen,m_nNsePrc,
        m_idNseFlr?(FLOAT32*)CData_XAddr(m_idNseFlr,0,0):NULL,
        m_idNseFlr?CData_GetNRecs(m_idNseFlr):0);

	return O_K;
}

INT16 CFBAproc::OnNseLenChanged()
{
    return dlm_noisesetup(m_nNseLen,m_nNsePrc,
        m_idNseFlr?(FLOAT32*)CData_XAddr(m_idNseFlr,0,0):NULL,
        m_idNseFlr?CData_GetNRecs(m_idNseFlr):0);

	return O_K;
}

INT16 CFBAproc::OnNsePrcChanged()
{
    return dlm_noisesetup(m_nNseLen,m_nNsePrc,
        m_idNseFlr?(FLOAT32*)CData_XAddr(m_idNseFlr,0,0):NULL,
        m_idNseFlr?CData_GetNRecs(m_idNseFlr):0);

	return O_K;
}

INT16 CFBAproc::OnNseUseChanged()
{
    return dlm_noisefrc(m_bNseUse);

	return O_K;
}

INT16 CFBAproc::OnPfaLambdaChanged()
{
    OnPfaLambdaChangedImpl();

	return O_K;
}

INT16 CFBAproc::OnQuantizationChanged()
{
           m_nMinLog=log(dlm_pow(2,-m_nQuantization+1));

	return O_K;
}

INT16 CFBAproc::OnSrateChanged()
{
    if (m_idWindow   ) IDESTROY(m_idWindow   );
    if (m_idRealFrame) IDESTROY(m_idRealFrame);
    if (m_idImagFrame) IDESTROY(m_idImagFrame);
    if (m_idEnergy   ) IDESTROY(m_idEnergy   );

	return O_K;
}

INT16 CFBAproc::OnWindowChanged()
{
      if(m_idWindow->GetNRecs()!=m_nWlen||m_idWindow->GetNComps()!=1)
        return IERROR(this,FBA_EXTWIN,m_idWindow->m_lpInstanceName,m_nWlen,0);
      else dlp_strcpy(m_lpsWtype,"Custom");

      m_idWindow->Tconvert(m_idWindow,T_DOUBLE);
      return MakeWindow(m_nWlen);

	return O_K;
}

INT16 CFBAproc::OnWlenChanged()
{
    if (m_idWindow   ) IDESTROY(m_idWindow   );

	return O_K;
}

INT16 CFBAproc::OnWtypeChanged()
{
       if (m_idWindow   ) IDESTROY(m_idWindow   );

	return O_K;
}

//}}CGEN_FCCF


// EOF
