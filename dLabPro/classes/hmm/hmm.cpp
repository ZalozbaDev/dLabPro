// dLabPro class CHmm (hmm)
// - Multiclass hidden Markov model
//
// AUTHOR : Matthias Wolff
// PACKAGE: dLabPro/classes
//
// This file was generated by dcg. DO NOT MODIFY! Modify hmm.def instead.
// 
// Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
// - Chair of System Theory and Speech Technology, TU Dresden
// - Chair of Communications Engineering, BTU Cottbus
// 
// This file is part of dLabPro.
// 
// dLabPro is free software: you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
// 
// dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
// details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with dLabPro. If not, see <http://www.gnu.org/licenses/>.


//{{CGEN_INCLUDE
//}}CGEN_END
#include "dlp_hmm.h"

// Class CHmm

CHmm::CHmm(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	DEBUGMSG(-1,"CHmm::CHmm; (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	dlp_strcpy(m_lpClassName,"hmm");
	dlp_strcpy(m_lpObsoleteName,"");
	dlp_strcpy(m_lpProjectName,"hmm");
	dlp_strcpy(m_version.no,"1.0.0");
	dlp_strcpy(m_version.date,"");
	m_nClStyle = CS_AUTOACTIVATE;

	if (bCallVirtual)
	{
		DLPASSERT(OK(AutoRegisterWords()));
		Init(TRUE);
	}
}

CHmm::~CHmm()
{
  //{{CGEN_DONECODE
  if(m_idBwalphaG) IDESTROY(m_idBwalphaG);
  if(m_idBwalphaH) IDESTROY(m_idBwalphaH);
  if(m_iBwalphaFstRev) IDESTROY(m_iBwalphaFstRev);
  DONE;
  //}}CGEN_DONECODE
}

INT16 CHmm::AutoRegisterWords()
{
	DEBUGMSG(-1,"CHmm::AutoRegisterWords",0,0,0);
	IF_NOK(inherited::AutoRegisterWords()) return NOT_EXEC;

	//{{CGEN_REGISTERWORDS
	REGISTER_METHOD("-best_n","",LPMF(CHmm,OnBestN),"Creates a tree with the best N paths taken from the source Fsm",0,"<hmm itSrc> <int nUnit> <int nPaths> <int nPathlength> <hmm this>","")
	REGISTER_METHOD("-bwalpha","",LPMF(CHmm,OnBwalpha),"calculate alpha values for baum-welch-training",0,"<int nUnit> <data idWeights> <data idAlpha> <hmm this>","")
	REGISTER_METHOD("-bwupdate","",LPMF(CHmm,OnBwupdate),"Update HMM with feature vectors (baum-welch-training).",0,"<data idAlpha> <data idMsf> <data idLsf> <int nUnit> <hmm this>","")
	REGISTER_METHOD("-cat","",LPMF(CHmm,OnCat),"Concatenates HMMs",0,"<hmm itSrc> <hmm this>","")
	REGISTER_METHOD("-cleanup","",LPMF(CHmm,OnCleanup),"Removes states and transitions not included in a path from start to end and deletes orphan gms",0,"<hmm itSrc> <hmm this>","")
	REGISTER_METHOD("-close","",LPMF(CHmm,OnClose),"Kleene closure",0,"<hmm itSrc> <int nUnit> <hmm this>","")
	REGISTER_METHOD("-compose","",LPMF(CHmm,OnCompose),"Composes weighted transducers",0,"<hmm itSrc1> <fst itSrc2> <int nUnit1> <int nUnit2> <hmm this>","")
	REGISTER_METHOD("-copy_fst","",LPMF(CHmm,OnCopyFst),"Copies the automata graphs from an FST instance.",0,"<fst itSrc> <hmm this>","")
	REGISTER_METHOD("-copy_ui","",LPMF(CHmm,OnCopyUi),"Copies HMMs according to a copying index.",0,"<hmm itSrc> <data idIndex> <int nPar> <hmm this>","")
	REGISTER_METHOD("-determinize","",LPMF(CHmm,OnDeterminize),"Determinizes a (weighted) acceptor or transducer",0,"<hmm itSrc> <int nUnit> <hmm this>","")
	REGISTER_METHOD("-epsremove","",LPMF(CHmm,OnEpsremove),"Removes epsilon transitions from automata",0,"<hmm itSrc> <int nUnit> <hmm this>","")
	REGISTER_METHOD("-gen_map","",LPMF(CHmm,OnGenMap),"Generate GMM index map for label sequence.",0,"<data idLab> <int nIcLab> <int nIcOfs> <int nIcLen> <data idMap> <hmm this>","")
	REGISTER_METHOD("-get_dim","",LPMF(CHmm,OnGetDim),"Get feature space dimensionality.",0,"<hmm this>","")
	REGISTER_METHOD("-gmm_mix","",LPMF(CHmm,GmmMix),"Combines Gaussians to mixtures",0,"<hmm this>","")
	REGISTER_METHOD("-hmm","",LPMF(CHmm,OnHmm),"Convert to HMM-style (weighted) acceptor or transducer",0,"<hmm itSrc> <int nUnit> <hmm this>","")
	REGISTER_METHOD("-intersect","",LPMF(CHmm,OnIntersect),"Calculates the intersection of weighted automata",0,"<hmm itSrc1> <hmm itSrc2> <int nUnit1> <int nUnit2> <hmm this>","")
	REGISTER_METHOD("-invert","",LPMF(CHmm,OnInvert),"Swap input and output symbols",0,"<int nUnit> <hmm this>","")
	REGISTER_METHOD("-merge_stats","",LPMF(CHmm,OnMergeStats),"Merges the internal statistics of two HMM instances",0,"<hmm iSrc> <hmm this>","")
	REGISTER_METHOD("-minimize","",LPMF(CHmm,OnMinimize),"Minimizes a (weighted) acceptor or transducer",0,"<hmm itSrc> <int nUnit> <hmm this>","")
	REGISTER_METHOD("-product","",LPMF(CHmm,OnProduct),"Calculates the cartesian product of two graphs",0,"<fst itSrc1> <fst itSrc2> <int nUnit1> <int nUnit2> <hmm this>","")
	REGISTER_METHOD("-project","",LPMF(CHmm,Project),"Remove output symbols",0,"<hmm this>","")
	REGISTER_METHOD("-reset_stats","",LPMF(CHmm,ResetStats),"Resets the internal statistics of an HMM instance.",0,"<hmm this>","")
	REGISTER_METHOD("-setup","",LPMF(CHmm,OnSetup),"Initilizes multiple HMMs.",0,"<int nMsf> <data idHmms> <hmm this>","")
	REGISTER_METHOD("-setup_ex","",LPMF(CHmm,OnSetupEx),"Initilizes multiple HMMs.",0,"<int nMsf> <data idHmms> <int nLsf> <int nPlf> <int nPsf> <int nPmf> <hmm this>","")
	REGISTER_METHOD("-setup_gmm","",LPMF(CHmm,OnSetupGmm),"(Re-)initializes the GMMs from the most significant feature statistics.",0,"<double mindet> <hmm this>","")
	REGISTER_METHOD("-split","",LPMF(CHmm,OnSplit),"Splits Gaussians and adjusts the HMM topology.",0,"<double nMinRc> <int nMaxCnt> <data idMap> <hmm this>","")
	REGISTER_METHOD("-tree","",LPMF(CHmm,OnTree),"Expands automaton graphs into trees",0,"<hmm itSrc> <int nUnit> <hmm this>","")
	REGISTER_METHOD("-union","",LPMF(CHmm,OnUnion),"Union",0,"<hmm itSrc> <hmm this>","")
	REGISTER_METHOD("-unweight","",LPMF(CHmm,Unweight),"Remove transition weights",0,"<hmm this>","")
	REGISTER_METHOD("-update","",LPMF(CHmm,OnUpdate),"Update HMM with feature vectors.",0,"<data idSrc> <int nIcTis> <int nIcTer> <data idMsf> <data idLsf> <int nUnit> <hmm this>","")
	REGISTER_OPTION("/byrc","",LPMV(m_bByrc),NULL,"Use RC instead of variance",0)
	REGISTER_OPTION("/fast","",LPMV(m_bFast),NULL,"Qick and dirty",0)
	REGISTER_OPTION("/nomix","",LPMV(m_bNomix),NULL,"Ignore mixture map",0)
	REGISTER_OPTION("/var","",LPMV(m_bVar),NULL,"Use variance vectors",0)

	// Register fields
	REGISTER_FIELD("bwalpha_fstrev","",LPMV(m_iBwalphaFstRev),NULL,"Internal use: Reverse fst of last alpha calculation",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6002,1,"fst",NULL)
	REGISTER_FIELD("bwalpha_g","",LPMV(m_idBwalphaG),NULL,"Internal use: Forward variables for alpha caluclation",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6002,1,"data",NULL)
	REGISTER_FIELD("bwalpha_h","",LPMV(m_idBwalphaH),NULL,"Internal use: Backward variables for alpha caluclation",FF_HIDDEN | FF_NOSET | FF_NOSAVE | FF_NONAUTOMATIC,6002,1,"data",NULL)
	REGISTER_FIELD("gm","",LPMV(m_iGm),NULL,"Gaussians associated with HMM transitions.",0,6002,1,"gmm",NULL)
	REGISTER_FIELD("grc","",LPMV(m_idGrc),NULL,"Gaussian reference counter",0,6002,1,"data",NULL)
	REGISTER_FIELD("lsmean","",LPMV(m_idLsmean),NULL,"Means of least significant features.",0,6002,1,"data",NULL)
	REGISTER_FIELD("pfsl","",LPMV(m_iPfsl),NULL,"Per frame statistics (least significant features).",0,6002,1,"statistics",NULL)
	REGISTER_FIELD("pfsm","",LPMV(m_iPfsm),NULL,"Per frame statistics (most significant features).",0,6002,1,"statistics",NULL)
	REGISTER_FIELD("pls","",LPMV(m_iPls),NULL,"Per HMM layer statistics.",0,6002,1,"statistics",NULL)
	REGISTER_FIELD("pms","",LPMV(m_iPms),NULL,"Per HMM statistics.",0,6002,1,"statistics",NULL)
	REGISTER_FIELD("pss","",LPMV(m_iPss),NULL,"Per HMM state statistics.",0,6002,1,"statistics",NULL)
	REGISTER_ERROR("~e4_2_0__1",EL_WARNING,HMM_DISCARDGMM,"Discarding GMM structures.")
	REGISTER_ERROR("~e5_2_0__1",EL_WARNING,HMM_BADNOLAB,"%ld labels for %ld feature vectors. Truncating %s.")
	REGISTER_ERROR("~e6_2_0__1",EL_WARNING,HMM_NOSPLIT,"No Gaussians split.")
	REGISTER_ERROR("~e7_2_0__1",EL_WARNING,HMM_INCOMPAT,"Incompatible statistics.")
	//}}CGEN_REGISTERWORDS

	return O_K;
}

INT16 CHmm::Init(BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CHmm::Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	//{{CGEN_INITCODE
  INIT;
	//}}CGEN_INITCODE

	// If last derivation call reset (do not reset members; already done by Init())
	if (bCallVirtual) return Reset(FALSE);
	else              return O_K;
}

INT16 CHmm::Reset(BOOL bResetMembers)
{
	DEBUGMSG(-1,"CHmm::Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	//{{CGEN_RESETCODE
  RESET;
  IFIELD_RESET(CData,"lsmean");
  IDESTROY(m_iGm  );
  IDESTROY(m_iPfsm);
  IDESTROY(m_iPfsl);
  IDESTROY(m_iPls );
  IDESTROY(m_iPss );
  IDESTROY(m_iPms );
  IDESTROY(m_idGrc);
  if(m_idBwalphaG) IDESTROY(m_idBwalphaG);
  if(m_idBwalphaH) IDESTROY(m_idBwalphaH);
  if(m_iBwalphaFstRev) IDESTROY(m_iBwalphaFstRev);
	//}}CGEN_RESETCODE

	return O_K;
}

INT16 CHmm::ClassProc()
{
	//{{CGEN_CLASSCODE
  return CLASSPROC;
	//}}CGEN_CLASSCODE

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CHmm::Serialize(CDN3Stream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CHmm::SerializeXml(CXmlStream* lpDest)
{
	//{{CGEN_SAVECODE
  return SAVE;
	//}}CGEN_SAVECODE

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CHmm::Deserialize(CDN3Stream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CHmm::DeserializeXml(CXmlStream* lpSrc)
{
	//{{CGEN_RESTORECODE
  return RESTORE;
	//}}CGEN_RESTORECODE

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CHmm::Copy(CDlpObject* __iSrc)
{
	//{{CGEN_COPYCODE
  return COPY;
	//}}CGEN_COPYCODE

	return O_K;
}

// Runtime class type information and class factory
INT16 CHmm::InstallProc(void* lpItp)
{
	//{{CGEN_INSTALLCODE
  return INSTALL;
	//}}CGEN_INSTALLCODE

	return O_K;
}

CHmm* CHmm::CreateInstance(const char* lpName)
{
	CHmm* lpNewInstance;
	ICREATEEX(CHmm,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CHmm::GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_AUTOACTIVATE;
	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CHmm::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CHmm::InstallProc;
	lpClassWord->ex.fct.lpProject   = "hmm";
	lpClassWord->ex.fct.lpBaseClass = "fst";
	lpClassWord->lpComment          = "Multiclass hidden Markov model";
	lpClassWord->ex.fct.lpAutoname  = "";
	lpClassWord->ex.fct.lpCname     = "CHmm";
	lpClassWord->ex.fct.lpAuthor    = "Matthias Wolff";

	dlp_strcpy(lpClassWord->lpName             ,"hmm");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"1.0.0");

	return O_K;
}

INT16 CHmm::GetInstanceInfo(SWord* lpClassWord)
{
	return CHmm::GetClassInfo(lpClassWord);
}

BOOL CHmm::IsKindOf(const char* lpClassName)
{
  if (dlp_strncmp(lpClassName,"hmm",L_NAMES) == 0) return TRUE;
  else return inherited::IsKindOf(lpClassName);
}

INT16 CHmm::ResetAllOptions(BOOL bInit)
{
	DEBUGMSG(-1,"CHmm::ResetAllOptions;",0,0,0);
	//{{CGEN_RESETALLOPTIONS
	_this->m_bByrc = FALSE;
	_this->m_bFast = FALSE;
	_this->m_bNomix = FALSE;
	_this->m_bVar = FALSE;
	//}}CGEN_RESETALLOPTIONS

	return inherited::ResetAllOptions(bInit);
}

// Generated primary method invocation functions

#ifndef __NOITP
//{{CGEN_PMIC
INT16 CHmm::OnBestN()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nPathlength = (INT32)MIC_GET_N(1,0);
	INT32 nPaths = (INT32)MIC_GET_N(2,1);
	INT32 nUnit = (INT32)MIC_GET_N(3,2);
	hmm* itSrc = MIC_GET_I_EX(itSrc,hmm,4,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = BestN(itSrc, nUnit, nPaths, nPathlength);
	return __nErr;
}

INT16 CHmm::OnBwalpha()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idAlpha = MIC_GET_I_EX(idAlpha,data,1,1);
	data* idWeights = MIC_GET_I_EX(idWeights,data,2,2);
	INT32 nUnit = (INT32)MIC_GET_N(3,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Bwalpha(nUnit, idWeights, idAlpha);
	return __nErr;
}

INT16 CHmm::OnBwupdate()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nUnit = (INT32)MIC_GET_N(1,0);
	data* idLsf = MIC_GET_I_EX(idLsf,data,2,1);
	data* idMsf = MIC_GET_I_EX(idMsf,data,3,2);
	data* idAlpha = MIC_GET_I_EX(idAlpha,data,4,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Bwupdate(idAlpha, idMsf, idLsf, nUnit);
	return __nErr;
}

INT16 CHmm::OnCat()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	hmm* itSrc = MIC_GET_I_EX(itSrc,hmm,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Cat(itSrc);
	return __nErr;
}

INT16 CHmm::OnCleanup()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	hmm* itSrc = MIC_GET_I_EX(itSrc,hmm,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Cleanup(itSrc);
	return __nErr;
}

INT16 CHmm::OnClose()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nUnit = (INT32)MIC_GET_N(1,0);
	hmm* itSrc = MIC_GET_I_EX(itSrc,hmm,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Close(itSrc, nUnit);
	return __nErr;
}

INT16 CHmm::OnCompose()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nUnit2 = (INT32)MIC_GET_N(1,0);
	INT32 nUnit1 = (INT32)MIC_GET_N(2,1);
	fst* itSrc2 = MIC_GET_I_EX(itSrc2,fst,3,1);
	hmm* itSrc1 = MIC_GET_I_EX(itSrc1,hmm,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Compose(itSrc1, itSrc2, nUnit1, nUnit2);
	return __nErr;
}

INT16 CHmm::OnCopyFst()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	fst* itSrc = MIC_GET_I_EX(itSrc,fst,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CopyFst(itSrc);
	return __nErr;
}

INT16 CHmm::OnCopyUi()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nPar = (INT32)MIC_GET_N(1,0);
	data* idIndex = MIC_GET_I_EX(idIndex,data,2,1);
	hmm* itSrc = MIC_GET_I_EX(itSrc,hmm,3,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CopyUi(itSrc, idIndex, nPar);
	return __nErr;
}

INT16 CHmm::OnDeterminize()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nUnit = (INT32)MIC_GET_N(1,0);
	hmm* itSrc = MIC_GET_I_EX(itSrc,hmm,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Determinize(itSrc, nUnit);
	return __nErr;
}

INT16 CHmm::OnEpsremove()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nUnit = (INT32)MIC_GET_N(1,0);
	hmm* itSrc = MIC_GET_I_EX(itSrc,hmm,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Epsremove(itSrc, nUnit);
	return __nErr;
}

INT16 CHmm::OnGenMap()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idMap = MIC_GET_I_EX(idMap,data,1,1);
	INT32 nIcLen = (INT32)MIC_GET_N(2,0);
	INT32 nIcOfs = (INT32)MIC_GET_N(3,1);
	INT32 nIcLab = (INT32)MIC_GET_N(4,2);
	data* idLab = MIC_GET_I_EX(idLab,data,5,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = GenMap(idLab, nIcLab, nIcOfs, nIcLen, idMap);
	return __nErr;
}

INT16 CHmm::OnGetDim()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_N(GetDim());
	return __nErr;
}

INT16 CHmm::OnHmm()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nUnit = (INT32)MIC_GET_N(1,0);
	hmm* itSrc = MIC_GET_I_EX(itSrc,hmm,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Hmm(itSrc, nUnit);
	return __nErr;
}

INT16 CHmm::OnIntersect()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nUnit2 = (INT32)MIC_GET_N(1,0);
	INT32 nUnit1 = (INT32)MIC_GET_N(2,1);
	hmm* itSrc2 = MIC_GET_I_EX(itSrc2,hmm,3,1);
	hmm* itSrc1 = MIC_GET_I_EX(itSrc1,hmm,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Intersect(itSrc1, itSrc2, nUnit1, nUnit2);
	return __nErr;
}

INT16 CHmm::OnInvert()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nUnit = (INT32)MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Invert(nUnit);
	return __nErr;
}

INT16 CHmm::OnMergeStats()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	hmm* iSrc = MIC_GET_I_EX(iSrc,hmm,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = MergeStats(iSrc);
	return __nErr;
}

INT16 CHmm::OnMinimize()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nUnit = (INT32)MIC_GET_N(1,0);
	hmm* itSrc = MIC_GET_I_EX(itSrc,hmm,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Minimize(itSrc, nUnit);
	return __nErr;
}

INT16 CHmm::OnProduct()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nUnit2 = (INT32)MIC_GET_N(1,0);
	INT32 nUnit1 = (INT32)MIC_GET_N(2,1);
	fst* itSrc2 = MIC_GET_I_EX(itSrc2,fst,3,1);
	fst* itSrc1 = MIC_GET_I_EX(itSrc1,fst,4,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Product(itSrc1, itSrc2, nUnit1, nUnit2);
	return __nErr;
}

INT16 CHmm::OnSetup()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idHmms = MIC_GET_I_EX(idHmms,data,1,1);
	INT32 nMsf = (INT32)MIC_GET_N(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Setup(nMsf, idHmms);
	return __nErr;
}

INT16 CHmm::OnSetupEx()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nPmf = (INT32)MIC_GET_N(1,0);
	INT32 nPsf = (INT32)MIC_GET_N(2,1);
	INT32 nPlf = (INT32)MIC_GET_N(3,2);
	INT32 nLsf = (INT32)MIC_GET_N(4,3);
	data* idHmms = MIC_GET_I_EX(idHmms,data,5,1);
	INT32 nMsf = (INT32)MIC_GET_N(6,4);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = SetupEx(nMsf, idHmms, nLsf, nPlf, nPsf, nPmf);
	return __nErr;
}

INT16 CHmm::OnSetupGmm()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	FLOAT64 mindet = MIC_GET_N(1,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = SetupGmm(mindet);
	return __nErr;
}

INT16 CHmm::OnSplit()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	data* idMap = MIC_GET_I_EX(idMap,data,1,1);
	INT32 nMaxCnt = (INT32)MIC_GET_N(2,0);
	FLOAT64 nMinRc = MIC_GET_N(3,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Split(nMinRc, nMaxCnt, idMap);
	return __nErr;
}

INT16 CHmm::OnTree()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nUnit = (INT32)MIC_GET_N(1,0);
	hmm* itSrc = MIC_GET_I_EX(itSrc,hmm,2,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Tree(itSrc, nUnit);
	return __nErr;
}

INT16 CHmm::OnUnion()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	hmm* itSrc = MIC_GET_I_EX(itSrc,hmm,1,1);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Union(itSrc);
	return __nErr;
}

INT16 CHmm::OnUpdate()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	INT32 nUnit = (INT32)MIC_GET_N(1,0);
	data* idLsf = MIC_GET_I_EX(idLsf,data,2,1);
	data* idMsf = MIC_GET_I_EX(idMsf,data,3,2);
	INT32 nIcTer = (INT32)MIC_GET_N(4,1);
	INT32 nIcTis = (INT32)MIC_GET_N(5,2);
	data* idSrc = MIC_GET_I_EX(idSrc,data,6,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = Update(idSrc, nIcTis, nIcTer, idMsf, idLsf, nUnit);
	return __nErr;
}

//}}CGEN_PMIC
#endif /* #ifndef __NOITP */


// Generated secondary method invocation functions

//{{CGEN_SMIC
INT16 CHmm::BestN(hmm* itSrc, INT32 nUnit, INT32 nPaths, INT32 nPathlength)
{
    return Op(itSrc,(CFst*)&nPathlength,(FLOAT64)nUnit,(FLOAT64)nPaths,AOP_BESTN);
	return O_K;
}

INT16 CHmm::Cat(hmm* itSrc)
{
    return CopyUiEx(itSrc,NULL,-1,TRUE);
	return O_K;
}

INT16 CHmm::Close(hmm* itSrc, INT32 nUnit)
{
    return Op(itSrc,NULL,(FLOAT64)nUnit,0.,AOP_CLOSE);
	return O_K;
}

INT16 CHmm::Compose(hmm* itSrc1, fst* itSrc2, INT32 nUnit1, INT32 nUnit2)
{
    return Op(itSrc1,itSrc2,(FLOAT64)nUnit1,(FLOAT64)nUnit2,AOP_CMPS);
	return O_K;
}

INT16 CHmm::CopyUi(hmm* itSrc, data* idIndex, INT32 nPar)
{
    return CopyUiEx(itSrc,idIndex,nPar,FALSE);
	return O_K;
}

INT16 CHmm::Determinize(hmm* itSrc, INT32 nUnit)
{
    return Op(itSrc,NULL,(FLOAT64)nUnit,0.,AOP_DET);
	return O_K;
}

INT16 CHmm::Epsremove(hmm* itSrc, INT32 nUnit)
{
    return Op(itSrc,NULL,(FLOAT64)nUnit,0.,AOP_ERM);
	return O_K;
}

INT16 CHmm::Hmm(hmm* itSrc, INT32 nUnit)
{
    return Op(itSrc,NULL,(FLOAT64)nUnit,0.,AOP_HMM);
	return O_K;
}

INT16 CHmm::Intersect(hmm* itSrc1, hmm* itSrc2, INT32 nUnit1, INT32 nUnit2)
{
    return Op(itSrc1,itSrc2,(double)nUnit1,(double)nUnit2,AOP_INTERS);
	return O_K;
}

INT16 CHmm::Invert(INT32 nUnit)
{
    return Op(NULL,NULL,(FLOAT64)nUnit,0.,AOP_INV);
	return O_K;
}

INT16 CHmm::Minimize(hmm* itSrc, INT32 nUnit)
{
    return Op(itSrc,NULL,(FLOAT64)nUnit,0.,AOP_MIN);
	return O_K;
}

INT16 CHmm::Product(fst* itSrc1, fst* itSrc2, INT32 nUnit1, INT32 nUnit2)
{
    return Op(itSrc1,itSrc2,(FLOAT64)nUnit1,(FLOAT64)nUnit2,AOP_PROD);
	return O_K;
}

INT16 CHmm::Project()
{
    return Op(NULL,NULL,0.,0.,AOP_PROJ);
	return O_K;
}

INT16 CHmm::Setup(INT32 nMsf, data* idHmms)
{
    return SetupEx(nMsf,idHmms,0,0,0,0);
	return O_K;
}

INT16 CHmm::Tree(hmm* itSrc, INT32 nUnit)
{
    return Op(itSrc,NULL,(FLOAT64)nUnit,0.,AOP_TREE);
	return O_K;
}

INT16 CHmm::Union(hmm* itSrc)
{
    return Op(itSrc,NULL,0.,0.,AOP_UNION);
	return O_K;
}

INT16 CHmm::Unweight()
{
    return Op(NULL,NULL,0.,0.,AOP_WRM);
	return O_K;
}

//}}CGEN_SMIC


// Generated option change callback functions

//{{CGEN_OCCF
//}}CGEN_OCCF


// Generated field change callback functions

//{{CGEN_FCCF
//}}CGEN_FCCF


// EOF
