/* dLabPro class CGmm (gmm)
 * - Header file
 *
 * AUTHOR : Matthias Wolff, Rainer Schaffer
 * PACKAGE: dLabPro/classes
 *
 * This file was generated by dcg. DO NOT MODIFY! Modify gmm.def instead.
 * 
 * Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
 * - Chair of System Theory and Speech Technology, TU Dresden
 * - Chair of Communications Engineering, BTU Cottbus
 * 
 * This file is part of dLabPro.
 * 
 * dLabPro is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 * 
 * dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with dLabPro. If not, see <http://www.gnu.org/licenses/>.
 */

/*{{CGEN_INCLUDE */
#include "dlp_config.h"
#include "dlp_object.h"
#include "dlp_vmap.h"
#include "dlp_matrix.h"
/*}}CGEN_END */

/*{{CGEN_ERRORS */
#undef GMM_NOTSETUP        
#undef GMM_DIM             
#undef GMM_RANK            
#undef GMM_IGNORE          
#undef GMM_INVALD          
#define GMM_NOTSETUP         -1001
#define GMM_DIM              -1002
#define GMM_RANK             -1003
#define GMM_IGNORE           -1004
#define GMM_INVALD           -1005
/*}}CGEN_END */

/* C/C++ language abstraction layer */
#undef gmm_par
#define gmm_par CGmm

/* dLabPro/C++ language abstraction layer */
#undef gmm
#define gmm CGmm

/*{{CGEN_DEFINE */
#define GMMG_MDIST  0
#define GMMG_LDENS  1
#define GMMG_NLDENS 2
#define GMMG_DENS   3
/*}}CGEN_DEFINE */

#ifndef __GMM_H
#define __GMM_H

/*{{CGEN_HEADERCODE */
/*}}CGEN_HEADERCODE */

/* Class CGmm */

#ifdef __cplusplus

class CGmm : public CDlpObject 
{

typedef CDlpObject inherited;
typedef CGmm thisclass;

/*{{CGEN_FRIENDS */
/*}}CGEN_FRIENDS */
public:
	CGmm(const char* lpInstanceName, BOOL bCallVirtual = 1);
	virtual ~CGmm();

/* Virtual and static function overrides */
public:
	virtual INT16 AutoRegisterWords();
	virtual INT16 Init(BOOL bCallVirtual = 0);
	virtual INT16 Reset(BOOL bResetMembers = 1);
	virtual INT16 Serialize(CDN3Stream* lpDest);
	virtual INT16 SerializeXml(CXmlStream* lpDest);
	virtual INT16 Deserialize(CDN3Stream* lpSrc);
	virtual INT16 DeserializeXml(CXmlStream* lpSrc);
	virtual INT16 Copy(CDlpObject* iSrc);
	virtual INT16 ClassProc();
	static  INT16 InstallProc(void* lpItp);
	static  CGmm* CreateInstance(const char* lpName);
	static  INT16 GetClassInfo(SWord* lpClassWord);
	virtual INT16 GetInstanceInfo(SWord* lpClassWord);
	virtual BOOL  IsKindOf(const char* lpClassName);
	virtual INT16 ResetAllOptions(BOOL bInit = 0);

/* Primary method invocation functions             */
/* DO NOT CALL THESE FUNCTIONS FROM C SCOPE.       */
/* THEY MAY INTERFERE WITH THE INTERPRETER SESSION */
#ifndef __NOITP
public:
/*{{CGEN_PMIC */
	INT16 OnDensity();
	INT16 OnDistance();
	INT16 OnExtract();
	INT16 OnGetNValidGauss();
	INT16 OnNoise();
	INT16 OnSetup();
	INT16 OnSetupEx();
	INT16 OnSplit();
	INT16 OnStatus();
/*}}CGEN_PMIC */
#endif /* #ifndef __NOITP */

/* Secondary method invocation functions */
public:
/*{{CGEN_SMIC */
	INT16 Density(data* idX, data* idXmap, data* idDens);
	INT16 Distance(data* idX, data* idXmap, data* idDist);
	INT16 Noise(INT64 nDim, INT64 nRecs, data* idDest);
	INT16 Setup(data* idMean, data* idCov, vmap* iMmap);
/*}}CGEN_SMIC */

/* Option changed callback functions */
public:
/*{{CGEN_OCCF */
	INT16 OnSse2Set();
/*}}CGEN_OCCF */

/* Field changed callback functions */
public:
/*{{CGEN_FCCF */
/*}}CGEN_FCCF */

/* Scanned member functions */
/*{{CGEN_EXPORT */

/* Taken from 'gmm_aux.c' */
	public: INT16 GetTypeEx(CData* idMean);
	public: INT16 GetType();
	public: INT32 GetDim();
	public: INT32 GetNMix();
	public: INT32 GetNGauss();
	public: INT32 GetNValidGauss();
	public: INT32 GetNIcov();
	public: FLOAT64 GetLimit(INT16 nMode);
	public: INT16 IsValidGauss(INT32 k);
	protected: INT16 CheckMean();
	protected: INT16 CheckIvar();
	protected: INT16 CheckCdet();
	protected: INT16 CheckIcov();
	protected: INT16 CheckMmap();
	protected: INT16 CheckCmap();
	protected: INT16 CheckPrecalc();
	public: INT16 Check();
	public: INT16 Status();

/* Taken from 'gmm_clst.c' */
	private: FLOAT64 Split_Icov(FLOAT64* lpMean, FLOAT64* lpCov, FLOAT64* lpMeanS1, FLOAT64* lpCovS1, FLOAT64* lpMeanS2, FLOAT64* lpCovS2, INT32 N);
	public: INT16 Split(FLOAT64 nParam, CData* idMap);

/* Taken from 'gmm_iam.c' */
	public: INT16 SetupEx(CData* idMean, CData* idCov, CVmap* iMmap, CData* idCmap, CData* idVar);
	public: INT16 Extract(CData* idMean, CData* idIcov);

/* Taken from 'gmm_work.c' */
	public: static BOOL Sse2();
	protected: INT32 Icov(CData* idCov, BOOL bIcov);
	private: void ClearGamma();
	protected: INT16 Precalc(BOOL bCleanup);
	protected: INT16 Gauss(CData* idX, CData* idXmap, CData* idDest, INT16 nMode);
/*}}CGEN_EXPORT */

/* Member variables */
public:
/*{{CGEN_ICXX_FIELDS */
	data*            m_idCdet;
	data*            m_idCmap;
	data*            m_idIcov;
	data*            m_idIvar;
	data*            m_idMean;
	vmap*            m_iMmap;
	data*            m_idSse2Icov;
/*}}CGEN_ICXX_FIELDS */

#else  /* #ifdef __cplusplus */

typedef struct CGmm
{
  /* Pointer to C base instance */
  struct CDlpObject* m_lpBaseInstance;

/*{{CGEN_IC_FIELDS */
	CDlpObject*      m_idCdet;
	CDlpObject*      m_idCmap;
	CDlpObject*      m_idIcov;
	CDlpObject*      m_idIvar;
	CDlpObject*      m_idMean;
	CDlpObject*      m_iMmap;
	CDlpObject*      m_idSse2Icov;
/*}}CGEN_IC_FIELDS */

#endif /* #ifdef __cplusplus */

/*{{CGEN_FIELDS */
	void*            m_lpAlpha;
	void*            m_lpBeta;
	FLOAT64          m_nDceil;
	void*            m_lpDelta;
	void*            m_lpGamma;
	void*            m_lpI;
	INT64            m_nK;
	INT64            m_nLDL;
	INT64            m_nLdlCoef;
	void*            m_lpLdlD;
	void*            m_lpLdlL;
	FLOAT64          m_nMindet;
	INT64            m_nN;
	void*            m_lpSse2Buf;
	INT16            m_nType;
	void*            m_lpV;
/*}}CGEN_FIELDS */

/*{{CGEN_OPTIONS */
	BOOL m_bDouble;
	BOOL m_bFloat;
	BOOL m_bIcov;
	BOOL m_bLdl;
	BOOL m_bLog;
	BOOL m_bNeglog;
	BOOL m_bNomix;
	BOOL m_bRandGaussBm;
	BOOL m_bRandGaussPolar;
	BOOL m_bSse2;
/*}}CGEN_OPTIONS */
}

#ifndef __cplusplus
CGmm
#endif
;

/* Class CGmm (C functions)*/

/* Virtual function overrides */
void  CGmm_Constructor(CGmm*, const char* lpInstanceName, BOOL bCallVirtual);
void  CGmm_Destructor(CDlpObject*);
INT16 CGmm_AutoRegisterWords(CDlpObject*);
INT16 CGmm_Reset(CDlpObject*, BOOL bResetMembers);
INT16 CGmm_Init(CDlpObject*, BOOL bCallVirtual);
INT16 CGmm_Serialize(CDlpObject*, CDN3Stream* lpDest);
INT16 CGmm_SerializeXml(CDlpObject*, CXmlStream* lpDest);
INT16 CGmm_Deserialize(CDlpObject*, CDN3Stream* lpSrc);
INT16 CGmm_DeserializeXml(CDlpObject*, CXmlStream* lpSrc);
INT16 CGmm_Copy(CDlpObject*, CDlpObject* __iSrc);
INT16 CGmm_ClassProc(CDlpObject*);
INT16 CGmm_InstallProc(void* lpItp);
CGmm* CGmm_CreateInstance(const char* lpName);
INT16 CGmm_GetClassInfo(SWord* lpClassWord);
INT16 CGmm_GetInstanceInfo(CDlpObject*, SWord* lpClassWord);
BOOL  CGmm_IsKindOf(CDlpObject*, const char* lpClassName);
INT16 CGmm_ResetAllOptions(CDlpObject*, BOOL bInit);

/* Primary method invocation functions             */
/* DO NOT CALL THESE FUNCTIONS FROM C SCOPE.       */
/* THEY MAY INTERFERE WITH THE INTERPRETER SESSION */
#ifndef __NOITP
/*{{CGEN_CPMIC */
INT16 CGmm_OnDensity(CDlpObject*);
INT16 CGmm_OnDistance(CDlpObject*);
INT16 CGmm_OnExtract(CDlpObject*);
INT16 CGmm_OnGetNValidGauss(CDlpObject*);
INT16 CGmm_OnNoise(CDlpObject*);
INT16 CGmm_OnSetup(CDlpObject*);
INT16 CGmm_OnSetupEx(CDlpObject*);
INT16 CGmm_OnSplit(CDlpObject*);
INT16 CGmm_OnStatus(CDlpObject*);
/*}}CGEN_CPMIC */
#endif /* #ifndef __NOITP */

/* Secondary method invocation functions */
/*{{CGEN_CSMIC */
INT16 CGmm_Density(CGmm*, data* idX, data* idXmap, data* idDens);
INT16 CGmm_Distance(CGmm*, data* idX, data* idXmap, data* idDist);
INT16 CGmm_Noise(CGmm*, INT64 nDim, INT64 nRecs, data* idDest);
INT16 CGmm_Setup(CGmm*, data* idMean, data* idCov, vmap* iMmap);
/*}}CGEN_CSMIC */

/* Option changed callback functions */
/*{{CGEN_COCCF */
INT16 CGmm_OnSse2Set(CDlpObject*);
/*}}CGEN_COCCF */

/* Field changed callback functions */
/*{{CGEN_CFCCF */
/*}}CGEN_CFCCF */

/* Scanned C (member) functions */
/*{{CGEN_CEXPORT */

/* Taken from 'gmm_aux.c' */
INT16 CGmm_GetTypeEx(CGmm*, CData* idMean);
INT16 CGmm_GetType(CGmm*);
INT32 CGmm_GetDim(CGmm*);
INT32 CGmm_GetNMix(CGmm*);
INT32 CGmm_GetNGauss(CGmm*);
INT32 CGmm_GetNValidGauss(CGmm*);
INT32 CGmm_GetNIcov(CGmm*);
FLOAT64 CGmm_GetLimit(CGmm*, INT16 nMode);
INT16 CGmm_IsValidGauss(CGmm*, INT32 k);
INT16 CGmm_CheckMean(CGmm*);
INT16 CGmm_CheckIvar(CGmm*);
INT16 CGmm_CheckCdet(CGmm*);
INT16 CGmm_CheckIcov(CGmm*);
INT16 CGmm_CheckMmap(CGmm*);
INT16 CGmm_CheckCmap(CGmm*);
INT16 CGmm_CheckPrecalc(CGmm*);
INT16 CGmm_Check(CGmm*);
INT16 CGmm_Status(CGmm*);

/* Taken from 'gmm_clst.c' */
FLOAT64 CGmm_Split_Icov(CGmm*, FLOAT64* lpMean, FLOAT64* lpCov, FLOAT64* lpMeanS1, FLOAT64* lpCovS1, FLOAT64* lpMeanS2, FLOAT64* lpCovS2, INT32 N);
INT16 CGmm_Split(CGmm*, FLOAT64 nParam, CData* idMap);

/* Taken from 'gmm_iam.c' */
INT16 CGmm_SetupEx(CGmm*, CData* idMean, CData* idCov, CVmap* iMmap, CData* idCmap, CData* idVar);
INT16 CGmm_Extract(CGmm*, CData* idMean, CData* idIcov);

/* Taken from 'gmm_work.c' */
BOOL CGmm_Sse2();
INT32 CGmm_Icov(CGmm*, CData* idCov, BOOL bIcov);
void CGmm_ClearGamma(CGmm*);
INT16 CGmm_Precalc(CGmm*, BOOL bCleanup);
INT16 CGmm_Gauss(CGmm*, CData* idX, CData* idXmap, CData* idDest, INT16 nMode);
/*}}CGEN_CEXPORT */

#endif /*#ifndef __GMM_H */


/* EOF */
