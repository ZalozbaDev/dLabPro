/* dLabPro class CFvrtools (fvrtools)
 * - FST-based feature-value relation processing tools
 *
 * AUTHOR : Matthias Wolff, Werner Meyer
 * PACKAGE: dLabPro/classes
 *
 * This file was generated by dcg. DO NOT MODIFY! Modify fvrtools.def instead.
 * 
 * Copyright 2013 dLabPro contributors and others (see COPYRIGHT file) 
 * - Chair of System Theory and Speech Technology, TU Dresden
 * - Chair of Communications Engineering, BTU Cottbus
 * 
 * This file is part of dLabPro.
 * 
 * dLabPro is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 * 
 * dLabPro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with dLabPro. If not, see <http://www.gnu.org/licenses/>.
 */

#include "dlp_cscope.h" /* Indicate C scope */
/*{{CGEN_INCLUDE */
/*}}CGEN_END */
#include "dlp_fvrtools.h"

/* Class CFvrtools */

void CFvrtools_Constructor(CFvrtools* _this, const char* lpInstanceName, BOOL bCallVirtual)
{
	DEBUGMSG(-1,"CFvrtools_Constructor; (bCallVirtual=%d)",(int)bCallVirtual,0,0);

#ifndef __cplusplus

	/* Register instance */
	dlp_xalloc_register_object('J',_this,1,sizeof(CFvrtools),
		__FILE__,__LINE__,"fvrtools",lpInstanceName);

	/* Create base instance */
	_this->m_lpBaseInstance = calloc(1,sizeof(CDlpObject));
	CDlpObject_Constructor(_this->m_lpBaseInstance,lpInstanceName,FALSE);

	/* Override virtual member functions */
	_this->m_lpBaseInstance->AutoRegisterWords = CFvrtools_AutoRegisterWords;
	_this->m_lpBaseInstance->Reset             = CFvrtools_Reset;
	_this->m_lpBaseInstance->Init              = CFvrtools_Init;
	_this->m_lpBaseInstance->Serialize         = CFvrtools_Serialize;
	_this->m_lpBaseInstance->SerializeXml      = CFvrtools_SerializeXml;
	_this->m_lpBaseInstance->Deserialize       = CFvrtools_Deserialize;
	_this->m_lpBaseInstance->DeserializeXml    = CFvrtools_DeserializeXml;
	_this->m_lpBaseInstance->Copy              = CFvrtools_Copy;
	_this->m_lpBaseInstance->ClassProc         = CFvrtools_ClassProc;
	_this->m_lpBaseInstance->GetInstanceInfo   = CFvrtools_GetInstanceInfo;
	_this->m_lpBaseInstance->IsKindOf          = CFvrtools_IsKindOf;
	_this->m_lpBaseInstance->Destructor        = CFvrtools_Destructor;
	_this->m_lpBaseInstance->ResetAllOptions   = CFvrtools_ResetAllOptions;

	/* Override pointer to derived instance */
	_this->m_lpBaseInstance->m_lpDerivedInstance = _this;

	#endif /* #ifndef __cplusplus */

	dlp_strcpy(BASEINST(_this)->m_lpClassName,"fvrtools");
	dlp_strcpy(BASEINST(_this)->m_lpObsoleteName,"");
	dlp_strcpy(BASEINST(_this)->m_lpProjectName,"fvrtools");
	dlp_strcpy(BASEINST(_this)->m_version.no,"1.0.0");
	dlp_strcpy(BASEINST(_this)->m_version.date,"");
	BASEINST(_this)->m_nClStyle = CS_SINGLETON;

	if (bCallVirtual)
	{
		DLPASSERT(OK(INVOKE_VIRTUAL_0(AutoRegisterWords)));
		INVOKE_VIRTUAL_1(Init,TRUE);
	}
}

void CFvrtools_Destructor(CDlpObject* __this)
{
	GET_THIS_VIRTUAL(CFvrtools);
	{
	/*{{CGEN_DONECODE */
  DONE;
	/*}}CGEN_DONECODE */
	}

#ifndef __cplusplus

	/* Destroy base instance */
	CDlpObject_Destructor(_this->m_lpBaseInstance);
	dlp_free(_this->m_lpBaseInstance);
	_this->m_lpBaseInstance = NULL;

#endif /* #ifndef __cplusplus */
}

INT16 CFvrtools_AutoRegisterWords(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	DEBUGMSG(-1,"CFvrtools_AutoRegisterWords",0,0,0);

	/* Call base class implementation */
	IF_NOK(INVOKE_BASEINST_0(AutoRegisterWords)) return NOT_EXEC;

	/*{{CGEN_REGISTERWORDS */

	/* Register methods */
	REGISTER_METHOD("-adjust","",LPMF(CFvrtools,OnAdjust),"Adjust a FVR with a given model of FVR and update both.",0,"<fst itWom> <fst itInp> <fst itQry> <fvrtools this>","")
	REGISTER_METHOD("-compare_with_model","",LPMF(CFvrtools,OnCompareWithModel),"Compare two FVRs each other.",0,"<fst itWom> <fst itInp> <fvrtools this>","")
	REGISTER_METHOD("-from_fst","",LPMF(CFvrtools,OnFromFst),"Creates a (weighted) FVR from an FST containing a single path.",0,"<fst itSeq> <fst itFvr> <fvrtools this>","")
	REGISTER_METHOD("-from_string","",LPMF(CFvrtools,OnFromString),"Creates a (weighted) FVR from a string representation",0,"<string src> <fst itFvr> <fvrtools this>","")
	REGISTER_METHOD("-fsg_fvr_check","",LPMF(CFvrtools,OnFsgFvrCheck),"Check square bracket parity in the output language of a FVR grammar.",0,"<fst itFsg> <fst itErr> <fvrtools this>","")
	REGISTER_METHOD("-fsg_normalize","",LPMF(CFvrtools,OnFsgNormalize),"...",0,"<fst itFsgSrc> <fst itFsgDst> <fvrtools this>","")
	REGISTER_METHOD("-hash","",LPMF(CFvrtools,OnHash),"Hashvalue for an FVR.",0,"<int nU> <fst itFvr> <fvrtools this>","")
	REGISTER_METHOD("-is_complete","",LPMF(CFvrtools,OnIsComplete),"Check itFvr is complete. All values are given.",0,"<int nU> <fst itFvr> <fvrtools this>","")
	REGISTER_METHOD("-is_fvr","",LPMF(CFvrtools,OnIsFvr),"Determines if the argument is an FVR",0,"<int nU> <fst itFvr> <fvrtools this>","")
	REGISTER_METHOD("-synthesize","",LPMF(CFvrtools,OnSynthesize),"Creates a FST list of all possible combinations of branches of a FVR",0,"<fst itDst> <fst itFvr> <fvrtools this>","")
	REGISTER_METHOD("-union","",LPMF(CFvrtools,OnUnion),"Combinates two FVRs",0,"<fst itDst> <fst itFvr> <fvrtools this>","")

	/* Register options */
	REGISTER_OPTION("/keepboth","",LPMV(m_bKeepboth),NULL,"Keep both (expectation and input) on double value entry by function union.",0)
	REGISTER_OPTION("/keepexpectation","",LPMV(m_bKeepexpectation),NULL,"Keep only expectation on double value entry by function union.",0)
	REGISTER_OPTION("/keepnothing","",LPMV(m_bKeepnothing),NULL,"Keep nothing on double value entry by function union.",0)
	REGISTER_OPTION("/nofvrcheck","",LPMV(m_bNofvrcheck),NULL,"Do not check for enclosing <code>'FVR[...]'</code>.",0)

	/* Register errors */
	REGISTER_ERROR("~e1_0_0__1",EL_ERROR,FVRT_SEQSYNTAX,"FVR string or sequence syntax error (%s)")
	REGISTER_ERROR("~e2_0_0__1",EL_ERROR,FVRT_NOTFVR,"'%s' is not a feature-value relation")
	REGISTER_ERROR("~e3_0_0__1",EL_WARNING,FVRT_EXTRATIS,"Ignored extra input symbol '%s' at transition %ld")
	REGISTER_ERROR("~e4_0_0__1",EL_WARNING,FVRT_NOTIS,"No input symbol at transition %ld")
	/*}}CGEN_REGISTERWORDS */

	return O_K;
}

INT16 CFvrtools_Init(CDlpObject* __this, BOOL bCallVirtual)
{
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	DEBUGMSG(-1,"CFvrtools_Init, (bCallVirtual=%d)",(int)bCallVirtual,0,0);
	{
	/*{{CGEN_INITCODE */
  INIT;
	/*}}CGEN_INITCODE */
	}

	/* If last derivation call reset (do not reset members; already done by Init()) */
#ifndef __NORTTI
	if (bCallVirtual) return INVOKE_VIRTUAL_1(Reset,FALSE); else
#endif
	                  return O_K;
}

INT16 CFvrtools_Reset(CDlpObject* __this, BOOL bResetMembers)
{
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	DEBUGMSG(-1,"CFvrtools_Reset; (bResetMembers=%d)",(int)bResetMembers,0,0);
	{
	/*{{CGEN_RESETCODE */
  return RESET;
	/*}}CGEN_RESETCODE */
	}

	return O_K;
}

INT16 CFvrtools_ClassProc(CDlpObject* __this)
{
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	{
	/*{{CGEN_CLASSCODE */
  return CLASSPROC;
	/*}}CGEN_CLASSCODE */
	}

	return O_K;
}

#define CODE_DN3 /* check this for xml specific save code */
#define SAVE  SAVE_DN3
INT16 CFvrtools_Serialize(CDlpObject* __this, CDN3Stream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
  return SAVE;
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific save code */
#define SAVE  SAVE_XML
INT16 CFvrtools_SerializeXml(CDlpObject* __this, CXmlStream* lpDest)
{
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	{
	/*{{CGEN_SAVECODE */
  return SAVE;
	/*}}CGEN_SAVECODE */
	}

	return O_K;
}
#undef  SAVE
#undef  CODE_XML

#define CODE_DN3 /* check this for dn3 specific restore code */
#define RESTORE  RESTORE_DN3
INT16 CFvrtools_Deserialize(CDlpObject* __this, CDN3Stream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
  return RESTORE;
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_DN3

#define CODE_XML /* check this for xml specific restore code */
#define RESTORE  RESTORE_XML
INT16 CFvrtools_DeserializeXml(CDlpObject* __this, CXmlStream* lpSrc)
{
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	{
	/*{{CGEN_RESTORECODE */
  return RESTORE;
	/*}}CGEN_RESTORECODE */
	}

	return O_K;
}
#undef  RESTORE
#undef  CODE_XML

INT16 CFvrtools_Copy(CDlpObject* __this, CDlpObject* __iSrc)
{
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	{
	/*{{CGEN_COPYCODE */
  return COPY;
	/*}}CGEN_COPYCODE */
	}

	return O_K;
}

/* Runtime class type information and class factory */
INT16 CFvrtools_InstallProc(void* lpItp)
{
	{
	/*{{CGEN_INSTALLCODE */
  return INSTALL;
	/*}}CGEN_INSTALLCODE */
	}

	return O_K;
}

CFvrtools* CFvrtools_CreateInstance(const char* lpName)
{
	CFvrtools* lpNewInstance;
	ICREATEEX(CFvrtools,lpNewInstance,lpName,NULL);
	return lpNewInstance;
}

INT16 CFvrtools_GetClassInfo(SWord* lpClassWord)
{
	if (!lpClassWord) return NOT_EXEC;
	dlp_memset(lpClassWord,0,sizeof(SWord));

	lpClassWord->nWordType          = WL_TYPE_FACTORY;
	lpClassWord->nFlags             = CS_SINGLETON;

#ifdef __cplusplus

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CFvrtools::CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CFvrtools::InstallProc;

#else /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpfFactory  = (LP_FACTORY_PROC)CFvrtools_CreateInstance;
	lpClassWord->ex.fct.lpfInstall  = CFvrtools_InstallProc;

#endif /* #ifdef __DLP_CSCOPE */

	lpClassWord->ex.fct.lpProject   = "fvrtools";
	lpClassWord->ex.fct.lpBaseClass = "-";
	lpClassWord->lpComment          = "FST-based feature-value relation processing tools";
	lpClassWord->ex.fct.lpAutoname  = "";
	lpClassWord->ex.fct.lpCname     = "CFvrtools";
	lpClassWord->ex.fct.lpAuthor    = "Matthias Wolff, Werner Meyer";

	dlp_strcpy(lpClassWord->lpName             ,"fvrtools");
	dlp_strcpy(lpClassWord->lpObsname          ,"");
	dlp_strcpy(lpClassWord->ex.fct.version.no  ,"1.0.0");

	return O_K;
}

INT16 CFvrtools_GetInstanceInfo(CDlpObject* __this, SWord* lpClassWord)
{
	return CFvrtools_GetClassInfo(lpClassWord);
}

BOOL CFvrtools_IsKindOf(CDlpObject* __this, const char* lpClassName)
{
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);

  if (dlp_strncmp(lpClassName,"fvrtools",L_NAMES) == 0) return TRUE;
	else return INVOKE_BASEINST_1(IsKindOf,lpClassName);
}

INT16 CFvrtools_ResetAllOptions(CDlpObject* __this, BOOL bInit)
{
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	DEBUGMSG(-1,"CFvrtools_ResetAllOptions;",0,0,0);
	{
	/*{{CGEN_RESETALLOPTIONS*/
	_this->m_bKeepboth = FALSE;
	_this->m_bKeepexpectation = FALSE;
	_this->m_bKeepnothing = FALSE;
	_this->m_bNofvrcheck = FALSE;
	/*}}CGEN_RESETALLOPTIONS*/
	}

	return INVOKE_BASEINST_1(ResetAllOptions,bInit);
}

/* Generated primary method invocation functions */

#ifndef __NOITP
/*{{CGEN_CPMIC */
INT16 CFvrtools_OnAdjust(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itWom;
	fst* itInp;
	fst* itQry;
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itQry = MIC_GET_I_EX(itQry,fst,1,1);
	itInp = MIC_GET_I_EX(itInp,fst,2,2);
	itWom = MIC_GET_I_EX(itWom,fst,3,3);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_B(CFvrtools_Adjust(_this, itWom, itInp, itQry));
	return __nErr;
}

INT16 CFvrtools_OnCompareWithModel(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itWom;
	fst* itInp;
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itInp = MIC_GET_I_EX(itInp,fst,1,1);
	itWom = MIC_GET_I_EX(itWom,fst,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_N(CFvrtools_CompareWithModel(_this, itWom, itInp));
	return __nErr;
}

INT16 CFvrtools_OnFromFst(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itSeq;
	fst* itFvr;
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itFvr = MIC_GET_I_EX(itFvr,fst,1,1);
	itSeq = MIC_GET_I_EX(itSeq,fst,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFvrtools_FromFst(_this, itSeq, itFvr);
	return __nErr;
}

INT16 CFvrtools_OnFromString(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	char* src;
	fst* itFvr;
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itFvr = MIC_GET_I_EX(itFvr,fst,1,1);
	src = MIC_GET_S(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFvrtools_FromString(_this, src, itFvr);
	return __nErr;
}

INT16 CFvrtools_OnFsgFvrCheck(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itFsg;
	fst* itErr;
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itErr = MIC_GET_I_EX(itErr,fst,1,1);
	itFsg = MIC_GET_I_EX(itFsg,fst,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_B(CFvrtools_FsgFvrCheck(_this, itFsg, itErr));
	return __nErr;
}

INT16 CFvrtools_OnFsgNormalize(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itFsgSrc;
	fst* itFsgDst;
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itFsgDst = MIC_GET_I_EX(itFsgDst,fst,1,1);
	itFsgSrc = MIC_GET_I_EX(itFsgSrc,fst,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFvrtools_FsgNormalize(_this, itFsgSrc, itFsgDst);
	return __nErr;
}

INT16 CFvrtools_OnHash(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nU;
	fst* itFvr;
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itFvr = MIC_GET_I_EX(itFvr,fst,1,1);
	nU = (INT32)MIC_GET_N(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_S(CFvrtools_Hash(_this, nU, itFvr));
	return __nErr;
}

INT16 CFvrtools_OnIsComplete(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nU;
	fst* itFvr;
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itFvr = MIC_GET_I_EX(itFvr,fst,1,1);
	nU = (INT32)MIC_GET_N(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_B(CFvrtools_IsComplete(_this, nU, itFvr));
	return __nErr;
}

INT16 CFvrtools_OnIsFvr(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	INT32 nU;
	fst* itFvr;
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itFvr = MIC_GET_I_EX(itFvr,fst,1,1);
	nU = (INT32)MIC_GET_N(2,0);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_B(CFvrtools_IsFvr(_this, nU, itFvr));
	return __nErr;
}

INT16 CFvrtools_OnSynthesize(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itDst;
	fst* itFvr;
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itFvr = MIC_GET_I_EX(itFvr,fst,1,1);
	itDst = MIC_GET_I_EX(itDst,fst,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	__nErr = CFvrtools_Synthesize(_this, itDst, itFvr);
	return __nErr;
}

INT16 CFvrtools_OnUnion(CDlpObject* __this)
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	INT16 __nErr    = O_K;
	INT32  __nErrCnt = 0;
	fst* itDst;
	fst* itFvr;
	GET_THIS_VIRTUAL_RV(CFvrtools,NOT_EXEC);
	MIC_CHECK;
	__nErrCnt = CDlpObject_GetErrorCount();
	itFvr = MIC_GET_I_EX(itFvr,fst,1,1);
	itDst = MIC_GET_I_EX(itDst,fst,2,2);
	if (CDlpObject_GetErrorCount()>__nErrCnt) return NOT_EXEC;
	MIC_PUT_B(CFvrtools_Union(_this, itDst, itFvr));
	return __nErr;
}

/*}}CGEN_CPMIC */
#endif /* #ifndef __NOITP */


/* Generated secondary method invocation functions */

/*{{CGEN_CSMIC */
/*}}CGEN_CSMIC */


/* Generated option change callback functions */

/*{{CGEN_COCCF */
/*}}CGEN_COCCF */


/* Generated field change callback functions */

/*{{CGEN_CFCCF */
/*}}CGEN_CFCCF */


/* C++ wrapper functions */
#ifdef __cplusplus

#define _this this

CFvrtools::CFvrtools(const char* lpInstanceName, BOOL bCallVirtual) : inherited(lpInstanceName,0)
{
	CFvrtools_Constructor(this,lpInstanceName,bCallVirtual);
}

CFvrtools::~CFvrtools()
{
	CFvrtools_Destructor(this);
}

INT16 CFvrtools::AutoRegisterWords()
{
	return CFvrtools_AutoRegisterWords(this);
}

INT16 CFvrtools::Init(BOOL bCallVirtual)
{
	return CFvrtools_Init(this,bCallVirtual);
}

INT16 CFvrtools::Reset(BOOL bResetMembers)
{
	return CFvrtools_Reset(this,bResetMembers);
}

INT16 CFvrtools::ClassProc()
{
	return CFvrtools_ClassProc(this);
}

INT16 CFvrtools::Serialize(CDN3Stream* lpDest)
{
	return CFvrtools_Serialize(this,lpDest);
}

INT16 CFvrtools::SerializeXml(CXmlStream* lpDest)
{
	return CFvrtools_SerializeXml(this,lpDest);
}

INT16 CFvrtools::Deserialize(CDN3Stream* lpSrc)
{
	return CFvrtools_Deserialize(this,lpSrc);
}

INT16 CFvrtools::DeserializeXml(CXmlStream* lpSrc)
{
	return CFvrtools_DeserializeXml(this,lpSrc);
}

INT16 CFvrtools::Copy(CDlpObject* __iSrc)
{
	return CFvrtools_Copy(this,__iSrc);
}

INT16 CFvrtools::InstallProc(void* lpItp)
{
	return CFvrtools_InstallProc(lpItp);
}

CFvrtools* CFvrtools::CreateInstance(const char* lpName)
{
	return CFvrtools_CreateInstance(lpName);
}

INT16 CFvrtools::GetClassInfo(SWord* lpClassWord)
{
	return CFvrtools_GetClassInfo(lpClassWord);
}

INT16 CFvrtools::GetInstanceInfo(SWord* lpClassWord)
{
	return CFvrtools_GetInstanceInfo(this,lpClassWord);
}

BOOL CFvrtools::IsKindOf(const char* lpClassName)
{
	return CFvrtools_IsKindOf(this,lpClassName);
}

INT16 CFvrtools::ResetAllOptions(BOOL bInit)
{
	return CFvrtools_ResetAllOptions(this,bInit);
}

#ifndef __NOITP
/*{{CGEN_PMIC */
INT16 CFvrtools::OnAdjust()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFvrtools_OnAdjust(this);
}

INT16 CFvrtools::OnCompareWithModel()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFvrtools_OnCompareWithModel(this);
}

INT16 CFvrtools::OnFromFst()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFvrtools_OnFromFst(this);
}

INT16 CFvrtools::OnFromString()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFvrtools_OnFromString(this);
}

INT16 CFvrtools::OnFsgFvrCheck()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFvrtools_OnFsgFvrCheck(this);
}

INT16 CFvrtools::OnFsgNormalize()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFvrtools_OnFsgNormalize(this);
}

INT16 CFvrtools::OnHash()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFvrtools_OnHash(this);
}

INT16 CFvrtools::OnIsComplete()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFvrtools_OnIsComplete(this);
}

INT16 CFvrtools::OnIsFvr()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFvrtools_OnIsFvr(this);
}

INT16 CFvrtools::OnSynthesize()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFvrtools_OnSynthesize(this);
}

INT16 CFvrtools::OnUnion()
/* DO NOT CALL THIS FUNCTION FROM C++ SCOPE.     */
/* IT MAY INTERFERE WITH THE INTERPRETER SESSION */
{
	return CFvrtools_OnUnion(this);
}

/*}}CGEN_PMIC */
#endif /* #ifndef __NOITP */

/*{{CGEN_SMIC */
/*}}CGEN_SMIC */

/*{{CGEN_OCCF */
/*}}CGEN_OCCF */

/*{{CGEN_FCCF */
/*}}CGEN_FCCF */

/*{{CGEN_CXXWRAP */
BOOL CFvrtools::IsFvr(INT32 nU, CFst* itFvr)
{
	return CFvrtools_IsFvr(this, nU, itFvr);
}

BOOL CFvrtools::IsComplete(INT32 nU, CFst* itFvr)
{
	return CFvrtools_IsComplete(this, nU, itFvr);
}

INT16 CFvrtools::FromString(const char* lpsSrc, CFst* itFvr)
{
	return CFvrtools_FromString(this, lpsSrc, itFvr);
}

INT16 CFvrtools::FromFst(CFst* itSeq, CFst* itFvr)
{
	return CFvrtools_FromFst(this, itSeq, itFvr);
}

INT16 CFvrtools::Synthesize(CFst* itDst, CFst* itFvr)
{
	return CFvrtools_Synthesize(this, itDst, itFvr);
}

BOOL CFvrtools::Union(CFst* itExp, CFst* itInp)
{
	return CFvrtools_Union(this, itExp, itInp);
}

BOOL CFvrtools::Adjust(CFst* itWom, CFst* itInp, CFst* itQry)
{
	return CFvrtools_Adjust(this, itWom, itInp, itQry);
}

FLOAT64 CFvrtools::CompareWithModel(CFst* itWom, CFst* itInp)
{
	return CFvrtools_CompareWithModel(this, itWom, itInp);
}

const char* CFvrtools::Hash(INT32 nU, CFst* itFvr)
{
	return CFvrtools_Hash(this, nU, itFvr);
}

FST_STYPE CFvrtools::FindIs(const char* lpsStr, BOOL bAdd, CFst* itFst)
{
	return CFvrtools_FindIs(lpsStr, bAdd, itFst);
}

FST_STYPE CFvrtools::FindOs(const char* lpsStr, BOOL bAdd, CFst* itFst)
{
	return CFvrtools_FindOs(lpsStr, bAdd, itFst);
}

void CFvrtools::AddToSeq(const char* lpsTok, INT32 nU, CFst* itSeq)
{
	CFvrtools_AddToSeq(this, lpsTok, nU, itSeq);
}

INT16 CFvrtools::CheckSeq(CFst* itSeq, CData* idS, INT32* pBO, INT32* pBC)
{
	return CFvrtools_CheckSeq(this, itSeq, idS, pBO, pBC);
}

INT16 CFvrtools::ParseSeq(CFst* itSeq, FST_ITYPE nIni, FST_ITYPE nPar, CFst* itFvr)
{
	return CFvrtools_ParseSeq(this, itSeq, nIni, nPar, itFvr);
}

INT16 CFvrtools::StrToSeq(const char* lpsSrc, CFst* itSeq)
{
	return CFvrtools_StrToSeq(this, lpsSrc, itSeq);
}

INT16 CFvrtools::SeqToFvr(CFst* itSeq, CFst* itFvr)
{
	return CFvrtools_SeqToFvr(this, itSeq, itFvr);
}

INT16 CFvrtools::FsgNormalize(CFst* itFsgSrc, CFst* itFsgDst)
{
	return CFvrtools_FsgNormalize(this, itFsgSrc, itFsgDst);
}

BOOL CFvrtools::FsgFvrCheck(CFst* itFsg, CFst* itErr)
{
	return CFvrtools_FsgFvrCheck(this, itFsg, itErr);
}

BOOL CFvrtools::ParseFsgCheck(CFst* itFsg, FST_ITYPE nMyIniState, CData* idVal)
{
	return CFvrtools_ParseFsgCheck(this, itFsg, nMyIniState, idVal);
}

/*}}CGEN_CXXWRAP */

#endif /* #ifdef __cplusplus */

/* EOF */
